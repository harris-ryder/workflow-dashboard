import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  bigint: { input: any; output: any; }
  date: { input: any; output: any; }
  float8: { input: any; output: any; }
  json: { input: any; output: any; }
  jsonb: { input: any; output: any; }
  numeric: { input: number; output: number; }
  timestamp: { input: string; output: string; }
  timestamptz: { input: string; output: string; }
  uuid: { input: string; output: string; }
};

/** Defines the status of the invoice. Enum table for Hasura. */
export type AccountInvoiceStripeStatuses = {
  __typename?: 'AccountInvoiceStripeStatuses';
  value: Scalars['String']['output'];
};

/** aggregated selection of "account_invoice_stripe_statuses" */
export type AccountInvoiceStripeStatusesAggregate = {
  __typename?: 'AccountInvoiceStripeStatusesAggregate';
  aggregate?: Maybe<AccountInvoiceStripeStatusesAggregateFields>;
  nodes: Array<AccountInvoiceStripeStatuses>;
};

/** aggregate fields of "account_invoice_stripe_statuses" */
export type AccountInvoiceStripeStatusesAggregateFields = {
  __typename?: 'AccountInvoiceStripeStatusesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<AccountInvoiceStripeStatusesMaxFields>;
  min?: Maybe<AccountInvoiceStripeStatusesMinFields>;
};


/** aggregate fields of "account_invoice_stripe_statuses" */
export type AccountInvoiceStripeStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AccountInvoiceStripeStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "account_invoice_stripe_statuses". All fields are combined with a logical 'AND'. */
export type AccountInvoiceStripeStatusesBoolExp = {
  _and?: InputMaybe<Array<AccountInvoiceStripeStatusesBoolExp>>;
  _not?: InputMaybe<AccountInvoiceStripeStatusesBoolExp>;
  _or?: InputMaybe<Array<AccountInvoiceStripeStatusesBoolExp>>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "account_invoice_stripe_statuses" */
export enum AccountInvoiceStripeStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  AccountInvoiceStripeStatusesPkey = 'account_invoice_stripe_statuses_pkey'
}

export enum AccountInvoiceStripeStatusesEnum {
  Draft = 'DRAFT',
  Open = 'OPEN',
  Paid = 'PAID',
  Uncollectible = 'UNCOLLECTIBLE',
  Void = 'VOID'
}

/** Boolean expression to compare columns of type "AccountInvoiceStripeStatusesEnum". All fields are combined with logical 'AND'. */
export type AccountInvoiceStripeStatusesEnumComparisonExp = {
  _eq?: InputMaybe<AccountInvoiceStripeStatusesEnum>;
  _in?: InputMaybe<Array<AccountInvoiceStripeStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<AccountInvoiceStripeStatusesEnum>;
  _nin?: InputMaybe<Array<AccountInvoiceStripeStatusesEnum>>;
};

/** input type for inserting data into table "account_invoice_stripe_statuses" */
export type AccountInvoiceStripeStatusesInsertInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type AccountInvoiceStripeStatusesMaxFields = {
  __typename?: 'AccountInvoiceStripeStatusesMaxFields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type AccountInvoiceStripeStatusesMinFields = {
  __typename?: 'AccountInvoiceStripeStatusesMinFields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "account_invoice_stripe_statuses" */
export type AccountInvoiceStripeStatusesMutationResponse = {
  __typename?: 'AccountInvoiceStripeStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AccountInvoiceStripeStatuses>;
};

/** on_conflict condition type for table "account_invoice_stripe_statuses" */
export type AccountInvoiceStripeStatusesOnConflict = {
  constraint: AccountInvoiceStripeStatusesConstraint;
  updateColumns?: Array<AccountInvoiceStripeStatusesUpdateColumn>;
  where?: InputMaybe<AccountInvoiceStripeStatusesBoolExp>;
};

/** Ordering options when selecting data from "account_invoice_stripe_statuses". */
export type AccountInvoiceStripeStatusesOrderBy = {
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: account_invoice_stripe_statuses */
export type AccountInvoiceStripeStatusesPkColumnsInput = {
  value: Scalars['String']['input'];
};

/** select columns of table "account_invoice_stripe_statuses" */
export enum AccountInvoiceStripeStatusesSelectColumn {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "account_invoice_stripe_statuses" */
export type AccountInvoiceStripeStatusesSetInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "account_invoice_stripe_statuses" */
export type AccountInvoiceStripeStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AccountInvoiceStripeStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AccountInvoiceStripeStatusesStreamCursorValueInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "account_invoice_stripe_statuses" */
export enum AccountInvoiceStripeStatusesUpdateColumn {
  /** column name */
  Value = 'value'
}

export type AccountInvoiceStripeStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AccountInvoiceStripeStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: AccountInvoiceStripeStatusesBoolExp;
};

/** Defines the type of invoice. Enum table for Hasura. */
export type AccountInvoiceTypes = {
  __typename?: 'AccountInvoiceTypes';
  value: Scalars['String']['output'];
};

/** aggregated selection of "account_invoice_types" */
export type AccountInvoiceTypesAggregate = {
  __typename?: 'AccountInvoiceTypesAggregate';
  aggregate?: Maybe<AccountInvoiceTypesAggregateFields>;
  nodes: Array<AccountInvoiceTypes>;
};

/** aggregate fields of "account_invoice_types" */
export type AccountInvoiceTypesAggregateFields = {
  __typename?: 'AccountInvoiceTypesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<AccountInvoiceTypesMaxFields>;
  min?: Maybe<AccountInvoiceTypesMinFields>;
};


/** aggregate fields of "account_invoice_types" */
export type AccountInvoiceTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AccountInvoiceTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "account_invoice_types". All fields are combined with a logical 'AND'. */
export type AccountInvoiceTypesBoolExp = {
  _and?: InputMaybe<Array<AccountInvoiceTypesBoolExp>>;
  _not?: InputMaybe<AccountInvoiceTypesBoolExp>;
  _or?: InputMaybe<Array<AccountInvoiceTypesBoolExp>>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "account_invoice_types" */
export enum AccountInvoiceTypesConstraint {
  /** unique or primary key constraint on columns "value" */
  AccountInvoiceTypesPkey = 'account_invoice_types_pkey'
}

export enum AccountInvoiceTypesEnum {
  Seats = 'SEATS',
  Storage = 'STORAGE'
}

/** Boolean expression to compare columns of type "AccountInvoiceTypesEnum". All fields are combined with logical 'AND'. */
export type AccountInvoiceTypesEnumComparisonExp = {
  _eq?: InputMaybe<AccountInvoiceTypesEnum>;
  _in?: InputMaybe<Array<AccountInvoiceTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<AccountInvoiceTypesEnum>;
  _nin?: InputMaybe<Array<AccountInvoiceTypesEnum>>;
};

/** input type for inserting data into table "account_invoice_types" */
export type AccountInvoiceTypesInsertInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type AccountInvoiceTypesMaxFields = {
  __typename?: 'AccountInvoiceTypesMaxFields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type AccountInvoiceTypesMinFields = {
  __typename?: 'AccountInvoiceTypesMinFields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "account_invoice_types" */
export type AccountInvoiceTypesMutationResponse = {
  __typename?: 'AccountInvoiceTypesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AccountInvoiceTypes>;
};

/** on_conflict condition type for table "account_invoice_types" */
export type AccountInvoiceTypesOnConflict = {
  constraint: AccountInvoiceTypesConstraint;
  updateColumns?: Array<AccountInvoiceTypesUpdateColumn>;
  where?: InputMaybe<AccountInvoiceTypesBoolExp>;
};

/** Ordering options when selecting data from "account_invoice_types". */
export type AccountInvoiceTypesOrderBy = {
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: account_invoice_types */
export type AccountInvoiceTypesPkColumnsInput = {
  value: Scalars['String']['input'];
};

/** select columns of table "account_invoice_types" */
export enum AccountInvoiceTypesSelectColumn {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "account_invoice_types" */
export type AccountInvoiceTypesSetInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "account_invoice_types" */
export type AccountInvoiceTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AccountInvoiceTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AccountInvoiceTypesStreamCursorValueInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "account_invoice_types" */
export enum AccountInvoiceTypesUpdateColumn {
  /** column name */
  Value = 'value'
}

export type AccountInvoiceTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AccountInvoiceTypesSetInput>;
  /** filter the rows which have to be updated */
  where: AccountInvoiceTypesBoolExp;
};

/** Invoices for an account. */
export type AccountInvoices = {
  __typename?: 'AccountInvoices';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** The amount of the invoice. */
  amount: Scalars['numeric']['output'];
  createdAt: Scalars['timestamp']['output'];
  id: Scalars['uuid']['output'];
  /** Whether the invoice has been paid. */
  isPaid: Scalars['Boolean']['output'];
  /** The ID of the invoice from Stripe. */
  stripeInvoiceId: Scalars['String']['output'];
  /** The status of the invoice from Stripe. */
  stripeStatus: AccountInvoiceStripeStatusesEnum;
  /** The ID of the subscription from Stripe. */
  stripeSubscriptionId: Scalars['String']['output'];
  /** The type of the invoice. See account_invoice_types table. */
  type: AccountInvoiceTypesEnum;
  updatedAt: Scalars['timestamp']['output'];
  /** The URL of the invoice from Stripe. */
  url?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "account_invoices" */
export type AccountInvoicesAggregate = {
  __typename?: 'AccountInvoicesAggregate';
  aggregate?: Maybe<AccountInvoicesAggregateFields>;
  nodes: Array<AccountInvoices>;
};

export type AccountInvoicesAggregateBoolExp = {
  bool_and?: InputMaybe<AccountInvoicesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<AccountInvoicesAggregateBoolExpBool_Or>;
  count?: InputMaybe<AccountInvoicesAggregateBoolExpCount>;
};

/** aggregate fields of "account_invoices" */
export type AccountInvoicesAggregateFields = {
  __typename?: 'AccountInvoicesAggregateFields';
  avg?: Maybe<AccountInvoicesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<AccountInvoicesMaxFields>;
  min?: Maybe<AccountInvoicesMinFields>;
  stddev?: Maybe<AccountInvoicesStddevFields>;
  stddevPop?: Maybe<AccountInvoicesStddevPopFields>;
  stddevSamp?: Maybe<AccountInvoicesStddevSampFields>;
  sum?: Maybe<AccountInvoicesSumFields>;
  varPop?: Maybe<AccountInvoicesVarPopFields>;
  varSamp?: Maybe<AccountInvoicesVarSampFields>;
  variance?: Maybe<AccountInvoicesVarianceFields>;
};


/** aggregate fields of "account_invoices" */
export type AccountInvoicesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AccountInvoicesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "account_invoices" */
export type AccountInvoicesAggregateOrderBy = {
  avg?: InputMaybe<AccountInvoicesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<AccountInvoicesMaxOrderBy>;
  min?: InputMaybe<AccountInvoicesMinOrderBy>;
  stddev?: InputMaybe<AccountInvoicesStddevOrderBy>;
  stddevPop?: InputMaybe<AccountInvoicesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<AccountInvoicesStddevSampOrderBy>;
  sum?: InputMaybe<AccountInvoicesSumOrderBy>;
  varPop?: InputMaybe<AccountInvoicesVarPopOrderBy>;
  varSamp?: InputMaybe<AccountInvoicesVarSampOrderBy>;
  variance?: InputMaybe<AccountInvoicesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "account_invoices" */
export type AccountInvoicesArrRelInsertInput = {
  data: Array<AccountInvoicesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<AccountInvoicesOnConflict>;
};

/** aggregate avg on columns */
export type AccountInvoicesAvgFields = {
  __typename?: 'AccountInvoicesAvgFields';
  /** The amount of the invoice. */
  amount?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "account_invoices" */
export type AccountInvoicesAvgOrderBy = {
  /** The amount of the invoice. */
  amount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "account_invoices". All fields are combined with a logical 'AND'. */
export type AccountInvoicesBoolExp = {
  _and?: InputMaybe<Array<AccountInvoicesBoolExp>>;
  _not?: InputMaybe<AccountInvoicesBoolExp>;
  _or?: InputMaybe<Array<AccountInvoicesBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  amount?: InputMaybe<NumericComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isPaid?: InputMaybe<BooleanComparisonExp>;
  stripeInvoiceId?: InputMaybe<StringComparisonExp>;
  stripeStatus?: InputMaybe<AccountInvoiceStripeStatusesEnumComparisonExp>;
  stripeSubscriptionId?: InputMaybe<StringComparisonExp>;
  type?: InputMaybe<AccountInvoiceTypesEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  url?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "account_invoices" */
export enum AccountInvoicesConstraint {
  /** unique or primary key constraint on columns "id" */
  AccountInvoicesPkey = 'account_invoices_pkey',
  /** unique or primary key constraint on columns "stripe_invoice_id" */
  IndexAccountInvoicesOnStripeInvoiceId = 'index_account_invoices_on_stripe_invoice_id'
}

/** input type for incrementing numeric columns in table "account_invoices" */
export type AccountInvoicesIncInput = {
  /** The amount of the invoice. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "account_invoices" */
export type AccountInvoicesInsertInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** The amount of the invoice. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the invoice has been paid. */
  isPaid?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the invoice from Stripe. */
  stripeInvoiceId?: InputMaybe<Scalars['String']['input']>;
  /** The status of the invoice from Stripe. */
  stripeStatus?: InputMaybe<AccountInvoiceStripeStatusesEnum>;
  /** The ID of the subscription from Stripe. */
  stripeSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  /** The type of the invoice. See account_invoice_types table. */
  type?: InputMaybe<AccountInvoiceTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The URL of the invoice from Stripe. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type AccountInvoicesMaxFields = {
  __typename?: 'AccountInvoicesMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** The amount of the invoice. */
  amount?: Maybe<Scalars['numeric']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** The ID of the invoice from Stripe. */
  stripeInvoiceId?: Maybe<Scalars['String']['output']>;
  /** The ID of the subscription from Stripe. */
  stripeSubscriptionId?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** The URL of the invoice from Stripe. */
  url?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "account_invoices" */
export type AccountInvoicesMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** The amount of the invoice. */
  amount?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** The ID of the invoice from Stripe. */
  stripeInvoiceId?: InputMaybe<OrderBy>;
  /** The ID of the subscription from Stripe. */
  stripeSubscriptionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** The URL of the invoice from Stripe. */
  url?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type AccountInvoicesMinFields = {
  __typename?: 'AccountInvoicesMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** The amount of the invoice. */
  amount?: Maybe<Scalars['numeric']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** The ID of the invoice from Stripe. */
  stripeInvoiceId?: Maybe<Scalars['String']['output']>;
  /** The ID of the subscription from Stripe. */
  stripeSubscriptionId?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** The URL of the invoice from Stripe. */
  url?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "account_invoices" */
export type AccountInvoicesMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** The amount of the invoice. */
  amount?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** The ID of the invoice from Stripe. */
  stripeInvoiceId?: InputMaybe<OrderBy>;
  /** The ID of the subscription from Stripe. */
  stripeSubscriptionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** The URL of the invoice from Stripe. */
  url?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "account_invoices" */
export type AccountInvoicesMutationResponse = {
  __typename?: 'AccountInvoicesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AccountInvoices>;
};

/** on_conflict condition type for table "account_invoices" */
export type AccountInvoicesOnConflict = {
  constraint: AccountInvoicesConstraint;
  updateColumns?: Array<AccountInvoicesUpdateColumn>;
  where?: InputMaybe<AccountInvoicesBoolExp>;
};

/** Ordering options when selecting data from "account_invoices". */
export type AccountInvoicesOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  amount?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isPaid?: InputMaybe<OrderBy>;
  stripeInvoiceId?: InputMaybe<OrderBy>;
  stripeStatus?: InputMaybe<OrderBy>;
  stripeSubscriptionId?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: account_invoices */
export type AccountInvoicesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "account_invoices" */
export enum AccountInvoicesSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsPaid = 'isPaid',
  /** column name */
  StripeInvoiceId = 'stripeInvoiceId',
  /** column name */
  StripeStatus = 'stripeStatus',
  /** column name */
  StripeSubscriptionId = 'stripeSubscriptionId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Url = 'url'
}

/** select "accountInvoicesAggregateBoolExpBool_andArgumentsColumns" columns of table "account_invoices" */
export enum AccountInvoicesSelectColumnAccountInvoicesAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsPaid = 'isPaid'
}

/** select "accountInvoicesAggregateBoolExpBool_orArgumentsColumns" columns of table "account_invoices" */
export enum AccountInvoicesSelectColumnAccountInvoicesAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsPaid = 'isPaid'
}

/** input type for updating data in table "account_invoices" */
export type AccountInvoicesSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** The amount of the invoice. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the invoice has been paid. */
  isPaid?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the invoice from Stripe. */
  stripeInvoiceId?: InputMaybe<Scalars['String']['input']>;
  /** The status of the invoice from Stripe. */
  stripeStatus?: InputMaybe<AccountInvoiceStripeStatusesEnum>;
  /** The ID of the subscription from Stripe. */
  stripeSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  /** The type of the invoice. See account_invoice_types table. */
  type?: InputMaybe<AccountInvoiceTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The URL of the invoice from Stripe. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type AccountInvoicesStddevFields = {
  __typename?: 'AccountInvoicesStddevFields';
  /** The amount of the invoice. */
  amount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "account_invoices" */
export type AccountInvoicesStddevOrderBy = {
  /** The amount of the invoice. */
  amount?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type AccountInvoicesStddevPopFields = {
  __typename?: 'AccountInvoicesStddevPopFields';
  /** The amount of the invoice. */
  amount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "account_invoices" */
export type AccountInvoicesStddevPopOrderBy = {
  /** The amount of the invoice. */
  amount?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type AccountInvoicesStddevSampFields = {
  __typename?: 'AccountInvoicesStddevSampFields';
  /** The amount of the invoice. */
  amount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "account_invoices" */
export type AccountInvoicesStddevSampOrderBy = {
  /** The amount of the invoice. */
  amount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "account_invoices" */
export type AccountInvoicesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AccountInvoicesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AccountInvoicesStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** The amount of the invoice. */
  amount?: InputMaybe<Scalars['numeric']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the invoice has been paid. */
  isPaid?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ID of the invoice from Stripe. */
  stripeInvoiceId?: InputMaybe<Scalars['String']['input']>;
  /** The status of the invoice from Stripe. */
  stripeStatus?: InputMaybe<AccountInvoiceStripeStatusesEnum>;
  /** The ID of the subscription from Stripe. */
  stripeSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  /** The type of the invoice. See account_invoice_types table. */
  type?: InputMaybe<AccountInvoiceTypesEnum>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The URL of the invoice from Stripe. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type AccountInvoicesSumFields = {
  __typename?: 'AccountInvoicesSumFields';
  /** The amount of the invoice. */
  amount?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "account_invoices" */
export type AccountInvoicesSumOrderBy = {
  /** The amount of the invoice. */
  amount?: InputMaybe<OrderBy>;
};

/** update columns of table "account_invoices" */
export enum AccountInvoicesUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsPaid = 'isPaid',
  /** column name */
  StripeInvoiceId = 'stripeInvoiceId',
  /** column name */
  StripeStatus = 'stripeStatus',
  /** column name */
  StripeSubscriptionId = 'stripeSubscriptionId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Url = 'url'
}

export type AccountInvoicesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AccountInvoicesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AccountInvoicesSetInput>;
  /** filter the rows which have to be updated */
  where: AccountInvoicesBoolExp;
};

/** aggregate varPop on columns */
export type AccountInvoicesVarPopFields = {
  __typename?: 'AccountInvoicesVarPopFields';
  /** The amount of the invoice. */
  amount?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "account_invoices" */
export type AccountInvoicesVarPopOrderBy = {
  /** The amount of the invoice. */
  amount?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type AccountInvoicesVarSampFields = {
  __typename?: 'AccountInvoicesVarSampFields';
  /** The amount of the invoice. */
  amount?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "account_invoices" */
export type AccountInvoicesVarSampOrderBy = {
  /** The amount of the invoice. */
  amount?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type AccountInvoicesVarianceFields = {
  __typename?: 'AccountInvoicesVarianceFields';
  /** The amount of the invoice. */
  amount?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "account_invoices" */
export type AccountInvoicesVarianceOrderBy = {
  /** The amount of the invoice. */
  amount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "account_user_roles" */
export type AccountUserRoles = {
  __typename?: 'AccountUserRoles';
  value: Scalars['String']['output'];
};

/** aggregated selection of "account_user_roles" */
export type AccountUserRolesAggregate = {
  __typename?: 'AccountUserRolesAggregate';
  aggregate?: Maybe<AccountUserRolesAggregateFields>;
  nodes: Array<AccountUserRoles>;
};

/** aggregate fields of "account_user_roles" */
export type AccountUserRolesAggregateFields = {
  __typename?: 'AccountUserRolesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<AccountUserRolesMaxFields>;
  min?: Maybe<AccountUserRolesMinFields>;
};


/** aggregate fields of "account_user_roles" */
export type AccountUserRolesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AccountUserRolesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "account_user_roles". All fields are combined with a logical 'AND'. */
export type AccountUserRolesBoolExp = {
  _and?: InputMaybe<Array<AccountUserRolesBoolExp>>;
  _not?: InputMaybe<AccountUserRolesBoolExp>;
  _or?: InputMaybe<Array<AccountUserRolesBoolExp>>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "account_user_roles" */
export enum AccountUserRolesConstraint {
  /** unique or primary key constraint on columns "value" */
  AccountUserRolesPkey = 'account_user_roles_pkey'
}

export enum AccountUserRolesEnum {
  Creative = 'CREATIVE',
  Teammate = 'TEAMMATE'
}

/** Boolean expression to compare columns of type "AccountUserRolesEnum". All fields are combined with logical 'AND'. */
export type AccountUserRolesEnumComparisonExp = {
  _eq?: InputMaybe<AccountUserRolesEnum>;
  _in?: InputMaybe<Array<AccountUserRolesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<AccountUserRolesEnum>;
  _nin?: InputMaybe<Array<AccountUserRolesEnum>>;
};

/** input type for inserting data into table "account_user_roles" */
export type AccountUserRolesInsertInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type AccountUserRolesMaxFields = {
  __typename?: 'AccountUserRolesMaxFields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type AccountUserRolesMinFields = {
  __typename?: 'AccountUserRolesMinFields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "account_user_roles" */
export type AccountUserRolesMutationResponse = {
  __typename?: 'AccountUserRolesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AccountUserRoles>;
};

/** on_conflict condition type for table "account_user_roles" */
export type AccountUserRolesOnConflict = {
  constraint: AccountUserRolesConstraint;
  updateColumns?: Array<AccountUserRolesUpdateColumn>;
  where?: InputMaybe<AccountUserRolesBoolExp>;
};

/** Ordering options when selecting data from "account_user_roles". */
export type AccountUserRolesOrderBy = {
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: account_user_roles */
export type AccountUserRolesPkColumnsInput = {
  value: Scalars['String']['input'];
};

/** select columns of table "account_user_roles" */
export enum AccountUserRolesSelectColumn {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "account_user_roles" */
export type AccountUserRolesSetInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "account_user_roles" */
export type AccountUserRolesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AccountUserRolesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AccountUserRolesStreamCursorValueInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "account_user_roles" */
export enum AccountUserRolesUpdateColumn {
  /** column name */
  Value = 'value'
}

export type AccountUserRolesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AccountUserRolesSetInput>;
  /** filter the rows which have to be updated */
  where: AccountUserRolesBoolExp;
};

/** Join table between account and user, defines the relationship between users (individual log in credentials) and accounts (workspaces) With replicache, users must have an account user if they have access to any data in that account The permission level of the user is defined by the fields guest and is_view_only. */
export type AccountUsers = {
  __typename?: 'AccountUsers';
  /** An object relationship */
  account: Accounts;
  accountId: Scalars['uuid']['output'];
  /** [Replicache] - the background colour for the user's icon when they do not have a profile picture. this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  color?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['timestamp']['output'];
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The email is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  email?: Maybe<Scalars['String']['output']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The first_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  firstName?: Maybe<Scalars['String']['output']>;
  /** [Permissions] - to revisit naming and use */
  guest: Scalars['Boolean']['output'];
  id: Scalars['uuid']['output'];
  /** [Permissions] - to revisit naming and use */
  isViewOnly?: Maybe<Scalars['Boolean']['output']>;
  /** check if used, potentially remove. Was used for  */
  kanbanDisplaySettings?: Maybe<Scalars['jsonb']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  lastName?: Maybe<Scalars['String']['output']>;
  /** remove */
  lastViewedFeedAt?: Maybe<Scalars['timestamp']['output']>;
  /** remove */
  lastViewedRecentAt?: Maybe<Scalars['timestamp']['output']>;
  /** remove */
  lastViewedSharedAt?: Maybe<Scalars['timestamp']['output']>;
  /** check if used, potentially remove */
  position: Scalars['Int']['output'];
  role?: Maybe<AccountUserRolesEnum>;
  /** remove */
  showRecent: Scalars['Boolean']['output'];
  /** remove */
  showShared: Scalars['Boolean']['output'];
  /** [Slack integration] The slack bot needs to know the email of the user in Slack to send them a message */
  slackEmail?: Maybe<Scalars['String']['output']>;
  /** [Slack integration] The Slack bot saves the ID of the user within Slack's database after finding the user via their email, then uses the ID to send messages to this user */
  slackId?: Maybe<Scalars['String']['output']>;
  /** remove */
  swimlaneOpen: Scalars['Boolean']['output'];
  updatedAt: Scalars['timestamp']['output'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid']['output'];
};


/** Join table between account and user, defines the relationship between users (individual log in credentials) and accounts (workspaces) With replicache, users must have an account user if they have access to any data in that account The permission level of the user is defined by the fields guest and is_view_only. */
export type AccountUsersKanbanDisplaySettingsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "account_users" */
export type AccountUsersAggregate = {
  __typename?: 'AccountUsersAggregate';
  aggregate?: Maybe<AccountUsersAggregateFields>;
  nodes: Array<AccountUsers>;
};

export type AccountUsersAggregateBoolExp = {
  bool_and?: InputMaybe<AccountUsersAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<AccountUsersAggregateBoolExpBool_Or>;
  count?: InputMaybe<AccountUsersAggregateBoolExpCount>;
};

/** aggregate fields of "account_users" */
export type AccountUsersAggregateFields = {
  __typename?: 'AccountUsersAggregateFields';
  avg?: Maybe<AccountUsersAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<AccountUsersMaxFields>;
  min?: Maybe<AccountUsersMinFields>;
  stddev?: Maybe<AccountUsersStddevFields>;
  stddevPop?: Maybe<AccountUsersStddevPopFields>;
  stddevSamp?: Maybe<AccountUsersStddevSampFields>;
  sum?: Maybe<AccountUsersSumFields>;
  varPop?: Maybe<AccountUsersVarPopFields>;
  varSamp?: Maybe<AccountUsersVarSampFields>;
  variance?: Maybe<AccountUsersVarianceFields>;
};


/** aggregate fields of "account_users" */
export type AccountUsersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AccountUsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "account_users" */
export type AccountUsersAggregateOrderBy = {
  avg?: InputMaybe<AccountUsersAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<AccountUsersMaxOrderBy>;
  min?: InputMaybe<AccountUsersMinOrderBy>;
  stddev?: InputMaybe<AccountUsersStddevOrderBy>;
  stddevPop?: InputMaybe<AccountUsersStddevPopOrderBy>;
  stddevSamp?: InputMaybe<AccountUsersStddevSampOrderBy>;
  sum?: InputMaybe<AccountUsersSumOrderBy>;
  varPop?: InputMaybe<AccountUsersVarPopOrderBy>;
  varSamp?: InputMaybe<AccountUsersVarSampOrderBy>;
  variance?: InputMaybe<AccountUsersVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AccountUsersAppendInput = {
  /** check if used, potentially remove. Was used for  */
  kanbanDisplaySettings?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "account_users" */
export type AccountUsersArrRelInsertInput = {
  data: Array<AccountUsersInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<AccountUsersOnConflict>;
};

/** aggregate avg on columns */
export type AccountUsersAvgFields = {
  __typename?: 'AccountUsersAvgFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check if used, potentially remove */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "account_users" */
export type AccountUsersAvgOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check if used, potentially remove */
  position?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "account_users". All fields are combined with a logical 'AND'. */
export type AccountUsersBoolExp = {
  _and?: InputMaybe<Array<AccountUsersBoolExp>>;
  _not?: InputMaybe<AccountUsersBoolExp>;
  _or?: InputMaybe<Array<AccountUsersBoolExp>>;
  account?: InputMaybe<AccountsBoolExp>;
  accountId?: InputMaybe<UuidComparisonExp>;
  color?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  firstName?: InputMaybe<StringComparisonExp>;
  guest?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isViewOnly?: InputMaybe<BooleanComparisonExp>;
  kanbanDisplaySettings?: InputMaybe<JsonbComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  lastName?: InputMaybe<StringComparisonExp>;
  lastViewedFeedAt?: InputMaybe<TimestampComparisonExp>;
  lastViewedRecentAt?: InputMaybe<TimestampComparisonExp>;
  lastViewedSharedAt?: InputMaybe<TimestampComparisonExp>;
  position?: InputMaybe<IntComparisonExp>;
  role?: InputMaybe<AccountUserRolesEnumComparisonExp>;
  showRecent?: InputMaybe<BooleanComparisonExp>;
  showShared?: InputMaybe<BooleanComparisonExp>;
  slackEmail?: InputMaybe<StringComparisonExp>;
  slackId?: InputMaybe<StringComparisonExp>;
  swimlaneOpen?: InputMaybe<BooleanComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "account_users" */
export enum AccountUsersConstraint {
  /** unique or primary key constraint on columns "id" */
  AccountUsersPkey = 'account_users_pkey',
  /** unique or primary key constraint on columns "user_id", "account_id" */
  IndexAccountUsersOnAccountIdAndUserId = 'index_account_users_on_account_id_and_user_id'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AccountUsersDeleteAtPathInput = {
  /** check if used, potentially remove. Was used for  */
  kanbanDisplaySettings?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AccountUsersDeleteElemInput = {
  /** check if used, potentially remove. Was used for  */
  kanbanDisplaySettings?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AccountUsersDeleteKeyInput = {
  /** check if used, potentially remove. Was used for  */
  kanbanDisplaySettings?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "account_users" */
export type AccountUsersIncInput = {
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** check if used, potentially remove */
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "account_users" */
export type AccountUsersInsertInput = {
  account?: InputMaybe<AccountsObjRelInsertInput>;
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [Replicache] - the background colour for the user's icon when they do not have a profile picture. this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  color?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The email is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The first_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** [Permissions] - to revisit naming and use */
  guest?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [Permissions] - to revisit naming and use */
  isViewOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** check if used, potentially remove. Was used for  */
  kanbanDisplaySettings?: InputMaybe<Scalars['jsonb']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  lastViewedFeedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** remove */
  lastViewedRecentAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** remove */
  lastViewedSharedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** check if used, potentially remove */
  position?: InputMaybe<Scalars['Int']['input']>;
  role?: InputMaybe<AccountUserRolesEnum>;
  /** remove */
  showRecent?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove */
  showShared?: InputMaybe<Scalars['Boolean']['input']>;
  /** [Slack integration] The slack bot needs to know the email of the user in Slack to send them a message */
  slackEmail?: InputMaybe<Scalars['String']['input']>;
  /** [Slack integration] The Slack bot saves the ID of the user within Slack's database after finding the user via their email, then uses the ID to send messages to this user */
  slackId?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  swimlaneOpen?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type AccountUsersMaxFields = {
  __typename?: 'AccountUsersMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** [Replicache] - the background colour for the user's icon when they do not have a profile picture. this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  color?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The email is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  email?: Maybe<Scalars['String']['output']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The first_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  lastName?: Maybe<Scalars['String']['output']>;
  /** remove */
  lastViewedFeedAt?: Maybe<Scalars['timestamp']['output']>;
  /** remove */
  lastViewedRecentAt?: Maybe<Scalars['timestamp']['output']>;
  /** remove */
  lastViewedSharedAt?: Maybe<Scalars['timestamp']['output']>;
  /** check if used, potentially remove */
  position?: Maybe<Scalars['Int']['output']>;
  /** [Slack integration] The slack bot needs to know the email of the user in Slack to send them a message */
  slackEmail?: Maybe<Scalars['String']['output']>;
  /** [Slack integration] The Slack bot saves the ID of the user within Slack's database after finding the user via their email, then uses the ID to send messages to this user */
  slackId?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "account_users" */
export type AccountUsersMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** [Replicache] - the background colour for the user's icon when they do not have a profile picture. this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  color?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The email is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  email?: InputMaybe<OrderBy>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The first_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  firstName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  lastName?: InputMaybe<OrderBy>;
  /** remove */
  lastViewedFeedAt?: InputMaybe<OrderBy>;
  /** remove */
  lastViewedRecentAt?: InputMaybe<OrderBy>;
  /** remove */
  lastViewedSharedAt?: InputMaybe<OrderBy>;
  /** check if used, potentially remove */
  position?: InputMaybe<OrderBy>;
  /** [Slack integration] The slack bot needs to know the email of the user in Slack to send them a message */
  slackEmail?: InputMaybe<OrderBy>;
  /** [Slack integration] The Slack bot saves the ID of the user within Slack's database after finding the user via their email, then uses the ID to send messages to this user */
  slackId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type AccountUsersMinFields = {
  __typename?: 'AccountUsersMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** [Replicache] - the background colour for the user's icon when they do not have a profile picture. this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  color?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The email is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  email?: Maybe<Scalars['String']['output']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The first_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  lastName?: Maybe<Scalars['String']['output']>;
  /** remove */
  lastViewedFeedAt?: Maybe<Scalars['timestamp']['output']>;
  /** remove */
  lastViewedRecentAt?: Maybe<Scalars['timestamp']['output']>;
  /** remove */
  lastViewedSharedAt?: Maybe<Scalars['timestamp']['output']>;
  /** check if used, potentially remove */
  position?: Maybe<Scalars['Int']['output']>;
  /** [Slack integration] The slack bot needs to know the email of the user in Slack to send them a message */
  slackEmail?: Maybe<Scalars['String']['output']>;
  /** [Slack integration] The Slack bot saves the ID of the user within Slack's database after finding the user via their email, then uses the ID to send messages to this user */
  slackId?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "account_users" */
export type AccountUsersMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** [Replicache] - the background colour for the user's icon when they do not have a profile picture. this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  color?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The email is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  email?: InputMaybe<OrderBy>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The first_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  firstName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  lastName?: InputMaybe<OrderBy>;
  /** remove */
  lastViewedFeedAt?: InputMaybe<OrderBy>;
  /** remove */
  lastViewedRecentAt?: InputMaybe<OrderBy>;
  /** remove */
  lastViewedSharedAt?: InputMaybe<OrderBy>;
  /** check if used, potentially remove */
  position?: InputMaybe<OrderBy>;
  /** [Slack integration] The slack bot needs to know the email of the user in Slack to send them a message */
  slackEmail?: InputMaybe<OrderBy>;
  /** [Slack integration] The Slack bot saves the ID of the user within Slack's database after finding the user via their email, then uses the ID to send messages to this user */
  slackId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "account_users" */
export type AccountUsersMutationResponse = {
  __typename?: 'AccountUsersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AccountUsers>;
};

/** on_conflict condition type for table "account_users" */
export type AccountUsersOnConflict = {
  constraint: AccountUsersConstraint;
  updateColumns?: Array<AccountUsersUpdateColumn>;
  where?: InputMaybe<AccountUsersBoolExp>;
};

/** Ordering options when selecting data from "account_users". */
export type AccountUsersOrderBy = {
  account?: InputMaybe<AccountsOrderBy>;
  accountId?: InputMaybe<OrderBy>;
  color?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  firstName?: InputMaybe<OrderBy>;
  guest?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isViewOnly?: InputMaybe<OrderBy>;
  kanbanDisplaySettings?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  lastName?: InputMaybe<OrderBy>;
  lastViewedFeedAt?: InputMaybe<OrderBy>;
  lastViewedRecentAt?: InputMaybe<OrderBy>;
  lastViewedSharedAt?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  role?: InputMaybe<OrderBy>;
  showRecent?: InputMaybe<OrderBy>;
  showShared?: InputMaybe<OrderBy>;
  slackEmail?: InputMaybe<OrderBy>;
  slackId?: InputMaybe<OrderBy>;
  swimlaneOpen?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: account_users */
export type AccountUsersPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AccountUsersPrependInput = {
  /** check if used, potentially remove. Was used for  */
  kanbanDisplaySettings?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "account_users" */
export enum AccountUsersSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  Color = 'color',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  Guest = 'guest',
  /** column name */
  Id = 'id',
  /** column name */
  IsViewOnly = 'isViewOnly',
  /** column name */
  KanbanDisplaySettings = 'kanbanDisplaySettings',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LastName = 'lastName',
  /** column name */
  LastViewedFeedAt = 'lastViewedFeedAt',
  /** column name */
  LastViewedRecentAt = 'lastViewedRecentAt',
  /** column name */
  LastViewedSharedAt = 'lastViewedSharedAt',
  /** column name */
  Position = 'position',
  /** column name */
  Role = 'role',
  /** column name */
  ShowRecent = 'showRecent',
  /** column name */
  ShowShared = 'showShared',
  /** column name */
  SlackEmail = 'slackEmail',
  /** column name */
  SlackId = 'slackId',
  /** column name */
  SwimlaneOpen = 'swimlaneOpen',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** select "accountUsersAggregateBoolExpBool_andArgumentsColumns" columns of table "account_users" */
export enum AccountUsersSelectColumnAccountUsersAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  Guest = 'guest',
  /** column name */
  IsViewOnly = 'isViewOnly',
  /** column name */
  ShowRecent = 'showRecent',
  /** column name */
  ShowShared = 'showShared',
  /** column name */
  SwimlaneOpen = 'swimlaneOpen'
}

/** select "accountUsersAggregateBoolExpBool_orArgumentsColumns" columns of table "account_users" */
export enum AccountUsersSelectColumnAccountUsersAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  Guest = 'guest',
  /** column name */
  IsViewOnly = 'isViewOnly',
  /** column name */
  ShowRecent = 'showRecent',
  /** column name */
  ShowShared = 'showShared',
  /** column name */
  SwimlaneOpen = 'swimlaneOpen'
}

/** input type for updating data in table "account_users" */
export type AccountUsersSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [Replicache] - the background colour for the user's icon when they do not have a profile picture. this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  color?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The email is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The first_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** [Permissions] - to revisit naming and use */
  guest?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [Permissions] - to revisit naming and use */
  isViewOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** check if used, potentially remove. Was used for  */
  kanbanDisplaySettings?: InputMaybe<Scalars['jsonb']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  lastViewedFeedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** remove */
  lastViewedRecentAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** remove */
  lastViewedSharedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** check if used, potentially remove */
  position?: InputMaybe<Scalars['Int']['input']>;
  role?: InputMaybe<AccountUserRolesEnum>;
  /** remove */
  showRecent?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove */
  showShared?: InputMaybe<Scalars['Boolean']['input']>;
  /** [Slack integration] The slack bot needs to know the email of the user in Slack to send them a message */
  slackEmail?: InputMaybe<Scalars['String']['input']>;
  /** [Slack integration] The Slack bot saves the ID of the user within Slack's database after finding the user via their email, then uses the ID to send messages to this user */
  slackId?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  swimlaneOpen?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type AccountUsersStddevFields = {
  __typename?: 'AccountUsersStddevFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check if used, potentially remove */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "account_users" */
export type AccountUsersStddevOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check if used, potentially remove */
  position?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type AccountUsersStddevPopFields = {
  __typename?: 'AccountUsersStddevPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check if used, potentially remove */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "account_users" */
export type AccountUsersStddevPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check if used, potentially remove */
  position?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type AccountUsersStddevSampFields = {
  __typename?: 'AccountUsersStddevSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check if used, potentially remove */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "account_users" */
export type AccountUsersStddevSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check if used, potentially remove */
  position?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "account_users" */
export type AccountUsersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AccountUsersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AccountUsersStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [Replicache] - the background colour for the user's icon when they do not have a profile picture. this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  color?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The email is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The first_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** [Permissions] - to revisit naming and use */
  guest?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [Permissions] - to revisit naming and use */
  isViewOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** check if used, potentially remove. Was used for  */
  kanbanDisplaySettings?: InputMaybe<Scalars['jsonb']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** [Replicache] - this field is somewhat misleading and is only added to account_users to support replicache. The last_name is really owned by the users table. However, replicache requires that all data loaded belongs to an single account. We do not send users data, which is shared between multiple accounts, to each account. Therefore, this field is duplicated from the users table to here to allow the replicache to pull this data in. If replicache is removed, this field can be removed. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  lastViewedFeedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** remove */
  lastViewedRecentAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** remove */
  lastViewedSharedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** check if used, potentially remove */
  position?: InputMaybe<Scalars['Int']['input']>;
  role?: InputMaybe<AccountUserRolesEnum>;
  /** remove */
  showRecent?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove */
  showShared?: InputMaybe<Scalars['Boolean']['input']>;
  /** [Slack integration] The slack bot needs to know the email of the user in Slack to send them a message */
  slackEmail?: InputMaybe<Scalars['String']['input']>;
  /** [Slack integration] The Slack bot saves the ID of the user within Slack's database after finding the user via their email, then uses the ID to send messages to this user */
  slackId?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  swimlaneOpen?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type AccountUsersSumFields = {
  __typename?: 'AccountUsersSumFields';
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** check if used, potentially remove */
  position?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "account_users" */
export type AccountUsersSumOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check if used, potentially remove */
  position?: InputMaybe<OrderBy>;
};

/** update columns of table "account_users" */
export enum AccountUsersUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  Color = 'color',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  Guest = 'guest',
  /** column name */
  Id = 'id',
  /** column name */
  IsViewOnly = 'isViewOnly',
  /** column name */
  KanbanDisplaySettings = 'kanbanDisplaySettings',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LastName = 'lastName',
  /** column name */
  LastViewedFeedAt = 'lastViewedFeedAt',
  /** column name */
  LastViewedRecentAt = 'lastViewedRecentAt',
  /** column name */
  LastViewedSharedAt = 'lastViewedSharedAt',
  /** column name */
  Position = 'position',
  /** column name */
  Role = 'role',
  /** column name */
  ShowRecent = 'showRecent',
  /** column name */
  ShowShared = 'showShared',
  /** column name */
  SlackEmail = 'slackEmail',
  /** column name */
  SlackId = 'slackId',
  /** column name */
  SwimlaneOpen = 'swimlaneOpen',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type AccountUsersUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<AccountUsersAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<AccountUsersDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<AccountUsersDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<AccountUsersDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AccountUsersIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<AccountUsersPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AccountUsersSetInput>;
  /** filter the rows which have to be updated */
  where: AccountUsersBoolExp;
};

/** aggregate varPop on columns */
export type AccountUsersVarPopFields = {
  __typename?: 'AccountUsersVarPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check if used, potentially remove */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "account_users" */
export type AccountUsersVarPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check if used, potentially remove */
  position?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type AccountUsersVarSampFields = {
  __typename?: 'AccountUsersVarSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check if used, potentially remove */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "account_users" */
export type AccountUsersVarSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check if used, potentially remove */
  position?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type AccountUsersVarianceFields = {
  __typename?: 'AccountUsersVarianceFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check if used, potentially remove */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "account_users" */
export type AccountUsersVarianceOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check if used, potentially remove */
  position?: InputMaybe<OrderBy>;
};

/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type Accounts = {
  __typename?: 'Accounts';
  /** An array relationship */
  accountInvoices: Array<AccountInvoices>;
  /** An aggregate relationship */
  accountInvoicesAggregate: AccountInvoicesAggregate;
  /** An array relationship */
  accountUsers: Array<AccountUsers>;
  /** An aggregate relationship */
  accountUsersAggregate: AccountUsersAggregate;
  /** [Airtable integration] - remove */
  airtableId?: Maybe<Scalars['String']['output']>;
  /** Record ID of a corresponding company in Attio */
  attioCompanyRecordId?: Maybe<Scalars['String']['output']>;
  /** [AI checks] - defines if AI checks automatically run for the account */
  automaticallyRunAiChecks: Scalars['Boolean']['output'];
  /** Billing address line 1 */
  billingAddress1?: Maybe<Scalars['String']['output']>;
  /** Billing address line 2 */
  billingAddress2?: Maybe<Scalars['String']['output']>;
  /** Billing city */
  billingCity?: Maybe<Scalars['String']['output']>;
  /** Billing country */
  billingCountry?: Maybe<Scalars['String']['output']>;
  /** Billing email */
  billingEmail?: Maybe<Scalars['String']['output']>;
  /** Billing name */
  billingName?: Maybe<Scalars['String']['output']>;
  /** Billing postal code */
  billingPostalCode?: Maybe<Scalars['String']['output']>;
  /** Billing state */
  billingState?: Maybe<Scalars['String']['output']>;
  /** Billing VAT ID */
  billingVatId?: Maybe<Scalars['String']['output']>;
  /** [branding] - remove */
  brandingFont?: Maybe<Scalars['String']['output']>;
  /** [branding] - remove */
  brandingMainBgColor?: Maybe<Scalars['String']['output']>;
  /** [branding] - remove */
  brandingSidebarBgColor?: Maybe<Scalars['String']['output']>;
  /** [branding] - remove */
  brandingSidebarTextColor?: Maybe<Scalars['String']['output']>;
  cancelledAt?: Maybe<Scalars['date']['output']>;
  createdAt: Scalars['timestamp']['output'];
  /** Credit balance towards next bill */
  creditBalance: Scalars['numeric']['output'];
  /** [analytics] Needs consolidation with is_demo. If this account is a demo account we can remove it from analytics */
  demo: Scalars['Boolean']['output'];
  /** An array relationship */
  documents: Array<Documents>;
  /** An aggregate relationship */
  documentsAggregate: DocumentsAggregate;
  /** [clients] - remove */
  hasClients: Scalars['Boolean']['output'];
  id: Scalars['uuid']['output'];
  /** [invite to team] - used to identify the team in links that invite people to join the team */
  inviteToken: Scalars['uuid']['output'];
  /** [analytics] Needs consolidation with is_demo. */
  isDemo: Scalars['Boolean']['output'];
  /** [storage] - remove */
  isStorageEnabled: Scalars['Boolean']['output'];
  /** [timeline] - remove */
  isTimelineEnabled: Scalars['Boolean']['output'];
  /** check if used, potentially remove. Was used for global default kanban display settings */
  kanbanDisplaySettings?: Maybe<Scalars['jsonb']['output']>;
  /** An array relationship */
  labels: Array<Labels>;
  /** An aggregate relationship */
  labelsAggregate: LabelsAggregate;
  /** An array relationship */
  lanes: Array<Lanes>;
  /** An aggregate relationship */
  lanesAggregate: LanesAggregate;
  /** Feature flag for livesites screenshots. We cannot use PostHog because it works on the user level, whereas we need account level. So that clients of customers could use screenshots too */
  livesitesScreenshotsEnabled: Scalars['Boolean']['output'];
  /** Contains a 1 or 2 word value for the marketing source */
  marketingSource?: Maybe<Scalars['String']['output']>;
  /** name of the workspace */
  name: Scalars['String']['output'];
  /** An array relationship */
  notifications: Array<Notifications>;
  /** An aggregate relationship */
  notificationsAggregate: NotificationsAggregate;
  /** Fix or remove. Users were previously, at one point, offered browser-based notifications. This is not related to electron. This broke and nobody has fixed it. */
  offerDesktopNotifications: Scalars['Boolean']['output'];
  /** [permissions] To revisit. The user who is the owner. At time of writing 23/11/24 the only perk is the ability to delete the account. Users would like to assign multiple, so this permission level should be moved to account_user. */
  ownerId: Scalars['uuid']['output'];
  /** An object relationship */
  ownerUser: Users;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing activity and can log if an error has occured (e.g. invalid upload). */
  photoProcessingError?: Maybe<Scalars['String']['output']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus: Scalars['Int']['output'];
  /** An array relationship */
  projectUsers: Array<ProjectUsers>;
  /** An aggregate relationship */
  projectUsersAggregate: ProjectUsersAggregate;
  /** An array relationship */
  projects: Array<Projects>;
  /** An aggregate relationship */
  projectsAggregate: ProjectsAggregate;
  /** An object relationship */
  referredByAccount?: Maybe<Accounts>;
  /** ID of the account who referred the current account */
  referredByAccountId?: Maybe<Scalars['uuid']['output']>;
  /** Stripe subscription ID for the per seat subscription */
  seatStripeSubscriptionId?: Maybe<Scalars['String']['output']>;
  /** [Slack integration] - used to connect to Slack */
  slackAccessToken?: Maybe<Scalars['String']['output']>;
  /** [Slack integration] - used to connect to Slack */
  slackIdentifier?: Maybe<Scalars['String']['output']>;
  /** [Slack integration] - the name of the Slack Workspace that the account is connected to */
  slackTeamName?: Maybe<Scalars['String']['output']>;
  /** Stripe subscription ID for the storage subscription */
  storageStripeSubscriptionId?: Maybe<Scalars['String']['output']>;
  /**
   * Each subscription in Stripe has subscription items. We store the ID of the item,
   * because we need to know it to update the usage and it saves us from having to call
   * Stripe to get the item ID.
   *
   */
  storageStripeSubscriptionItemId?: Maybe<Scalars['String']['output']>;
  /** [payments] ID of user in Stripe, so that they can be charged */
  stripeId?: Maybe<Scalars['String']['output']>;
  subscribedAt?: Maybe<Scalars['date']['output']>;
  subscriptionStatus: SubscriptionStatusesEnum;
  subscriptionType?: Maybe<SubscriptionTypesEnum>;
  /** [timeline] - remove */
  timelineEnableRowNames: Scalars['Boolean']['output'];
  trialEndsAt?: Maybe<Scalars['timestamp']['output']>;
  updatedAt: Scalars['timestamp']['output'];
  /** URL pointing to the full resolution workspace icon */
  workspaceIconUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the workspace icon URL expires */
  workspaceIconUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsAccountInvoicesArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoicesOrderBy>>;
  where?: InputMaybe<AccountInvoicesBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsAccountInvoicesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoicesOrderBy>>;
  where?: InputMaybe<AccountInvoicesBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsAccountUsersArgs = {
  distinctOn?: InputMaybe<Array<AccountUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountUsersOrderBy>>;
  where?: InputMaybe<AccountUsersBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsAccountUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountUsersOrderBy>>;
  where?: InputMaybe<AccountUsersBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsDocumentsArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsDocumentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsKanbanDisplaySettingsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsLabelsArgs = {
  distinctOn?: InputMaybe<Array<LabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LabelsOrderBy>>;
  where?: InputMaybe<LabelsBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsLabelsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LabelsOrderBy>>;
  where?: InputMaybe<LabelsBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsLanesArgs = {
  distinctOn?: InputMaybe<Array<LanesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LanesOrderBy>>;
  where?: InputMaybe<LanesBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsLanesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LanesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LanesOrderBy>>;
  where?: InputMaybe<LanesBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsNotificationsArgs = {
  distinctOn?: InputMaybe<Array<NotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
  where?: InputMaybe<NotificationsBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsNotificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<NotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
  where?: InputMaybe<NotificationsBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsProjectUsersArgs = {
  distinctOn?: InputMaybe<Array<ProjectUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
  where?: InputMaybe<ProjectUsersBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsProjectUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<ProjectUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
  where?: InputMaybe<ProjectUsersBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsProjectsArgs = {
  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  where?: InputMaybe<ProjectsBoolExp>;
};


/** An account is a workspace. Usually one organisation will have one account. However due to our current opinionated constraint that accounts have a global set of lanes (Kanban stages) - therefore some companies have worked around this by creating two accounts. Accounts are generally "self-contained" and contain all data relating to that organisation - the only exception to this is users who can be across accounts (as defined by their account_user join table entry), similarly to a user in multiple Slack workspaces. In replicache, every piece of data must belong to an account - this might be a sensible constraint to retain if replicache is removed for security reasons and to prevent orphan data. */
export type AccountsProjectsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  where?: InputMaybe<ProjectsBoolExp>;
};

/** aggregated selection of "accounts" */
export type AccountsAggregate = {
  __typename?: 'AccountsAggregate';
  aggregate?: Maybe<AccountsAggregateFields>;
  nodes: Array<Accounts>;
};

export type AccountsAggregateBoolExp = {
  bool_and?: InputMaybe<AccountsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<AccountsAggregateBoolExpBool_Or>;
  count?: InputMaybe<AccountsAggregateBoolExpCount>;
};

/** aggregate fields of "accounts" */
export type AccountsAggregateFields = {
  __typename?: 'AccountsAggregateFields';
  avg?: Maybe<AccountsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<AccountsMaxFields>;
  min?: Maybe<AccountsMinFields>;
  stddev?: Maybe<AccountsStddevFields>;
  stddevPop?: Maybe<AccountsStddevPopFields>;
  stddevSamp?: Maybe<AccountsStddevSampFields>;
  sum?: Maybe<AccountsSumFields>;
  varPop?: Maybe<AccountsVarPopFields>;
  varSamp?: Maybe<AccountsVarSampFields>;
  variance?: Maybe<AccountsVarianceFields>;
};


/** aggregate fields of "accounts" */
export type AccountsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AccountsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "accounts" */
export type AccountsAggregateOrderBy = {
  avg?: InputMaybe<AccountsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<AccountsMaxOrderBy>;
  min?: InputMaybe<AccountsMinOrderBy>;
  stddev?: InputMaybe<AccountsStddevOrderBy>;
  stddevPop?: InputMaybe<AccountsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<AccountsStddevSampOrderBy>;
  sum?: InputMaybe<AccountsSumOrderBy>;
  varPop?: InputMaybe<AccountsVarPopOrderBy>;
  varSamp?: InputMaybe<AccountsVarSampOrderBy>;
  variance?: InputMaybe<AccountsVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AccountsAppendInput = {
  /** check if used, potentially remove. Was used for global default kanban display settings */
  kanbanDisplaySettings?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "accounts" */
export type AccountsArrRelInsertInput = {
  data: Array<AccountsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<AccountsOnConflict>;
};

/** aggregate avg on columns */
export type AccountsAvgFields = {
  __typename?: 'AccountsAvgFields';
  /** Credit balance towards next bill */
  creditBalance?: Maybe<Scalars['Float']['output']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "accounts" */
export type AccountsAvgOrderBy = {
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<OrderBy>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "accounts". All fields are combined with a logical 'AND'. */
export type AccountsBoolExp = {
  _and?: InputMaybe<Array<AccountsBoolExp>>;
  _not?: InputMaybe<AccountsBoolExp>;
  _or?: InputMaybe<Array<AccountsBoolExp>>;
  accountInvoices?: InputMaybe<AccountInvoicesBoolExp>;
  accountInvoicesAggregate?: InputMaybe<AccountInvoicesAggregateBoolExp>;
  accountUsers?: InputMaybe<AccountUsersBoolExp>;
  accountUsersAggregate?: InputMaybe<AccountUsersAggregateBoolExp>;
  airtableId?: InputMaybe<StringComparisonExp>;
  attioCompanyRecordId?: InputMaybe<StringComparisonExp>;
  automaticallyRunAiChecks?: InputMaybe<BooleanComparisonExp>;
  billingAddress1?: InputMaybe<StringComparisonExp>;
  billingAddress2?: InputMaybe<StringComparisonExp>;
  billingCity?: InputMaybe<StringComparisonExp>;
  billingCountry?: InputMaybe<StringComparisonExp>;
  billingEmail?: InputMaybe<StringComparisonExp>;
  billingName?: InputMaybe<StringComparisonExp>;
  billingPostalCode?: InputMaybe<StringComparisonExp>;
  billingState?: InputMaybe<StringComparisonExp>;
  billingVatId?: InputMaybe<StringComparisonExp>;
  brandingFont?: InputMaybe<StringComparisonExp>;
  brandingMainBgColor?: InputMaybe<StringComparisonExp>;
  brandingSidebarBgColor?: InputMaybe<StringComparisonExp>;
  brandingSidebarTextColor?: InputMaybe<StringComparisonExp>;
  cancelledAt?: InputMaybe<DateComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  creditBalance?: InputMaybe<NumericComparisonExp>;
  demo?: InputMaybe<BooleanComparisonExp>;
  documents?: InputMaybe<DocumentsBoolExp>;
  documentsAggregate?: InputMaybe<DocumentsAggregateBoolExp>;
  hasClients?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  inviteToken?: InputMaybe<UuidComparisonExp>;
  isDemo?: InputMaybe<BooleanComparisonExp>;
  isStorageEnabled?: InputMaybe<BooleanComparisonExp>;
  isTimelineEnabled?: InputMaybe<BooleanComparisonExp>;
  kanbanDisplaySettings?: InputMaybe<JsonbComparisonExp>;
  labels?: InputMaybe<LabelsBoolExp>;
  labelsAggregate?: InputMaybe<LabelsAggregateBoolExp>;
  lanes?: InputMaybe<LanesBoolExp>;
  lanesAggregate?: InputMaybe<LanesAggregateBoolExp>;
  livesitesScreenshotsEnabled?: InputMaybe<BooleanComparisonExp>;
  marketingSource?: InputMaybe<StringComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  notifications?: InputMaybe<NotificationsBoolExp>;
  notificationsAggregate?: InputMaybe<NotificationsAggregateBoolExp>;
  offerDesktopNotifications?: InputMaybe<BooleanComparisonExp>;
  ownerId?: InputMaybe<UuidComparisonExp>;
  ownerUser?: InputMaybe<UsersBoolExp>;
  photoProcessingError?: InputMaybe<StringComparisonExp>;
  photoProcessingStatus?: InputMaybe<IntComparisonExp>;
  projectUsers?: InputMaybe<ProjectUsersBoolExp>;
  projectUsersAggregate?: InputMaybe<ProjectUsersAggregateBoolExp>;
  projects?: InputMaybe<ProjectsBoolExp>;
  projectsAggregate?: InputMaybe<ProjectsAggregateBoolExp>;
  referredByAccount?: InputMaybe<AccountsBoolExp>;
  referredByAccountId?: InputMaybe<UuidComparisonExp>;
  seatStripeSubscriptionId?: InputMaybe<StringComparisonExp>;
  slackAccessToken?: InputMaybe<StringComparisonExp>;
  slackIdentifier?: InputMaybe<StringComparisonExp>;
  slackTeamName?: InputMaybe<StringComparisonExp>;
  storageStripeSubscriptionId?: InputMaybe<StringComparisonExp>;
  storageStripeSubscriptionItemId?: InputMaybe<StringComparisonExp>;
  stripeId?: InputMaybe<StringComparisonExp>;
  subscribedAt?: InputMaybe<DateComparisonExp>;
  subscriptionStatus?: InputMaybe<SubscriptionStatusesEnumComparisonExp>;
  subscriptionType?: InputMaybe<SubscriptionTypesEnumComparisonExp>;
  timelineEnableRowNames?: InputMaybe<BooleanComparisonExp>;
  trialEndsAt?: InputMaybe<TimestampComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  workspaceIconUrl?: InputMaybe<StringComparisonExp>;
  workspaceIconUrlExpiresAt?: InputMaybe<TimestampComparisonExp>;
};

/** unique or primary key constraints on table "accounts" */
export enum AccountsConstraint {
  /** unique or primary key constraint on columns "id" */
  AccountsPkey = 'accounts_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AccountsDeleteAtPathInput = {
  /** check if used, potentially remove. Was used for global default kanban display settings */
  kanbanDisplaySettings?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AccountsDeleteElemInput = {
  /** check if used, potentially remove. Was used for global default kanban display settings */
  kanbanDisplaySettings?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AccountsDeleteKeyInput = {
  /** check if used, potentially remove. Was used for global default kanban display settings */
  kanbanDisplaySettings?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "accounts" */
export type AccountsIncInput = {
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<Scalars['numeric']['input']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "accounts" */
export type AccountsInsertInput = {
  accountInvoices?: InputMaybe<AccountInvoicesArrRelInsertInput>;
  accountUsers?: InputMaybe<AccountUsersArrRelInsertInput>;
  /** [Airtable integration] - remove */
  airtableId?: InputMaybe<Scalars['String']['input']>;
  /** Record ID of a corresponding company in Attio */
  attioCompanyRecordId?: InputMaybe<Scalars['String']['input']>;
  /** [AI checks] - defines if AI checks automatically run for the account */
  automaticallyRunAiChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Billing address line 1 */
  billingAddress1?: InputMaybe<Scalars['String']['input']>;
  /** Billing address line 2 */
  billingAddress2?: InputMaybe<Scalars['String']['input']>;
  /** Billing city */
  billingCity?: InputMaybe<Scalars['String']['input']>;
  /** Billing country */
  billingCountry?: InputMaybe<Scalars['String']['input']>;
  /** Billing email */
  billingEmail?: InputMaybe<Scalars['String']['input']>;
  /** Billing name */
  billingName?: InputMaybe<Scalars['String']['input']>;
  /** Billing postal code */
  billingPostalCode?: InputMaybe<Scalars['String']['input']>;
  /** Billing state */
  billingState?: InputMaybe<Scalars['String']['input']>;
  /** Billing VAT ID */
  billingVatId?: InputMaybe<Scalars['String']['input']>;
  /** [branding] - remove */
  brandingFont?: InputMaybe<Scalars['String']['input']>;
  /** [branding] - remove */
  brandingMainBgColor?: InputMaybe<Scalars['String']['input']>;
  /** [branding] - remove */
  brandingSidebarBgColor?: InputMaybe<Scalars['String']['input']>;
  /** [branding] - remove */
  brandingSidebarTextColor?: InputMaybe<Scalars['String']['input']>;
  cancelledAt?: InputMaybe<Scalars['date']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<Scalars['numeric']['input']>;
  /** [analytics] Needs consolidation with is_demo. If this account is a demo account we can remove it from analytics */
  demo?: InputMaybe<Scalars['Boolean']['input']>;
  documents?: InputMaybe<DocumentsArrRelInsertInput>;
  /** [clients] - remove */
  hasClients?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [invite to team] - used to identify the team in links that invite people to join the team */
  inviteToken?: InputMaybe<Scalars['uuid']['input']>;
  /** [analytics] Needs consolidation with is_demo. */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  /** [storage] - remove */
  isStorageEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** [timeline] - remove */
  isTimelineEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** check if used, potentially remove. Was used for global default kanban display settings */
  kanbanDisplaySettings?: InputMaybe<Scalars['jsonb']['input']>;
  labels?: InputMaybe<LabelsArrRelInsertInput>;
  lanes?: InputMaybe<LanesArrRelInsertInput>;
  /** Feature flag for livesites screenshots. We cannot use PostHog because it works on the user level, whereas we need account level. So that clients of customers could use screenshots too */
  livesitesScreenshotsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Contains a 1 or 2 word value for the marketing source */
  marketingSource?: InputMaybe<Scalars['String']['input']>;
  /** name of the workspace */
  name?: InputMaybe<Scalars['String']['input']>;
  notifications?: InputMaybe<NotificationsArrRelInsertInput>;
  /** Fix or remove. Users were previously, at one point, offered browser-based notifications. This is not related to electron. This broke and nobody has fixed it. */
  offerDesktopNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  /** [permissions] To revisit. The user who is the owner. At time of writing 23/11/24 the only perk is the ability to delete the account. Users would like to assign multiple, so this permission level should be moved to account_user. */
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  ownerUser?: InputMaybe<UsersObjRelInsertInput>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing activity and can log if an error has occured (e.g. invalid upload). */
  photoProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  projectUsers?: InputMaybe<ProjectUsersArrRelInsertInput>;
  projects?: InputMaybe<ProjectsArrRelInsertInput>;
  referredByAccount?: InputMaybe<AccountsObjRelInsertInput>;
  /** ID of the account who referred the current account */
  referredByAccountId?: InputMaybe<Scalars['uuid']['input']>;
  /** Stripe subscription ID for the per seat subscription */
  seatStripeSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  /** [Slack integration] - used to connect to Slack */
  slackAccessToken?: InputMaybe<Scalars['String']['input']>;
  /** [Slack integration] - used to connect to Slack */
  slackIdentifier?: InputMaybe<Scalars['String']['input']>;
  /** [Slack integration] - the name of the Slack Workspace that the account is connected to */
  slackTeamName?: InputMaybe<Scalars['String']['input']>;
  /** Stripe subscription ID for the storage subscription */
  storageStripeSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Each subscription in Stripe has subscription items. We store the ID of the item,
   * because we need to know it to update the usage and it saves us from having to call
   * Stripe to get the item ID.
   *
   */
  storageStripeSubscriptionItemId?: InputMaybe<Scalars['String']['input']>;
  /** [payments] ID of user in Stripe, so that they can be charged */
  stripeId?: InputMaybe<Scalars['String']['input']>;
  subscribedAt?: InputMaybe<Scalars['date']['input']>;
  subscriptionStatus?: InputMaybe<SubscriptionStatusesEnum>;
  subscriptionType?: InputMaybe<SubscriptionTypesEnum>;
  /** [timeline] - remove */
  timelineEnableRowNames?: InputMaybe<Scalars['Boolean']['input']>;
  trialEndsAt?: InputMaybe<Scalars['timestamp']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** URL pointing to the full resolution workspace icon */
  workspaceIconUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the workspace icon URL expires */
  workspaceIconUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate max on columns */
export type AccountsMaxFields = {
  __typename?: 'AccountsMaxFields';
  /** [Airtable integration] - remove */
  airtableId?: Maybe<Scalars['String']['output']>;
  /** Record ID of a corresponding company in Attio */
  attioCompanyRecordId?: Maybe<Scalars['String']['output']>;
  /** Billing address line 1 */
  billingAddress1?: Maybe<Scalars['String']['output']>;
  /** Billing address line 2 */
  billingAddress2?: Maybe<Scalars['String']['output']>;
  /** Billing city */
  billingCity?: Maybe<Scalars['String']['output']>;
  /** Billing country */
  billingCountry?: Maybe<Scalars['String']['output']>;
  /** Billing email */
  billingEmail?: Maybe<Scalars['String']['output']>;
  /** Billing name */
  billingName?: Maybe<Scalars['String']['output']>;
  /** Billing postal code */
  billingPostalCode?: Maybe<Scalars['String']['output']>;
  /** Billing state */
  billingState?: Maybe<Scalars['String']['output']>;
  /** Billing VAT ID */
  billingVatId?: Maybe<Scalars['String']['output']>;
  /** [branding] - remove */
  brandingFont?: Maybe<Scalars['String']['output']>;
  /** [branding] - remove */
  brandingMainBgColor?: Maybe<Scalars['String']['output']>;
  /** [branding] - remove */
  brandingSidebarBgColor?: Maybe<Scalars['String']['output']>;
  /** [branding] - remove */
  brandingSidebarTextColor?: Maybe<Scalars['String']['output']>;
  cancelledAt?: Maybe<Scalars['date']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** Credit balance towards next bill */
  creditBalance?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** [invite to team] - used to identify the team in links that invite people to join the team */
  inviteToken?: Maybe<Scalars['uuid']['output']>;
  /** Contains a 1 or 2 word value for the marketing source */
  marketingSource?: Maybe<Scalars['String']['output']>;
  /** name of the workspace */
  name?: Maybe<Scalars['String']['output']>;
  /** [permissions] To revisit. The user who is the owner. At time of writing 23/11/24 the only perk is the ability to delete the account. Users would like to assign multiple, so this permission level should be moved to account_user. */
  ownerId?: Maybe<Scalars['uuid']['output']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing activity and can log if an error has occured (e.g. invalid upload). */
  photoProcessingError?: Maybe<Scalars['String']['output']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** ID of the account who referred the current account */
  referredByAccountId?: Maybe<Scalars['uuid']['output']>;
  /** Stripe subscription ID for the per seat subscription */
  seatStripeSubscriptionId?: Maybe<Scalars['String']['output']>;
  /** [Slack integration] - used to connect to Slack */
  slackAccessToken?: Maybe<Scalars['String']['output']>;
  /** [Slack integration] - used to connect to Slack */
  slackIdentifier?: Maybe<Scalars['String']['output']>;
  /** [Slack integration] - the name of the Slack Workspace that the account is connected to */
  slackTeamName?: Maybe<Scalars['String']['output']>;
  /** Stripe subscription ID for the storage subscription */
  storageStripeSubscriptionId?: Maybe<Scalars['String']['output']>;
  /**
   * Each subscription in Stripe has subscription items. We store the ID of the item,
   * because we need to know it to update the usage and it saves us from having to call
   * Stripe to get the item ID.
   *
   */
  storageStripeSubscriptionItemId?: Maybe<Scalars['String']['output']>;
  /** [payments] ID of user in Stripe, so that they can be charged */
  stripeId?: Maybe<Scalars['String']['output']>;
  subscribedAt?: Maybe<Scalars['date']['output']>;
  trialEndsAt?: Maybe<Scalars['timestamp']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** URL pointing to the full resolution workspace icon */
  workspaceIconUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the workspace icon URL expires */
  workspaceIconUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by max() on columns of table "accounts" */
export type AccountsMaxOrderBy = {
  /** [Airtable integration] - remove */
  airtableId?: InputMaybe<OrderBy>;
  /** Record ID of a corresponding company in Attio */
  attioCompanyRecordId?: InputMaybe<OrderBy>;
  /** Billing address line 1 */
  billingAddress1?: InputMaybe<OrderBy>;
  /** Billing address line 2 */
  billingAddress2?: InputMaybe<OrderBy>;
  /** Billing city */
  billingCity?: InputMaybe<OrderBy>;
  /** Billing country */
  billingCountry?: InputMaybe<OrderBy>;
  /** Billing email */
  billingEmail?: InputMaybe<OrderBy>;
  /** Billing name */
  billingName?: InputMaybe<OrderBy>;
  /** Billing postal code */
  billingPostalCode?: InputMaybe<OrderBy>;
  /** Billing state */
  billingState?: InputMaybe<OrderBy>;
  /** Billing VAT ID */
  billingVatId?: InputMaybe<OrderBy>;
  /** [branding] - remove */
  brandingFont?: InputMaybe<OrderBy>;
  /** [branding] - remove */
  brandingMainBgColor?: InputMaybe<OrderBy>;
  /** [branding] - remove */
  brandingSidebarBgColor?: InputMaybe<OrderBy>;
  /** [branding] - remove */
  brandingSidebarTextColor?: InputMaybe<OrderBy>;
  cancelledAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** [invite to team] - used to identify the team in links that invite people to join the team */
  inviteToken?: InputMaybe<OrderBy>;
  /** Contains a 1 or 2 word value for the marketing source */
  marketingSource?: InputMaybe<OrderBy>;
  /** name of the workspace */
  name?: InputMaybe<OrderBy>;
  /** [permissions] To revisit. The user who is the owner. At time of writing 23/11/24 the only perk is the ability to delete the account. Users would like to assign multiple, so this permission level should be moved to account_user. */
  ownerId?: InputMaybe<OrderBy>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing activity and can log if an error has occured (e.g. invalid upload). */
  photoProcessingError?: InputMaybe<OrderBy>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<OrderBy>;
  /** ID of the account who referred the current account */
  referredByAccountId?: InputMaybe<OrderBy>;
  /** Stripe subscription ID for the per seat subscription */
  seatStripeSubscriptionId?: InputMaybe<OrderBy>;
  /** [Slack integration] - used to connect to Slack */
  slackAccessToken?: InputMaybe<OrderBy>;
  /** [Slack integration] - used to connect to Slack */
  slackIdentifier?: InputMaybe<OrderBy>;
  /** [Slack integration] - the name of the Slack Workspace that the account is connected to */
  slackTeamName?: InputMaybe<OrderBy>;
  /** Stripe subscription ID for the storage subscription */
  storageStripeSubscriptionId?: InputMaybe<OrderBy>;
  /**
   * Each subscription in Stripe has subscription items. We store the ID of the item,
   * because we need to know it to update the usage and it saves us from having to call
   * Stripe to get the item ID.
   *
   */
  storageStripeSubscriptionItemId?: InputMaybe<OrderBy>;
  /** [payments] ID of user in Stripe, so that they can be charged */
  stripeId?: InputMaybe<OrderBy>;
  subscribedAt?: InputMaybe<OrderBy>;
  trialEndsAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** URL pointing to the full resolution workspace icon */
  workspaceIconUrl?: InputMaybe<OrderBy>;
  /** Timestamp when the workspace icon URL expires */
  workspaceIconUrlExpiresAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type AccountsMinFields = {
  __typename?: 'AccountsMinFields';
  /** [Airtable integration] - remove */
  airtableId?: Maybe<Scalars['String']['output']>;
  /** Record ID of a corresponding company in Attio */
  attioCompanyRecordId?: Maybe<Scalars['String']['output']>;
  /** Billing address line 1 */
  billingAddress1?: Maybe<Scalars['String']['output']>;
  /** Billing address line 2 */
  billingAddress2?: Maybe<Scalars['String']['output']>;
  /** Billing city */
  billingCity?: Maybe<Scalars['String']['output']>;
  /** Billing country */
  billingCountry?: Maybe<Scalars['String']['output']>;
  /** Billing email */
  billingEmail?: Maybe<Scalars['String']['output']>;
  /** Billing name */
  billingName?: Maybe<Scalars['String']['output']>;
  /** Billing postal code */
  billingPostalCode?: Maybe<Scalars['String']['output']>;
  /** Billing state */
  billingState?: Maybe<Scalars['String']['output']>;
  /** Billing VAT ID */
  billingVatId?: Maybe<Scalars['String']['output']>;
  /** [branding] - remove */
  brandingFont?: Maybe<Scalars['String']['output']>;
  /** [branding] - remove */
  brandingMainBgColor?: Maybe<Scalars['String']['output']>;
  /** [branding] - remove */
  brandingSidebarBgColor?: Maybe<Scalars['String']['output']>;
  /** [branding] - remove */
  brandingSidebarTextColor?: Maybe<Scalars['String']['output']>;
  cancelledAt?: Maybe<Scalars['date']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** Credit balance towards next bill */
  creditBalance?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** [invite to team] - used to identify the team in links that invite people to join the team */
  inviteToken?: Maybe<Scalars['uuid']['output']>;
  /** Contains a 1 or 2 word value for the marketing source */
  marketingSource?: Maybe<Scalars['String']['output']>;
  /** name of the workspace */
  name?: Maybe<Scalars['String']['output']>;
  /** [permissions] To revisit. The user who is the owner. At time of writing 23/11/24 the only perk is the ability to delete the account. Users would like to assign multiple, so this permission level should be moved to account_user. */
  ownerId?: Maybe<Scalars['uuid']['output']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing activity and can log if an error has occured (e.g. invalid upload). */
  photoProcessingError?: Maybe<Scalars['String']['output']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** ID of the account who referred the current account */
  referredByAccountId?: Maybe<Scalars['uuid']['output']>;
  /** Stripe subscription ID for the per seat subscription */
  seatStripeSubscriptionId?: Maybe<Scalars['String']['output']>;
  /** [Slack integration] - used to connect to Slack */
  slackAccessToken?: Maybe<Scalars['String']['output']>;
  /** [Slack integration] - used to connect to Slack */
  slackIdentifier?: Maybe<Scalars['String']['output']>;
  /** [Slack integration] - the name of the Slack Workspace that the account is connected to */
  slackTeamName?: Maybe<Scalars['String']['output']>;
  /** Stripe subscription ID for the storage subscription */
  storageStripeSubscriptionId?: Maybe<Scalars['String']['output']>;
  /**
   * Each subscription in Stripe has subscription items. We store the ID of the item,
   * because we need to know it to update the usage and it saves us from having to call
   * Stripe to get the item ID.
   *
   */
  storageStripeSubscriptionItemId?: Maybe<Scalars['String']['output']>;
  /** [payments] ID of user in Stripe, so that they can be charged */
  stripeId?: Maybe<Scalars['String']['output']>;
  subscribedAt?: Maybe<Scalars['date']['output']>;
  trialEndsAt?: Maybe<Scalars['timestamp']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** URL pointing to the full resolution workspace icon */
  workspaceIconUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the workspace icon URL expires */
  workspaceIconUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by min() on columns of table "accounts" */
export type AccountsMinOrderBy = {
  /** [Airtable integration] - remove */
  airtableId?: InputMaybe<OrderBy>;
  /** Record ID of a corresponding company in Attio */
  attioCompanyRecordId?: InputMaybe<OrderBy>;
  /** Billing address line 1 */
  billingAddress1?: InputMaybe<OrderBy>;
  /** Billing address line 2 */
  billingAddress2?: InputMaybe<OrderBy>;
  /** Billing city */
  billingCity?: InputMaybe<OrderBy>;
  /** Billing country */
  billingCountry?: InputMaybe<OrderBy>;
  /** Billing email */
  billingEmail?: InputMaybe<OrderBy>;
  /** Billing name */
  billingName?: InputMaybe<OrderBy>;
  /** Billing postal code */
  billingPostalCode?: InputMaybe<OrderBy>;
  /** Billing state */
  billingState?: InputMaybe<OrderBy>;
  /** Billing VAT ID */
  billingVatId?: InputMaybe<OrderBy>;
  /** [branding] - remove */
  brandingFont?: InputMaybe<OrderBy>;
  /** [branding] - remove */
  brandingMainBgColor?: InputMaybe<OrderBy>;
  /** [branding] - remove */
  brandingSidebarBgColor?: InputMaybe<OrderBy>;
  /** [branding] - remove */
  brandingSidebarTextColor?: InputMaybe<OrderBy>;
  cancelledAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** [invite to team] - used to identify the team in links that invite people to join the team */
  inviteToken?: InputMaybe<OrderBy>;
  /** Contains a 1 or 2 word value for the marketing source */
  marketingSource?: InputMaybe<OrderBy>;
  /** name of the workspace */
  name?: InputMaybe<OrderBy>;
  /** [permissions] To revisit. The user who is the owner. At time of writing 23/11/24 the only perk is the ability to delete the account. Users would like to assign multiple, so this permission level should be moved to account_user. */
  ownerId?: InputMaybe<OrderBy>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing activity and can log if an error has occured (e.g. invalid upload). */
  photoProcessingError?: InputMaybe<OrderBy>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<OrderBy>;
  /** ID of the account who referred the current account */
  referredByAccountId?: InputMaybe<OrderBy>;
  /** Stripe subscription ID for the per seat subscription */
  seatStripeSubscriptionId?: InputMaybe<OrderBy>;
  /** [Slack integration] - used to connect to Slack */
  slackAccessToken?: InputMaybe<OrderBy>;
  /** [Slack integration] - used to connect to Slack */
  slackIdentifier?: InputMaybe<OrderBy>;
  /** [Slack integration] - the name of the Slack Workspace that the account is connected to */
  slackTeamName?: InputMaybe<OrderBy>;
  /** Stripe subscription ID for the storage subscription */
  storageStripeSubscriptionId?: InputMaybe<OrderBy>;
  /**
   * Each subscription in Stripe has subscription items. We store the ID of the item,
   * because we need to know it to update the usage and it saves us from having to call
   * Stripe to get the item ID.
   *
   */
  storageStripeSubscriptionItemId?: InputMaybe<OrderBy>;
  /** [payments] ID of user in Stripe, so that they can be charged */
  stripeId?: InputMaybe<OrderBy>;
  subscribedAt?: InputMaybe<OrderBy>;
  trialEndsAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** URL pointing to the full resolution workspace icon */
  workspaceIconUrl?: InputMaybe<OrderBy>;
  /** Timestamp when the workspace icon URL expires */
  workspaceIconUrlExpiresAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "accounts" */
export type AccountsMutationResponse = {
  __typename?: 'AccountsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Accounts>;
};

/** input type for inserting object relation for remote table "accounts" */
export type AccountsObjRelInsertInput = {
  data: AccountsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<AccountsOnConflict>;
};

/** on_conflict condition type for table "accounts" */
export type AccountsOnConflict = {
  constraint: AccountsConstraint;
  updateColumns?: Array<AccountsUpdateColumn>;
  where?: InputMaybe<AccountsBoolExp>;
};

/** Ordering options when selecting data from "accounts". */
export type AccountsOrderBy = {
  accountInvoicesAggregate?: InputMaybe<AccountInvoicesAggregateOrderBy>;
  accountUsersAggregate?: InputMaybe<AccountUsersAggregateOrderBy>;
  airtableId?: InputMaybe<OrderBy>;
  attioCompanyRecordId?: InputMaybe<OrderBy>;
  automaticallyRunAiChecks?: InputMaybe<OrderBy>;
  billingAddress1?: InputMaybe<OrderBy>;
  billingAddress2?: InputMaybe<OrderBy>;
  billingCity?: InputMaybe<OrderBy>;
  billingCountry?: InputMaybe<OrderBy>;
  billingEmail?: InputMaybe<OrderBy>;
  billingName?: InputMaybe<OrderBy>;
  billingPostalCode?: InputMaybe<OrderBy>;
  billingState?: InputMaybe<OrderBy>;
  billingVatId?: InputMaybe<OrderBy>;
  brandingFont?: InputMaybe<OrderBy>;
  brandingMainBgColor?: InputMaybe<OrderBy>;
  brandingSidebarBgColor?: InputMaybe<OrderBy>;
  brandingSidebarTextColor?: InputMaybe<OrderBy>;
  cancelledAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  creditBalance?: InputMaybe<OrderBy>;
  demo?: InputMaybe<OrderBy>;
  documentsAggregate?: InputMaybe<DocumentsAggregateOrderBy>;
  hasClients?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  inviteToken?: InputMaybe<OrderBy>;
  isDemo?: InputMaybe<OrderBy>;
  isStorageEnabled?: InputMaybe<OrderBy>;
  isTimelineEnabled?: InputMaybe<OrderBy>;
  kanbanDisplaySettings?: InputMaybe<OrderBy>;
  labelsAggregate?: InputMaybe<LabelsAggregateOrderBy>;
  lanesAggregate?: InputMaybe<LanesAggregateOrderBy>;
  livesitesScreenshotsEnabled?: InputMaybe<OrderBy>;
  marketingSource?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  notificationsAggregate?: InputMaybe<NotificationsAggregateOrderBy>;
  offerDesktopNotifications?: InputMaybe<OrderBy>;
  ownerId?: InputMaybe<OrderBy>;
  ownerUser?: InputMaybe<UsersOrderBy>;
  photoProcessingError?: InputMaybe<OrderBy>;
  photoProcessingStatus?: InputMaybe<OrderBy>;
  projectUsersAggregate?: InputMaybe<ProjectUsersAggregateOrderBy>;
  projectsAggregate?: InputMaybe<ProjectsAggregateOrderBy>;
  referredByAccount?: InputMaybe<AccountsOrderBy>;
  referredByAccountId?: InputMaybe<OrderBy>;
  seatStripeSubscriptionId?: InputMaybe<OrderBy>;
  slackAccessToken?: InputMaybe<OrderBy>;
  slackIdentifier?: InputMaybe<OrderBy>;
  slackTeamName?: InputMaybe<OrderBy>;
  storageStripeSubscriptionId?: InputMaybe<OrderBy>;
  storageStripeSubscriptionItemId?: InputMaybe<OrderBy>;
  stripeId?: InputMaybe<OrderBy>;
  subscribedAt?: InputMaybe<OrderBy>;
  subscriptionStatus?: InputMaybe<OrderBy>;
  subscriptionType?: InputMaybe<OrderBy>;
  timelineEnableRowNames?: InputMaybe<OrderBy>;
  trialEndsAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  workspaceIconUrl?: InputMaybe<OrderBy>;
  workspaceIconUrlExpiresAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: accounts */
export type AccountsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AccountsPrependInput = {
  /** check if used, potentially remove. Was used for global default kanban display settings */
  kanbanDisplaySettings?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "accounts" */
export enum AccountsSelectColumn {
  /** column name */
  AirtableId = 'airtableId',
  /** column name */
  AttioCompanyRecordId = 'attioCompanyRecordId',
  /** column name */
  AutomaticallyRunAiChecks = 'automaticallyRunAiChecks',
  /** column name */
  BillingAddress1 = 'billingAddress1',
  /** column name */
  BillingAddress2 = 'billingAddress2',
  /** column name */
  BillingCity = 'billingCity',
  /** column name */
  BillingCountry = 'billingCountry',
  /** column name */
  BillingEmail = 'billingEmail',
  /** column name */
  BillingName = 'billingName',
  /** column name */
  BillingPostalCode = 'billingPostalCode',
  /** column name */
  BillingState = 'billingState',
  /** column name */
  BillingVatId = 'billingVatId',
  /** column name */
  BrandingFont = 'brandingFont',
  /** column name */
  BrandingMainBgColor = 'brandingMainBgColor',
  /** column name */
  BrandingSidebarBgColor = 'brandingSidebarBgColor',
  /** column name */
  BrandingSidebarTextColor = 'brandingSidebarTextColor',
  /** column name */
  CancelledAt = 'cancelledAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreditBalance = 'creditBalance',
  /** column name */
  Demo = 'demo',
  /** column name */
  HasClients = 'hasClients',
  /** column name */
  Id = 'id',
  /** column name */
  InviteToken = 'inviteToken',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  IsStorageEnabled = 'isStorageEnabled',
  /** column name */
  IsTimelineEnabled = 'isTimelineEnabled',
  /** column name */
  KanbanDisplaySettings = 'kanbanDisplaySettings',
  /** column name */
  LivesitesScreenshotsEnabled = 'livesitesScreenshotsEnabled',
  /** column name */
  MarketingSource = 'marketingSource',
  /** column name */
  Name = 'name',
  /** column name */
  OfferDesktopNotifications = 'offerDesktopNotifications',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  PhotoProcessingError = 'photoProcessingError',
  /** column name */
  PhotoProcessingStatus = 'photoProcessingStatus',
  /** column name */
  ReferredByAccountId = 'referredByAccountId',
  /** column name */
  SeatStripeSubscriptionId = 'seatStripeSubscriptionId',
  /** column name */
  SlackAccessToken = 'slackAccessToken',
  /** column name */
  SlackIdentifier = 'slackIdentifier',
  /** column name */
  SlackTeamName = 'slackTeamName',
  /** column name */
  StorageStripeSubscriptionId = 'storageStripeSubscriptionId',
  /** column name */
  StorageStripeSubscriptionItemId = 'storageStripeSubscriptionItemId',
  /** column name */
  StripeId = 'stripeId',
  /** column name */
  SubscribedAt = 'subscribedAt',
  /** column name */
  SubscriptionStatus = 'subscriptionStatus',
  /** column name */
  SubscriptionType = 'subscriptionType',
  /** column name */
  TimelineEnableRowNames = 'timelineEnableRowNames',
  /** column name */
  TrialEndsAt = 'trialEndsAt',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WorkspaceIconUrl = 'workspaceIconUrl',
  /** column name */
  WorkspaceIconUrlExpiresAt = 'workspaceIconUrlExpiresAt'
}

/** select "accountsAggregateBoolExpBool_andArgumentsColumns" columns of table "accounts" */
export enum AccountsSelectColumnAccountsAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  AutomaticallyRunAiChecks = 'automaticallyRunAiChecks',
  /** column name */
  Demo = 'demo',
  /** column name */
  HasClients = 'hasClients',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  IsStorageEnabled = 'isStorageEnabled',
  /** column name */
  IsTimelineEnabled = 'isTimelineEnabled',
  /** column name */
  LivesitesScreenshotsEnabled = 'livesitesScreenshotsEnabled',
  /** column name */
  OfferDesktopNotifications = 'offerDesktopNotifications',
  /** column name */
  TimelineEnableRowNames = 'timelineEnableRowNames'
}

/** select "accountsAggregateBoolExpBool_orArgumentsColumns" columns of table "accounts" */
export enum AccountsSelectColumnAccountsAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  AutomaticallyRunAiChecks = 'automaticallyRunAiChecks',
  /** column name */
  Demo = 'demo',
  /** column name */
  HasClients = 'hasClients',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  IsStorageEnabled = 'isStorageEnabled',
  /** column name */
  IsTimelineEnabled = 'isTimelineEnabled',
  /** column name */
  LivesitesScreenshotsEnabled = 'livesitesScreenshotsEnabled',
  /** column name */
  OfferDesktopNotifications = 'offerDesktopNotifications',
  /** column name */
  TimelineEnableRowNames = 'timelineEnableRowNames'
}

/** input type for updating data in table "accounts" */
export type AccountsSetInput = {
  /** [Airtable integration] - remove */
  airtableId?: InputMaybe<Scalars['String']['input']>;
  /** Record ID of a corresponding company in Attio */
  attioCompanyRecordId?: InputMaybe<Scalars['String']['input']>;
  /** [AI checks] - defines if AI checks automatically run for the account */
  automaticallyRunAiChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Billing address line 1 */
  billingAddress1?: InputMaybe<Scalars['String']['input']>;
  /** Billing address line 2 */
  billingAddress2?: InputMaybe<Scalars['String']['input']>;
  /** Billing city */
  billingCity?: InputMaybe<Scalars['String']['input']>;
  /** Billing country */
  billingCountry?: InputMaybe<Scalars['String']['input']>;
  /** Billing email */
  billingEmail?: InputMaybe<Scalars['String']['input']>;
  /** Billing name */
  billingName?: InputMaybe<Scalars['String']['input']>;
  /** Billing postal code */
  billingPostalCode?: InputMaybe<Scalars['String']['input']>;
  /** Billing state */
  billingState?: InputMaybe<Scalars['String']['input']>;
  /** Billing VAT ID */
  billingVatId?: InputMaybe<Scalars['String']['input']>;
  /** [branding] - remove */
  brandingFont?: InputMaybe<Scalars['String']['input']>;
  /** [branding] - remove */
  brandingMainBgColor?: InputMaybe<Scalars['String']['input']>;
  /** [branding] - remove */
  brandingSidebarBgColor?: InputMaybe<Scalars['String']['input']>;
  /** [branding] - remove */
  brandingSidebarTextColor?: InputMaybe<Scalars['String']['input']>;
  cancelledAt?: InputMaybe<Scalars['date']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<Scalars['numeric']['input']>;
  /** [analytics] Needs consolidation with is_demo. If this account is a demo account we can remove it from analytics */
  demo?: InputMaybe<Scalars['Boolean']['input']>;
  /** [clients] - remove */
  hasClients?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [invite to team] - used to identify the team in links that invite people to join the team */
  inviteToken?: InputMaybe<Scalars['uuid']['input']>;
  /** [analytics] Needs consolidation with is_demo. */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  /** [storage] - remove */
  isStorageEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** [timeline] - remove */
  isTimelineEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** check if used, potentially remove. Was used for global default kanban display settings */
  kanbanDisplaySettings?: InputMaybe<Scalars['jsonb']['input']>;
  /** Feature flag for livesites screenshots. We cannot use PostHog because it works on the user level, whereas we need account level. So that clients of customers could use screenshots too */
  livesitesScreenshotsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Contains a 1 or 2 word value for the marketing source */
  marketingSource?: InputMaybe<Scalars['String']['input']>;
  /** name of the workspace */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Fix or remove. Users were previously, at one point, offered browser-based notifications. This is not related to electron. This broke and nobody has fixed it. */
  offerDesktopNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  /** [permissions] To revisit. The user who is the owner. At time of writing 23/11/24 the only perk is the ability to delete the account. Users would like to assign multiple, so this permission level should be moved to account_user. */
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing activity and can log if an error has occured (e.g. invalid upload). */
  photoProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** ID of the account who referred the current account */
  referredByAccountId?: InputMaybe<Scalars['uuid']['input']>;
  /** Stripe subscription ID for the per seat subscription */
  seatStripeSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  /** [Slack integration] - used to connect to Slack */
  slackAccessToken?: InputMaybe<Scalars['String']['input']>;
  /** [Slack integration] - used to connect to Slack */
  slackIdentifier?: InputMaybe<Scalars['String']['input']>;
  /** [Slack integration] - the name of the Slack Workspace that the account is connected to */
  slackTeamName?: InputMaybe<Scalars['String']['input']>;
  /** Stripe subscription ID for the storage subscription */
  storageStripeSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Each subscription in Stripe has subscription items. We store the ID of the item,
   * because we need to know it to update the usage and it saves us from having to call
   * Stripe to get the item ID.
   *
   */
  storageStripeSubscriptionItemId?: InputMaybe<Scalars['String']['input']>;
  /** [payments] ID of user in Stripe, so that they can be charged */
  stripeId?: InputMaybe<Scalars['String']['input']>;
  subscribedAt?: InputMaybe<Scalars['date']['input']>;
  subscriptionStatus?: InputMaybe<SubscriptionStatusesEnum>;
  subscriptionType?: InputMaybe<SubscriptionTypesEnum>;
  /** [timeline] - remove */
  timelineEnableRowNames?: InputMaybe<Scalars['Boolean']['input']>;
  trialEndsAt?: InputMaybe<Scalars['timestamp']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** URL pointing to the full resolution workspace icon */
  workspaceIconUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the workspace icon URL expires */
  workspaceIconUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate stddev on columns */
export type AccountsStddevFields = {
  __typename?: 'AccountsStddevFields';
  /** Credit balance towards next bill */
  creditBalance?: Maybe<Scalars['Float']['output']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "accounts" */
export type AccountsStddevOrderBy = {
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<OrderBy>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type AccountsStddevPopFields = {
  __typename?: 'AccountsStddevPopFields';
  /** Credit balance towards next bill */
  creditBalance?: Maybe<Scalars['Float']['output']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "accounts" */
export type AccountsStddevPopOrderBy = {
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<OrderBy>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type AccountsStddevSampFields = {
  __typename?: 'AccountsStddevSampFields';
  /** Credit balance towards next bill */
  creditBalance?: Maybe<Scalars['Float']['output']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "accounts" */
export type AccountsStddevSampOrderBy = {
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<OrderBy>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "accounts" */
export type AccountsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AccountsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AccountsStreamCursorValueInput = {
  /** [Airtable integration] - remove */
  airtableId?: InputMaybe<Scalars['String']['input']>;
  /** Record ID of a corresponding company in Attio */
  attioCompanyRecordId?: InputMaybe<Scalars['String']['input']>;
  /** [AI checks] - defines if AI checks automatically run for the account */
  automaticallyRunAiChecks?: InputMaybe<Scalars['Boolean']['input']>;
  /** Billing address line 1 */
  billingAddress1?: InputMaybe<Scalars['String']['input']>;
  /** Billing address line 2 */
  billingAddress2?: InputMaybe<Scalars['String']['input']>;
  /** Billing city */
  billingCity?: InputMaybe<Scalars['String']['input']>;
  /** Billing country */
  billingCountry?: InputMaybe<Scalars['String']['input']>;
  /** Billing email */
  billingEmail?: InputMaybe<Scalars['String']['input']>;
  /** Billing name */
  billingName?: InputMaybe<Scalars['String']['input']>;
  /** Billing postal code */
  billingPostalCode?: InputMaybe<Scalars['String']['input']>;
  /** Billing state */
  billingState?: InputMaybe<Scalars['String']['input']>;
  /** Billing VAT ID */
  billingVatId?: InputMaybe<Scalars['String']['input']>;
  /** [branding] - remove */
  brandingFont?: InputMaybe<Scalars['String']['input']>;
  /** [branding] - remove */
  brandingMainBgColor?: InputMaybe<Scalars['String']['input']>;
  /** [branding] - remove */
  brandingSidebarBgColor?: InputMaybe<Scalars['String']['input']>;
  /** [branding] - remove */
  brandingSidebarTextColor?: InputMaybe<Scalars['String']['input']>;
  cancelledAt?: InputMaybe<Scalars['date']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<Scalars['numeric']['input']>;
  /** [analytics] Needs consolidation with is_demo. If this account is a demo account we can remove it from analytics */
  demo?: InputMaybe<Scalars['Boolean']['input']>;
  /** [clients] - remove */
  hasClients?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [invite to team] - used to identify the team in links that invite people to join the team */
  inviteToken?: InputMaybe<Scalars['uuid']['input']>;
  /** [analytics] Needs consolidation with is_demo. */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  /** [storage] - remove */
  isStorageEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** [timeline] - remove */
  isTimelineEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** check if used, potentially remove. Was used for global default kanban display settings */
  kanbanDisplaySettings?: InputMaybe<Scalars['jsonb']['input']>;
  /** Feature flag for livesites screenshots. We cannot use PostHog because it works on the user level, whereas we need account level. So that clients of customers could use screenshots too */
  livesitesScreenshotsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Contains a 1 or 2 word value for the marketing source */
  marketingSource?: InputMaybe<Scalars['String']['input']>;
  /** name of the workspace */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Fix or remove. Users were previously, at one point, offered browser-based notifications. This is not related to electron. This broke and nobody has fixed it. */
  offerDesktopNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  /** [permissions] To revisit. The user who is the owner. At time of writing 23/11/24 the only perk is the ability to delete the account. Users would like to assign multiple, so this permission level should be moved to account_user. */
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing activity and can log if an error has occured (e.g. invalid upload). */
  photoProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** ID of the account who referred the current account */
  referredByAccountId?: InputMaybe<Scalars['uuid']['input']>;
  /** Stripe subscription ID for the per seat subscription */
  seatStripeSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  /** [Slack integration] - used to connect to Slack */
  slackAccessToken?: InputMaybe<Scalars['String']['input']>;
  /** [Slack integration] - used to connect to Slack */
  slackIdentifier?: InputMaybe<Scalars['String']['input']>;
  /** [Slack integration] - the name of the Slack Workspace that the account is connected to */
  slackTeamName?: InputMaybe<Scalars['String']['input']>;
  /** Stripe subscription ID for the storage subscription */
  storageStripeSubscriptionId?: InputMaybe<Scalars['String']['input']>;
  /**
   * Each subscription in Stripe has subscription items. We store the ID of the item,
   * because we need to know it to update the usage and it saves us from having to call
   * Stripe to get the item ID.
   *
   */
  storageStripeSubscriptionItemId?: InputMaybe<Scalars['String']['input']>;
  /** [payments] ID of user in Stripe, so that they can be charged */
  stripeId?: InputMaybe<Scalars['String']['input']>;
  subscribedAt?: InputMaybe<Scalars['date']['input']>;
  subscriptionStatus?: InputMaybe<SubscriptionStatusesEnum>;
  subscriptionType?: InputMaybe<SubscriptionTypesEnum>;
  /** [timeline] - remove */
  timelineEnableRowNames?: InputMaybe<Scalars['Boolean']['input']>;
  trialEndsAt?: InputMaybe<Scalars['timestamp']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** URL pointing to the full resolution workspace icon */
  workspaceIconUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the workspace icon URL expires */
  workspaceIconUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate sum on columns */
export type AccountsSumFields = {
  __typename?: 'AccountsSumFields';
  /** Credit balance towards next bill */
  creditBalance?: Maybe<Scalars['numeric']['output']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "accounts" */
export type AccountsSumOrderBy = {
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<OrderBy>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<OrderBy>;
};

/** update columns of table "accounts" */
export enum AccountsUpdateColumn {
  /** column name */
  AirtableId = 'airtableId',
  /** column name */
  AttioCompanyRecordId = 'attioCompanyRecordId',
  /** column name */
  AutomaticallyRunAiChecks = 'automaticallyRunAiChecks',
  /** column name */
  BillingAddress1 = 'billingAddress1',
  /** column name */
  BillingAddress2 = 'billingAddress2',
  /** column name */
  BillingCity = 'billingCity',
  /** column name */
  BillingCountry = 'billingCountry',
  /** column name */
  BillingEmail = 'billingEmail',
  /** column name */
  BillingName = 'billingName',
  /** column name */
  BillingPostalCode = 'billingPostalCode',
  /** column name */
  BillingState = 'billingState',
  /** column name */
  BillingVatId = 'billingVatId',
  /** column name */
  BrandingFont = 'brandingFont',
  /** column name */
  BrandingMainBgColor = 'brandingMainBgColor',
  /** column name */
  BrandingSidebarBgColor = 'brandingSidebarBgColor',
  /** column name */
  BrandingSidebarTextColor = 'brandingSidebarTextColor',
  /** column name */
  CancelledAt = 'cancelledAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreditBalance = 'creditBalance',
  /** column name */
  Demo = 'demo',
  /** column name */
  HasClients = 'hasClients',
  /** column name */
  Id = 'id',
  /** column name */
  InviteToken = 'inviteToken',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  IsStorageEnabled = 'isStorageEnabled',
  /** column name */
  IsTimelineEnabled = 'isTimelineEnabled',
  /** column name */
  KanbanDisplaySettings = 'kanbanDisplaySettings',
  /** column name */
  LivesitesScreenshotsEnabled = 'livesitesScreenshotsEnabled',
  /** column name */
  MarketingSource = 'marketingSource',
  /** column name */
  Name = 'name',
  /** column name */
  OfferDesktopNotifications = 'offerDesktopNotifications',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  PhotoProcessingError = 'photoProcessingError',
  /** column name */
  PhotoProcessingStatus = 'photoProcessingStatus',
  /** column name */
  ReferredByAccountId = 'referredByAccountId',
  /** column name */
  SeatStripeSubscriptionId = 'seatStripeSubscriptionId',
  /** column name */
  SlackAccessToken = 'slackAccessToken',
  /** column name */
  SlackIdentifier = 'slackIdentifier',
  /** column name */
  SlackTeamName = 'slackTeamName',
  /** column name */
  StorageStripeSubscriptionId = 'storageStripeSubscriptionId',
  /** column name */
  StorageStripeSubscriptionItemId = 'storageStripeSubscriptionItemId',
  /** column name */
  StripeId = 'stripeId',
  /** column name */
  SubscribedAt = 'subscribedAt',
  /** column name */
  SubscriptionStatus = 'subscriptionStatus',
  /** column name */
  SubscriptionType = 'subscriptionType',
  /** column name */
  TimelineEnableRowNames = 'timelineEnableRowNames',
  /** column name */
  TrialEndsAt = 'trialEndsAt',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WorkspaceIconUrl = 'workspaceIconUrl',
  /** column name */
  WorkspaceIconUrlExpiresAt = 'workspaceIconUrlExpiresAt'
}

export type AccountsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<AccountsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<AccountsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<AccountsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<AccountsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AccountsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<AccountsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AccountsSetInput>;
  /** filter the rows which have to be updated */
  where: AccountsBoolExp;
};

/** aggregate varPop on columns */
export type AccountsVarPopFields = {
  __typename?: 'AccountsVarPopFields';
  /** Credit balance towards next bill */
  creditBalance?: Maybe<Scalars['Float']['output']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "accounts" */
export type AccountsVarPopOrderBy = {
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<OrderBy>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type AccountsVarSampFields = {
  __typename?: 'AccountsVarSampFields';
  /** Credit balance towards next bill */
  creditBalance?: Maybe<Scalars['Float']['output']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "accounts" */
export type AccountsVarSampOrderBy = {
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<OrderBy>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type AccountsVarianceFields = {
  __typename?: 'AccountsVarianceFields';
  /** Credit balance towards next bill */
  creditBalance?: Maybe<Scalars['Float']['output']>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "accounts" */
export type AccountsVarianceOrderBy = {
  /** Credit balance towards next bill */
  creditBalance?: InputMaybe<OrderBy>;
  /** [logo] we process any uploaded logo into the correct size for the screen. This field tracks the status of that processing. This is a enum, which relates to the statuses defined in the Account model */
  photoProcessingStatus?: InputMaybe<OrderBy>;
};

export enum Actions_SubscriptionTypesEnum {
  PerSeatAnnual = 'PER_SEAT_ANNUAL',
  PerSeatMonthly = 'PER_SEAT_MONTHLY',
  UnlimitedAnnual = 'UNLIMITED_ANNUAL',
  UnlimitedMonthly = 'UNLIMITED_MONTHLY'
}

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type BigintComparisonExp = {
  _eq?: InputMaybe<Scalars['bigint']['input']>;
  _gt?: InputMaybe<Scalars['bigint']['input']>;
  _gte?: InputMaybe<Scalars['bigint']['input']>;
  _in?: InputMaybe<Array<Scalars['bigint']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['bigint']['input']>;
  _lte?: InputMaybe<Scalars['bigint']['input']>;
  _neq?: InputMaybe<Scalars['bigint']['input']>;
  _nin?: InputMaybe<Array<Scalars['bigint']['input']>>;
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type BooleanComparisonExp = {
  _eq?: InputMaybe<Scalars['Boolean']['input']>;
  _gt?: InputMaybe<Scalars['Boolean']['input']>;
  _gte?: InputMaybe<Scalars['Boolean']['input']>;
  _in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Boolean']['input']>;
  _lte?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Scalars['Boolean']['input']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

/** [Displaying assets] Each version has one or more pieces of content to display, which are stored as canvas items. All items that are shown to users are Canvas Items. Data specific to specific types of asset are stored in sub-type models (FileItem, SiteItem, etc) */
export type CanvasItems = {
  __typename?: 'CanvasItems';
  accountId: Scalars['uuid']['output'];
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes: Scalars['bigint']['output'];
  createdAt: Scalars['timestamp']['output'];
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: Maybe<Scalars['Int']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  fileItem?: Maybe<FileItems>;
  id: Scalars['uuid']['output'];
  lastModifiedVersion: Scalars['Int']['output'];
  /** An object relationship */
  pdfItem?: Maybe<PdfItems>;
  /** The order of the item on the canvas. */
  position: Scalars['Int']['output'];
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: Maybe<Scalars['Int']['output']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  siteItem?: Maybe<SiteItems>;
  /** An object relationship */
  textItem?: Maybe<TextItems>;
  updatedAt: Scalars['timestamp']['output'];
  /** An object relationship */
  version: Versions;
  versionId: Scalars['uuid']['output'];
  /** An object relationship */
  videoItem?: Maybe<VideoItems>;
};

/** aggregated selection of "canvas_items" */
export type CanvasItemsAggregate = {
  __typename?: 'CanvasItemsAggregate';
  aggregate?: Maybe<CanvasItemsAggregateFields>;
  nodes: Array<CanvasItems>;
};

export type CanvasItemsAggregateBoolExp = {
  count?: InputMaybe<CanvasItemsAggregateBoolExpCount>;
};

/** aggregate fields of "canvas_items" */
export type CanvasItemsAggregateFields = {
  __typename?: 'CanvasItemsAggregateFields';
  avg?: Maybe<CanvasItemsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<CanvasItemsMaxFields>;
  min?: Maybe<CanvasItemsMinFields>;
  stddev?: Maybe<CanvasItemsStddevFields>;
  stddevPop?: Maybe<CanvasItemsStddevPopFields>;
  stddevSamp?: Maybe<CanvasItemsStddevSampFields>;
  sum?: Maybe<CanvasItemsSumFields>;
  varPop?: Maybe<CanvasItemsVarPopFields>;
  varSamp?: Maybe<CanvasItemsVarSampFields>;
  variance?: Maybe<CanvasItemsVarianceFields>;
};


/** aggregate fields of "canvas_items" */
export type CanvasItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CanvasItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "canvas_items" */
export type CanvasItemsAggregateOrderBy = {
  avg?: InputMaybe<CanvasItemsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<CanvasItemsMaxOrderBy>;
  min?: InputMaybe<CanvasItemsMinOrderBy>;
  stddev?: InputMaybe<CanvasItemsStddevOrderBy>;
  stddevPop?: InputMaybe<CanvasItemsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<CanvasItemsStddevSampOrderBy>;
  sum?: InputMaybe<CanvasItemsSumOrderBy>;
  varPop?: InputMaybe<CanvasItemsVarPopOrderBy>;
  varSamp?: InputMaybe<CanvasItemsVarSampOrderBy>;
  variance?: InputMaybe<CanvasItemsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "canvas_items" */
export type CanvasItemsArrRelInsertInput = {
  data: Array<CanvasItemsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<CanvasItemsOnConflict>;
};

/** aggregate avg on columns */
export type CanvasItemsAvgFields = {
  __typename?: 'CanvasItemsAvgFields';
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The order of the item on the canvas. */
  position?: Maybe<Scalars['Float']['output']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "canvas_items" */
export type CanvasItemsAvgOrderBy = {
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<OrderBy>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<OrderBy>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "canvas_items". All fields are combined with a logical 'AND'. */
export type CanvasItemsBoolExp = {
  _and?: InputMaybe<Array<CanvasItemsBoolExp>>;
  _not?: InputMaybe<CanvasItemsBoolExp>;
  _or?: InputMaybe<Array<CanvasItemsBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  chargeableSizeInBytes?: InputMaybe<BigintComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  figmaPositionX?: InputMaybe<IntComparisonExp>;
  figmaPositionY?: InputMaybe<IntComparisonExp>;
  fileItem?: InputMaybe<FileItemsBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  pdfItem?: InputMaybe<PdfItemsBoolExp>;
  position?: InputMaybe<IntComparisonExp>;
  positionX?: InputMaybe<IntComparisonExp>;
  positionY?: InputMaybe<IntComparisonExp>;
  siteItem?: InputMaybe<SiteItemsBoolExp>;
  textItem?: InputMaybe<TextItemsBoolExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<VersionsBoolExp>;
  versionId?: InputMaybe<UuidComparisonExp>;
  videoItem?: InputMaybe<VideoItemsBoolExp>;
};

/** unique or primary key constraints on table "canvas_items" */
export enum CanvasItemsConstraint {
  /** unique or primary key constraint on columns "id" */
  CanvasItemsPkey = 'canvas_items_pkey'
}

/** input type for incrementing numeric columns in table "canvas_items" */
export type CanvasItemsIncInput = {
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<Scalars['bigint']['input']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<Scalars['Int']['input']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<Scalars['Int']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<Scalars['Int']['input']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "canvas_items" */
export type CanvasItemsInsertInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<Scalars['bigint']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<Scalars['Int']['input']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<Scalars['Int']['input']>;
  fileItem?: InputMaybe<FileItemsObjRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  pdfItem?: InputMaybe<PdfItemsObjRelInsertInput>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<Scalars['Int']['input']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<Scalars['Int']['input']>;
  siteItem?: InputMaybe<SiteItemsObjRelInsertInput>;
  textItem?: InputMaybe<TextItemsObjRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  version?: InputMaybe<VersionsObjRelInsertInput>;
  versionId?: InputMaybe<Scalars['uuid']['input']>;
  videoItem?: InputMaybe<VideoItemsObjRelInsertInput>;
};

/** aggregate max on columns */
export type CanvasItemsMaxFields = {
  __typename?: 'CanvasItemsMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: Maybe<Scalars['bigint']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: Maybe<Scalars['Int']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** The order of the item on the canvas. */
  position?: Maybe<Scalars['Int']['output']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: Maybe<Scalars['Int']['output']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  versionId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "canvas_items" */
export type CanvasItemsMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<OrderBy>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<OrderBy>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  versionId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type CanvasItemsMinFields = {
  __typename?: 'CanvasItemsMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: Maybe<Scalars['bigint']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: Maybe<Scalars['Int']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** The order of the item on the canvas. */
  position?: Maybe<Scalars['Int']['output']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: Maybe<Scalars['Int']['output']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  versionId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "canvas_items" */
export type CanvasItemsMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<OrderBy>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<OrderBy>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  versionId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "canvas_items" */
export type CanvasItemsMutationResponse = {
  __typename?: 'CanvasItemsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<CanvasItems>;
};

/** input type for inserting object relation for remote table "canvas_items" */
export type CanvasItemsObjRelInsertInput = {
  data: CanvasItemsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<CanvasItemsOnConflict>;
};

/** on_conflict condition type for table "canvas_items" */
export type CanvasItemsOnConflict = {
  constraint: CanvasItemsConstraint;
  updateColumns?: Array<CanvasItemsUpdateColumn>;
  where?: InputMaybe<CanvasItemsBoolExp>;
};

/** Ordering options when selecting data from "canvas_items". */
export type CanvasItemsOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  chargeableSizeInBytes?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  figmaPositionX?: InputMaybe<OrderBy>;
  figmaPositionY?: InputMaybe<OrderBy>;
  fileItem?: InputMaybe<FileItemsOrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  pdfItem?: InputMaybe<PdfItemsOrderBy>;
  position?: InputMaybe<OrderBy>;
  positionX?: InputMaybe<OrderBy>;
  positionY?: InputMaybe<OrderBy>;
  siteItem?: InputMaybe<SiteItemsOrderBy>;
  textItem?: InputMaybe<TextItemsOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  version?: InputMaybe<VersionsOrderBy>;
  versionId?: InputMaybe<OrderBy>;
  videoItem?: InputMaybe<VideoItemsOrderBy>;
};

/** primary key columns input for table: canvas_items */
export type CanvasItemsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "canvas_items" */
export enum CanvasItemsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  ChargeableSizeInBytes = 'chargeableSizeInBytes',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FigmaPositionX = 'figmaPositionX',
  /** column name */
  FigmaPositionY = 'figmaPositionY',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  Position = 'position',
  /** column name */
  PositionX = 'positionX',
  /** column name */
  PositionY = 'positionY',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VersionId = 'versionId'
}

/** input type for updating data in table "canvas_items" */
export type CanvasItemsSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<Scalars['bigint']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<Scalars['Int']['input']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<Scalars['Int']['input']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  versionId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type CanvasItemsStddevFields = {
  __typename?: 'CanvasItemsStddevFields';
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The order of the item on the canvas. */
  position?: Maybe<Scalars['Float']['output']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "canvas_items" */
export type CanvasItemsStddevOrderBy = {
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<OrderBy>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<OrderBy>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type CanvasItemsStddevPopFields = {
  __typename?: 'CanvasItemsStddevPopFields';
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The order of the item on the canvas. */
  position?: Maybe<Scalars['Float']['output']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "canvas_items" */
export type CanvasItemsStddevPopOrderBy = {
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<OrderBy>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<OrderBy>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type CanvasItemsStddevSampFields = {
  __typename?: 'CanvasItemsStddevSampFields';
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The order of the item on the canvas. */
  position?: Maybe<Scalars['Float']['output']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "canvas_items" */
export type CanvasItemsStddevSampOrderBy = {
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<OrderBy>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<OrderBy>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "canvas_items" */
export type CanvasItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CanvasItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CanvasItemsStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<Scalars['bigint']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<Scalars['Int']['input']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<Scalars['Int']['input']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  versionId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type CanvasItemsSumFields = {
  __typename?: 'CanvasItemsSumFields';
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: Maybe<Scalars['bigint']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: Maybe<Scalars['Int']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: Maybe<Scalars['Int']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** The order of the item on the canvas. */
  position?: Maybe<Scalars['Int']['output']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: Maybe<Scalars['Int']['output']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "canvas_items" */
export type CanvasItemsSumOrderBy = {
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<OrderBy>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<OrderBy>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<OrderBy>;
};

/** update columns of table "canvas_items" */
export enum CanvasItemsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  ChargeableSizeInBytes = 'chargeableSizeInBytes',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FigmaPositionX = 'figmaPositionX',
  /** column name */
  FigmaPositionY = 'figmaPositionY',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  Position = 'position',
  /** column name */
  PositionX = 'positionX',
  /** column name */
  PositionY = 'positionY',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VersionId = 'versionId'
}

export type CanvasItemsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CanvasItemsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CanvasItemsSetInput>;
  /** filter the rows which have to be updated */
  where: CanvasItemsBoolExp;
};

/** aggregate varPop on columns */
export type CanvasItemsVarPopFields = {
  __typename?: 'CanvasItemsVarPopFields';
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The order of the item on the canvas. */
  position?: Maybe<Scalars['Float']['output']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "canvas_items" */
export type CanvasItemsVarPopOrderBy = {
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<OrderBy>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<OrderBy>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type CanvasItemsVarSampFields = {
  __typename?: 'CanvasItemsVarSampFields';
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The order of the item on the canvas. */
  position?: Maybe<Scalars['Float']['output']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "canvas_items" */
export type CanvasItemsVarSampOrderBy = {
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<OrderBy>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<OrderBy>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type CanvasItemsVarianceFields = {
  __typename?: 'CanvasItemsVarianceFields';
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The order of the item on the canvas. */
  position?: Maybe<Scalars['Float']['output']>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "canvas_items" */
export type CanvasItemsVarianceOrderBy = {
  /** The size of the canvas item, in bytes if we charge for its type */
  chargeableSizeInBytes?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column simply ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. */
  figmaPositionY?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The order of the item on the canvas. */
  position?: InputMaybe<OrderBy>;
  /** The x coordinate of the item on the canvas. Calculated async. */
  positionX?: InputMaybe<OrderBy>;
  /** The y coordinate of the item on the canvas. Calculated async. */
  positionY?: InputMaybe<OrderBy>;
};

export type CheckoutSession = {
  __typename?: 'CheckoutSession';
  url: Scalars['String']['output'];
};

export type CompleteMultipartUploadInput = {
  bucket: Scalars['String']['input'];
  key: Scalars['String']['input'];
  parts: Array<MultipartUploadPartInput>;
  uploadId: Scalars['String']['input'];
};

export type CompleteMultipartUploadOutput = {
  __typename?: 'CompleteMultipartUploadOutput';
  storageObjectId: Scalars['uuid']['output'];
};

export type CreateDocumentOutput = {
  __typename?: 'CreateDocumentOutput';
  document_id?: Maybe<Scalars['uuid']['output']>;
  errors?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  success: Scalars['Boolean']['output'];
};

export type CreateDocumentWithVersionBlobsInput = {
  account_id: Scalars['uuid']['input'];
  assignee_id?: InputMaybe<Scalars['uuid']['input']>;
  content_blob_ids: Array<Scalars['String']['input']>;
  document_id: Scalars['uuid']['input'];
  due_at?: InputMaybe<Scalars['String']['input']>;
  fractional_position: Scalars['String']['input'];
  label_ids?: InputMaybe<Array<Scalars['uuid']['input']>>;
  lane_id: Scalars['uuid']['input'];
  name: Scalars['String']['input'];
  priority?: InputMaybe<Scalars['Int']['input']>;
  project_id?: InputMaybe<Scalars['uuid']['input']>;
  slug: Scalars['String']['input'];
  task_description?: InputMaybe<Scalars['jsonb']['input']>;
  version_id: Scalars['uuid']['input'];
};

export type CreateDocumentWithVersionSiteAdminInput = {
  account_id: Scalars['uuid']['input'];
  assignee_id?: InputMaybe<Scalars['uuid']['input']>;
  content_site_url: Scalars['String']['input'];
  document_id: Scalars['uuid']['input'];
  due_at?: InputMaybe<Scalars['String']['input']>;
  fractional_position: Scalars['String']['input'];
  is_demo?: InputMaybe<Scalars['Boolean']['input']>;
  label_ids?: InputMaybe<Array<Scalars['uuid']['input']>>;
  lane_id: Scalars['uuid']['input'];
  name: Scalars['String']['input'];
  priority?: InputMaybe<Scalars['Int']['input']>;
  project_id?: InputMaybe<Scalars['uuid']['input']>;
  slug: Scalars['String']['input'];
  task_description?: InputMaybe<Scalars['jsonb']['input']>;
  user_id: Scalars['uuid']['input'];
  version_id: Scalars['uuid']['input'];
};

export type CreateDocumentWithVersionSiteInput = {
  account_id: Scalars['uuid']['input'];
  assignee_id?: InputMaybe<Scalars['uuid']['input']>;
  content_site_url: Scalars['String']['input'];
  document_id: Scalars['uuid']['input'];
  due_at?: InputMaybe<Scalars['String']['input']>;
  fractional_position: Scalars['String']['input'];
  label_ids?: InputMaybe<Array<Scalars['uuid']['input']>>;
  lane_id: Scalars['uuid']['input'];
  name: Scalars['String']['input'];
  priority?: InputMaybe<Scalars['Int']['input']>;
  project_id?: InputMaybe<Scalars['uuid']['input']>;
  slug: Scalars['String']['input'];
  task_description?: InputMaybe<Scalars['jsonb']['input']>;
  version_id: Scalars['uuid']['input'];
};

export type CreateDocumentWithoutVersionInput = {
  account_id: Scalars['uuid']['input'];
  assignee_id?: InputMaybe<Scalars['uuid']['input']>;
  document_id: Scalars['uuid']['input'];
  due_at?: InputMaybe<Scalars['String']['input']>;
  fractional_position: Scalars['String']['input'];
  label_ids?: InputMaybe<Array<Scalars['uuid']['input']>>;
  lane_id: Scalars['uuid']['input'];
  name: Scalars['String']['input'];
  priority?: InputMaybe<Scalars['Int']['input']>;
  project_id?: InputMaybe<Scalars['uuid']['input']>;
  slug: Scalars['String']['input'];
  task_description?: InputMaybe<Scalars['jsonb']['input']>;
};

export type CreateMessageFileInput = {
  account_id: Scalars['uuid']['input'];
  blob_id: Scalars['String']['input'];
  id: Scalars['uuid']['input'];
  name: Scalars['String']['input'];
};

export type CreateMessageFileOutput = {
  __typename?: 'CreateMessageFileOutput';
  errors?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  success: Scalars['Boolean']['output'];
};

export type CreateVersionOutput = {
  __typename?: 'CreateVersionOutput';
  errors?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  success: Scalars['Boolean']['output'];
  version_id?: Maybe<Scalars['uuid']['output']>;
};

export type CreateVersionWithBlobsInput = {
  content_blob_ids: Array<InputMaybe<Scalars['String']['input']>>;
  document_id: Scalars['uuid']['input'];
  id: Scalars['uuid']['input'];
};

export type CreateVersionWithSiteInput = {
  content_site_url: Scalars['String']['input'];
  document_id: Scalars['uuid']['input'];
  id: Scalars['uuid']['input'];
};

export type CreateVersionWithTextDoc = {
  document_id: Scalars['uuid']['input'];
  id: Scalars['uuid']['input'];
};

/** ordering argument of a cursor */
export enum CursorOrdering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type DateComparisonExp = {
  _eq?: InputMaybe<Scalars['date']['input']>;
  _gt?: InputMaybe<Scalars['date']['input']>;
  _gte?: InputMaybe<Scalars['date']['input']>;
  _in?: InputMaybe<Array<Scalars['date']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['date']['input']>;
  _lte?: InputMaybe<Scalars['date']['input']>;
  _neq?: InputMaybe<Scalars['date']['input']>;
  _nin?: InputMaybe<Array<Scalars['date']['input']>>;
};

/** Enum of possible DB event log types */
export type DbEventLogTypes = {
  __typename?: 'DbEventLogTypes';
  value: Scalars['String']['output'];
};

/** aggregated selection of "db_event_log_types" */
export type DbEventLogTypesAggregate = {
  __typename?: 'DbEventLogTypesAggregate';
  aggregate?: Maybe<DbEventLogTypesAggregateFields>;
  nodes: Array<DbEventLogTypes>;
};

/** aggregate fields of "db_event_log_types" */
export type DbEventLogTypesAggregateFields = {
  __typename?: 'DbEventLogTypesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<DbEventLogTypesMaxFields>;
  min?: Maybe<DbEventLogTypesMinFields>;
};


/** aggregate fields of "db_event_log_types" */
export type DbEventLogTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<DbEventLogTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "db_event_log_types". All fields are combined with a logical 'AND'. */
export type DbEventLogTypesBoolExp = {
  _and?: InputMaybe<Array<DbEventLogTypesBoolExp>>;
  _not?: InputMaybe<DbEventLogTypesBoolExp>;
  _or?: InputMaybe<Array<DbEventLogTypesBoolExp>>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "db_event_log_types" */
export enum DbEventLogTypesConstraint {
  /** unique or primary key constraint on columns "value" */
  DbEventLogTypesPkey = 'db_event_log_types_pkey'
}

export enum DbEventLogTypesEnum {
  Delete = 'DELETE',
  Insert = 'INSERT',
  Update = 'UPDATE'
}

/** Boolean expression to compare columns of type "DbEventLogTypesEnum". All fields are combined with logical 'AND'. */
export type DbEventLogTypesEnumComparisonExp = {
  _eq?: InputMaybe<DbEventLogTypesEnum>;
  _in?: InputMaybe<Array<DbEventLogTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<DbEventLogTypesEnum>;
  _nin?: InputMaybe<Array<DbEventLogTypesEnum>>;
};

/** input type for inserting data into table "db_event_log_types" */
export type DbEventLogTypesInsertInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type DbEventLogTypesMaxFields = {
  __typename?: 'DbEventLogTypesMaxFields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type DbEventLogTypesMinFields = {
  __typename?: 'DbEventLogTypesMinFields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "db_event_log_types" */
export type DbEventLogTypesMutationResponse = {
  __typename?: 'DbEventLogTypesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<DbEventLogTypes>;
};

/** on_conflict condition type for table "db_event_log_types" */
export type DbEventLogTypesOnConflict = {
  constraint: DbEventLogTypesConstraint;
  updateColumns?: Array<DbEventLogTypesUpdateColumn>;
  where?: InputMaybe<DbEventLogTypesBoolExp>;
};

/** Ordering options when selecting data from "db_event_log_types". */
export type DbEventLogTypesOrderBy = {
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: db_event_log_types */
export type DbEventLogTypesPkColumnsInput = {
  value: Scalars['String']['input'];
};

/** select columns of table "db_event_log_types" */
export enum DbEventLogTypesSelectColumn {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "db_event_log_types" */
export type DbEventLogTypesSetInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "db_event_log_types" */
export type DbEventLogTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: DbEventLogTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type DbEventLogTypesStreamCursorValueInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "db_event_log_types" */
export enum DbEventLogTypesUpdateColumn {
  /** column name */
  Value = 'value'
}

export type DbEventLogTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DbEventLogTypesSetInput>;
  /** filter the rows which have to be updated */
  where: DbEventLogTypesBoolExp;
};

/** Log of DB related event (insert, update, delete) */
export type DbEventLogs = {
  __typename?: 'DbEventLogs';
  /** ID of the account where the update occurred. */
  accountId: Scalars['uuid']['output'];
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** [enum] one of insert, update, delete */
  eventType: DbEventLogTypesEnum;
  id: Scalars['uuid']['output'];
  payload: Scalars['jsonb']['output'];
  /** Original ID of the object on which the event occurred. */
  targetId: Scalars['uuid']['output'];
  /** Table on which the event occurred */
  targetTable: Scalars['String']['output'];
};


/** Log of DB related event (insert, update, delete) */
export type DbEventLogsPayloadArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "db_event_logs" */
export type DbEventLogsAggregate = {
  __typename?: 'DbEventLogsAggregate';
  aggregate?: Maybe<DbEventLogsAggregateFields>;
  nodes: Array<DbEventLogs>;
};

/** aggregate fields of "db_event_logs" */
export type DbEventLogsAggregateFields = {
  __typename?: 'DbEventLogsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<DbEventLogsMaxFields>;
  min?: Maybe<DbEventLogsMinFields>;
};


/** aggregate fields of "db_event_logs" */
export type DbEventLogsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<DbEventLogsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type DbEventLogsAppendInput = {
  payload?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "db_event_logs". All fields are combined with a logical 'AND'. */
export type DbEventLogsBoolExp = {
  _and?: InputMaybe<Array<DbEventLogsBoolExp>>;
  _not?: InputMaybe<DbEventLogsBoolExp>;
  _or?: InputMaybe<Array<DbEventLogsBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  eventType?: InputMaybe<DbEventLogTypesEnumComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  payload?: InputMaybe<JsonbComparisonExp>;
  targetId?: InputMaybe<UuidComparisonExp>;
  targetTable?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "db_event_logs" */
export enum DbEventLogsConstraint {
  /** unique or primary key constraint on columns "id" */
  DbEventLogsPkey = 'db_event_logs_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type DbEventLogsDeleteAtPathInput = {
  payload?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type DbEventLogsDeleteElemInput = {
  payload?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type DbEventLogsDeleteKeyInput = {
  payload?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "db_event_logs" */
export type DbEventLogsInsertInput = {
  /** ID of the account where the update occurred. */
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [enum] one of insert, update, delete */
  eventType?: InputMaybe<DbEventLogTypesEnum>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  payload?: InputMaybe<Scalars['jsonb']['input']>;
  /** Original ID of the object on which the event occurred. */
  targetId?: InputMaybe<Scalars['uuid']['input']>;
  /** Table on which the event occurred */
  targetTable?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type DbEventLogsMaxFields = {
  __typename?: 'DbEventLogsMaxFields';
  /** ID of the account where the update occurred. */
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** Original ID of the object on which the event occurred. */
  targetId?: Maybe<Scalars['uuid']['output']>;
  /** Table on which the event occurred */
  targetTable?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type DbEventLogsMinFields = {
  __typename?: 'DbEventLogsMinFields';
  /** ID of the account where the update occurred. */
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** Original ID of the object on which the event occurred. */
  targetId?: Maybe<Scalars['uuid']['output']>;
  /** Table on which the event occurred */
  targetTable?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "db_event_logs" */
export type DbEventLogsMutationResponse = {
  __typename?: 'DbEventLogsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<DbEventLogs>;
};

/** on_conflict condition type for table "db_event_logs" */
export type DbEventLogsOnConflict = {
  constraint: DbEventLogsConstraint;
  updateColumns?: Array<DbEventLogsUpdateColumn>;
  where?: InputMaybe<DbEventLogsBoolExp>;
};

/** Ordering options when selecting data from "db_event_logs". */
export type DbEventLogsOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  eventType?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  payload?: InputMaybe<OrderBy>;
  targetId?: InputMaybe<OrderBy>;
  targetTable?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: db_event_logs */
export type DbEventLogsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type DbEventLogsPrependInput = {
  payload?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "db_event_logs" */
export enum DbEventLogsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventType = 'eventType',
  /** column name */
  Id = 'id',
  /** column name */
  Payload = 'payload',
  /** column name */
  TargetId = 'targetId',
  /** column name */
  TargetTable = 'targetTable'
}

/** input type for updating data in table "db_event_logs" */
export type DbEventLogsSetInput = {
  /** ID of the account where the update occurred. */
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [enum] one of insert, update, delete */
  eventType?: InputMaybe<DbEventLogTypesEnum>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  payload?: InputMaybe<Scalars['jsonb']['input']>;
  /** Original ID of the object on which the event occurred. */
  targetId?: InputMaybe<Scalars['uuid']['input']>;
  /** Table on which the event occurred */
  targetTable?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "db_event_logs" */
export type DbEventLogsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: DbEventLogsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type DbEventLogsStreamCursorValueInput = {
  /** ID of the account where the update occurred. */
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [enum] one of insert, update, delete */
  eventType?: InputMaybe<DbEventLogTypesEnum>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  payload?: InputMaybe<Scalars['jsonb']['input']>;
  /** Original ID of the object on which the event occurred. */
  targetId?: InputMaybe<Scalars['uuid']['input']>;
  /** Table on which the event occurred */
  targetTable?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "db_event_logs" */
export enum DbEventLogsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventType = 'eventType',
  /** column name */
  Id = 'id',
  /** column name */
  Payload = 'payload',
  /** column name */
  TargetId = 'targetId',
  /** column name */
  TargetTable = 'targetTable'
}

export type DbEventLogsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<DbEventLogsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<DbEventLogsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<DbEventLogsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<DbEventLogsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<DbEventLogsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DbEventLogsSetInput>;
  /** filter the rows which have to be updated */
  where: DbEventLogsBoolExp;
};

export type Discount = {
  __typename?: 'Discount';
  flatAmount: Scalars['Int']['output'];
  numMonths: Scalars['Int']['output'];
  percentage: Scalars['Int']['output'];
};

/** A join table that stores whether a given document (i.e. task) has a given label. */
export type DocumentLabels = {
  __typename?: 'DocumentLabels';
  /** An object relationship */
  account: Accounts;
  accountId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamp']['output'];
  /** An object relationship */
  document: Documents;
  /** The task that the lable is on */
  documentId: Scalars['uuid']['output'];
  id: Scalars['uuid']['output'];
  /** An object relationship */
  label: Labels;
  /** The label this relates to */
  labelId: Scalars['uuid']['output'];
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['timestamp']['output'];
};

/** aggregated selection of "document_labels" */
export type DocumentLabelsAggregate = {
  __typename?: 'DocumentLabelsAggregate';
  aggregate?: Maybe<DocumentLabelsAggregateFields>;
  nodes: Array<DocumentLabels>;
};

export type DocumentLabelsAggregateBoolExp = {
  count?: InputMaybe<DocumentLabelsAggregateBoolExpCount>;
};

/** aggregate fields of "document_labels" */
export type DocumentLabelsAggregateFields = {
  __typename?: 'DocumentLabelsAggregateFields';
  avg?: Maybe<DocumentLabelsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<DocumentLabelsMaxFields>;
  min?: Maybe<DocumentLabelsMinFields>;
  stddev?: Maybe<DocumentLabelsStddevFields>;
  stddevPop?: Maybe<DocumentLabelsStddevPopFields>;
  stddevSamp?: Maybe<DocumentLabelsStddevSampFields>;
  sum?: Maybe<DocumentLabelsSumFields>;
  varPop?: Maybe<DocumentLabelsVarPopFields>;
  varSamp?: Maybe<DocumentLabelsVarSampFields>;
  variance?: Maybe<DocumentLabelsVarianceFields>;
};


/** aggregate fields of "document_labels" */
export type DocumentLabelsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<DocumentLabelsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "document_labels" */
export type DocumentLabelsAggregateOrderBy = {
  avg?: InputMaybe<DocumentLabelsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<DocumentLabelsMaxOrderBy>;
  min?: InputMaybe<DocumentLabelsMinOrderBy>;
  stddev?: InputMaybe<DocumentLabelsStddevOrderBy>;
  stddevPop?: InputMaybe<DocumentLabelsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<DocumentLabelsStddevSampOrderBy>;
  sum?: InputMaybe<DocumentLabelsSumOrderBy>;
  varPop?: InputMaybe<DocumentLabelsVarPopOrderBy>;
  varSamp?: InputMaybe<DocumentLabelsVarSampOrderBy>;
  variance?: InputMaybe<DocumentLabelsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "document_labels" */
export type DocumentLabelsArrRelInsertInput = {
  data: Array<DocumentLabelsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<DocumentLabelsOnConflict>;
};

/** aggregate avg on columns */
export type DocumentLabelsAvgFields = {
  __typename?: 'DocumentLabelsAvgFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "document_labels" */
export type DocumentLabelsAvgOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "document_labels". All fields are combined with a logical 'AND'. */
export type DocumentLabelsBoolExp = {
  _and?: InputMaybe<Array<DocumentLabelsBoolExp>>;
  _not?: InputMaybe<DocumentLabelsBoolExp>;
  _or?: InputMaybe<Array<DocumentLabelsBoolExp>>;
  account?: InputMaybe<AccountsBoolExp>;
  accountId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  document?: InputMaybe<DocumentsBoolExp>;
  documentId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  label?: InputMaybe<LabelsBoolExp>;
  labelId?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
};

/** unique or primary key constraints on table "document_labels" */
export enum DocumentLabelsConstraint {
  /** unique or primary key constraint on columns "id" */
  DocumentLabelsPkey = 'document_labels_pkey'
}

/** input type for incrementing numeric columns in table "document_labels" */
export type DocumentLabelsIncInput = {
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "document_labels" */
export type DocumentLabelsInsertInput = {
  account?: InputMaybe<AccountsObjRelInsertInput>;
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  document?: InputMaybe<DocumentsObjRelInsertInput>;
  /** The task that the lable is on */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  label?: InputMaybe<LabelsObjRelInsertInput>;
  /** The label this relates to */
  labelId?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate max on columns */
export type DocumentLabelsMaxFields = {
  __typename?: 'DocumentLabelsMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** The task that the lable is on */
  documentId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** The label this relates to */
  labelId?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by max() on columns of table "document_labels" */
export type DocumentLabelsMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** The task that the lable is on */
  documentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** The label this relates to */
  labelId?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type DocumentLabelsMinFields = {
  __typename?: 'DocumentLabelsMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** The task that the lable is on */
  documentId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** The label this relates to */
  labelId?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by min() on columns of table "document_labels" */
export type DocumentLabelsMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** The task that the lable is on */
  documentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** The label this relates to */
  labelId?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "document_labels" */
export type DocumentLabelsMutationResponse = {
  __typename?: 'DocumentLabelsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<DocumentLabels>;
};

/** on_conflict condition type for table "document_labels" */
export type DocumentLabelsOnConflict = {
  constraint: DocumentLabelsConstraint;
  updateColumns?: Array<DocumentLabelsUpdateColumn>;
  where?: InputMaybe<DocumentLabelsBoolExp>;
};

/** Ordering options when selecting data from "document_labels". */
export type DocumentLabelsOrderBy = {
  account?: InputMaybe<AccountsOrderBy>;
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  document?: InputMaybe<DocumentsOrderBy>;
  documentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  label?: InputMaybe<LabelsOrderBy>;
  labelId?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: document_labels */
export type DocumentLabelsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "document_labels" */
export enum DocumentLabelsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DocumentId = 'documentId',
  /** column name */
  Id = 'id',
  /** column name */
  LabelId = 'labelId',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "document_labels" */
export type DocumentLabelsSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The task that the lable is on */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** The label this relates to */
  labelId?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate stddev on columns */
export type DocumentLabelsStddevFields = {
  __typename?: 'DocumentLabelsStddevFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "document_labels" */
export type DocumentLabelsStddevOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type DocumentLabelsStddevPopFields = {
  __typename?: 'DocumentLabelsStddevPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "document_labels" */
export type DocumentLabelsStddevPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type DocumentLabelsStddevSampFields = {
  __typename?: 'DocumentLabelsStddevSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "document_labels" */
export type DocumentLabelsStddevSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "document_labels" */
export type DocumentLabelsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: DocumentLabelsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type DocumentLabelsStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The task that the lable is on */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** The label this relates to */
  labelId?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate sum on columns */
export type DocumentLabelsSumFields = {
  __typename?: 'DocumentLabelsSumFields';
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "document_labels" */
export type DocumentLabelsSumOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** update columns of table "document_labels" */
export enum DocumentLabelsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DocumentId = 'documentId',
  /** column name */
  Id = 'id',
  /** column name */
  LabelId = 'labelId',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type DocumentLabelsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<DocumentLabelsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DocumentLabelsSetInput>;
  /** filter the rows which have to be updated */
  where: DocumentLabelsBoolExp;
};

/** aggregate varPop on columns */
export type DocumentLabelsVarPopFields = {
  __typename?: 'DocumentLabelsVarPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "document_labels" */
export type DocumentLabelsVarPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type DocumentLabelsVarSampFields = {
  __typename?: 'DocumentLabelsVarSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "document_labels" */
export type DocumentLabelsVarSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type DocumentLabelsVarianceFields = {
  __typename?: 'DocumentLabelsVarianceFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "document_labels" */
export type DocumentLabelsVarianceOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** A join table that defines the relationship between a given user and a given document (task). Stores permissions, and metadata about last interractions */
export type DocumentUsers = {
  __typename?: 'DocumentUsers';
  accountId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  document: Documents;
  documentId: Scalars['uuid']['output'];
  /** [permissions] - defines if user is a not full creative, so cannot add versions, delete, etc */
  guest: Scalars['Boolean']['output'];
  id: Scalars['uuid']['output'];
  /** [permissions] - defines if user is only able to view the asset without commenting */
  isViewOnly?: Maybe<Scalars['Boolean']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Tracks time that the user last went to the Comments tab, so that we can display an indicator (a line that says New) in the chat about which messages are below the line and thus new */
  lastReadDiscussionAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Tracks when user viewed the document so that we can show to the user whether there are any more recent notifications to be viewed. */
  lastViewed?: Maybe<Scalars['timestamptz']['output']>;
  /** [notifications] - if the user has interracted with the document in any way, they become an observer, meaning they are notified for any subsequent changes and interractions on that document */
  observer: Scalars['Boolean']['output'];
  updatedAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid']['output'];
};

/** aggregated selection of "document_users" */
export type DocumentUsersAggregate = {
  __typename?: 'DocumentUsersAggregate';
  aggregate?: Maybe<DocumentUsersAggregateFields>;
  nodes: Array<DocumentUsers>;
};

export type DocumentUsersAggregateBoolExp = {
  bool_and?: InputMaybe<DocumentUsersAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<DocumentUsersAggregateBoolExpBool_Or>;
  count?: InputMaybe<DocumentUsersAggregateBoolExpCount>;
};

/** aggregate fields of "document_users" */
export type DocumentUsersAggregateFields = {
  __typename?: 'DocumentUsersAggregateFields';
  avg?: Maybe<DocumentUsersAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<DocumentUsersMaxFields>;
  min?: Maybe<DocumentUsersMinFields>;
  stddev?: Maybe<DocumentUsersStddevFields>;
  stddevPop?: Maybe<DocumentUsersStddevPopFields>;
  stddevSamp?: Maybe<DocumentUsersStddevSampFields>;
  sum?: Maybe<DocumentUsersSumFields>;
  varPop?: Maybe<DocumentUsersVarPopFields>;
  varSamp?: Maybe<DocumentUsersVarSampFields>;
  variance?: Maybe<DocumentUsersVarianceFields>;
};


/** aggregate fields of "document_users" */
export type DocumentUsersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<DocumentUsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "document_users" */
export type DocumentUsersAggregateOrderBy = {
  avg?: InputMaybe<DocumentUsersAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<DocumentUsersMaxOrderBy>;
  min?: InputMaybe<DocumentUsersMinOrderBy>;
  stddev?: InputMaybe<DocumentUsersStddevOrderBy>;
  stddevPop?: InputMaybe<DocumentUsersStddevPopOrderBy>;
  stddevSamp?: InputMaybe<DocumentUsersStddevSampOrderBy>;
  sum?: InputMaybe<DocumentUsersSumOrderBy>;
  varPop?: InputMaybe<DocumentUsersVarPopOrderBy>;
  varSamp?: InputMaybe<DocumentUsersVarSampOrderBy>;
  variance?: InputMaybe<DocumentUsersVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "document_users" */
export type DocumentUsersArrRelInsertInput = {
  data: Array<DocumentUsersInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<DocumentUsersOnConflict>;
};

/** aggregate avg on columns */
export type DocumentUsersAvgFields = {
  __typename?: 'DocumentUsersAvgFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "document_users" */
export type DocumentUsersAvgOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "document_users". All fields are combined with a logical 'AND'. */
export type DocumentUsersBoolExp = {
  _and?: InputMaybe<Array<DocumentUsersBoolExp>>;
  _not?: InputMaybe<DocumentUsersBoolExp>;
  _or?: InputMaybe<Array<DocumentUsersBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  document?: InputMaybe<DocumentsBoolExp>;
  documentId?: InputMaybe<UuidComparisonExp>;
  guest?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isViewOnly?: InputMaybe<BooleanComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  lastReadDiscussionAt?: InputMaybe<TimestamptzComparisonExp>;
  lastViewed?: InputMaybe<TimestamptzComparisonExp>;
  observer?: InputMaybe<BooleanComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "document_users" */
export enum DocumentUsersConstraint {
  /** unique or primary key constraint on columns "id" */
  DocumentUsersPkey = 'document_users_pkey',
  /** unique or primary key constraint on columns "user_id", "document_id" */
  DocumentUsersUserIdDocumentIdKey = 'document_users_user_id_document_id_key',
  /** unique or primary key constraint on columns "user_id", "document_id" */
  IndexDocumentUsersOnUserIdAndDocumentId = 'index_document_users_on_user_id_and_document_id'
}

/** input type for incrementing numeric columns in table "document_users" */
export type DocumentUsersIncInput = {
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "document_users" */
export type DocumentUsersInsertInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  document?: InputMaybe<DocumentsObjRelInsertInput>;
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** [permissions] - defines if user is a not full creative, so cannot add versions, delete, etc */
  guest?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [permissions] - defines if user is only able to view the asset without commenting */
  isViewOnly?: InputMaybe<Scalars['Boolean']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Tracks time that the user last went to the Comments tab, so that we can display an indicator (a line that says New) in the chat about which messages are below the line and thus new */
  lastReadDiscussionAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Tracks when user viewed the document so that we can show to the user whether there are any more recent notifications to be viewed. */
  lastViewed?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [notifications] - if the user has interracted with the document in any way, they become an observer, meaning they are notified for any subsequent changes and interractions on that document */
  observer?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type DocumentUsersMaxFields = {
  __typename?: 'DocumentUsersMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  documentId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Tracks time that the user last went to the Comments tab, so that we can display an indicator (a line that says New) in the chat about which messages are below the line and thus new */
  lastReadDiscussionAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Tracks when user viewed the document so that we can show to the user whether there are any more recent notifications to be viewed. */
  lastViewed?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "document_users" */
export type DocumentUsersMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  documentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Tracks time that the user last went to the Comments tab, so that we can display an indicator (a line that says New) in the chat about which messages are below the line and thus new */
  lastReadDiscussionAt?: InputMaybe<OrderBy>;
  /** Tracks when user viewed the document so that we can show to the user whether there are any more recent notifications to be viewed. */
  lastViewed?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type DocumentUsersMinFields = {
  __typename?: 'DocumentUsersMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  documentId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Tracks time that the user last went to the Comments tab, so that we can display an indicator (a line that says New) in the chat about which messages are below the line and thus new */
  lastReadDiscussionAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Tracks when user viewed the document so that we can show to the user whether there are any more recent notifications to be viewed. */
  lastViewed?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "document_users" */
export type DocumentUsersMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  documentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Tracks time that the user last went to the Comments tab, so that we can display an indicator (a line that says New) in the chat about which messages are below the line and thus new */
  lastReadDiscussionAt?: InputMaybe<OrderBy>;
  /** Tracks when user viewed the document so that we can show to the user whether there are any more recent notifications to be viewed. */
  lastViewed?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "document_users" */
export type DocumentUsersMutationResponse = {
  __typename?: 'DocumentUsersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<DocumentUsers>;
};

/** on_conflict condition type for table "document_users" */
export type DocumentUsersOnConflict = {
  constraint: DocumentUsersConstraint;
  updateColumns?: Array<DocumentUsersUpdateColumn>;
  where?: InputMaybe<DocumentUsersBoolExp>;
};

/** Ordering options when selecting data from "document_users". */
export type DocumentUsersOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  document?: InputMaybe<DocumentsOrderBy>;
  documentId?: InputMaybe<OrderBy>;
  guest?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isViewOnly?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  lastReadDiscussionAt?: InputMaybe<OrderBy>;
  lastViewed?: InputMaybe<OrderBy>;
  observer?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: document_users */
export type DocumentUsersPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "document_users" */
export enum DocumentUsersSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DocumentId = 'documentId',
  /** column name */
  Guest = 'guest',
  /** column name */
  Id = 'id',
  /** column name */
  IsViewOnly = 'isViewOnly',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LastReadDiscussionAt = 'lastReadDiscussionAt',
  /** column name */
  LastViewed = 'lastViewed',
  /** column name */
  Observer = 'observer',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** select "documentUsersAggregateBoolExpBool_andArgumentsColumns" columns of table "document_users" */
export enum DocumentUsersSelectColumnDocumentUsersAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  Guest = 'guest',
  /** column name */
  IsViewOnly = 'isViewOnly',
  /** column name */
  Observer = 'observer'
}

/** select "documentUsersAggregateBoolExpBool_orArgumentsColumns" columns of table "document_users" */
export enum DocumentUsersSelectColumnDocumentUsersAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  Guest = 'guest',
  /** column name */
  IsViewOnly = 'isViewOnly',
  /** column name */
  Observer = 'observer'
}

/** input type for updating data in table "document_users" */
export type DocumentUsersSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** [permissions] - defines if user is a not full creative, so cannot add versions, delete, etc */
  guest?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [permissions] - defines if user is only able to view the asset without commenting */
  isViewOnly?: InputMaybe<Scalars['Boolean']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Tracks time that the user last went to the Comments tab, so that we can display an indicator (a line that says New) in the chat about which messages are below the line and thus new */
  lastReadDiscussionAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Tracks when user viewed the document so that we can show to the user whether there are any more recent notifications to be viewed. */
  lastViewed?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [notifications] - if the user has interracted with the document in any way, they become an observer, meaning they are notified for any subsequent changes and interractions on that document */
  observer?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type DocumentUsersStddevFields = {
  __typename?: 'DocumentUsersStddevFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "document_users" */
export type DocumentUsersStddevOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type DocumentUsersStddevPopFields = {
  __typename?: 'DocumentUsersStddevPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "document_users" */
export type DocumentUsersStddevPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type DocumentUsersStddevSampFields = {
  __typename?: 'DocumentUsersStddevSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "document_users" */
export type DocumentUsersStddevSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "document_users" */
export type DocumentUsersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: DocumentUsersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type DocumentUsersStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** [permissions] - defines if user is a not full creative, so cannot add versions, delete, etc */
  guest?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [permissions] - defines if user is only able to view the asset without commenting */
  isViewOnly?: InputMaybe<Scalars['Boolean']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Tracks time that the user last went to the Comments tab, so that we can display an indicator (a line that says New) in the chat about which messages are below the line and thus new */
  lastReadDiscussionAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Tracks when user viewed the document so that we can show to the user whether there are any more recent notifications to be viewed. */
  lastViewed?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [notifications] - if the user has interracted with the document in any way, they become an observer, meaning they are notified for any subsequent changes and interractions on that document */
  observer?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type DocumentUsersSumFields = {
  __typename?: 'DocumentUsersSumFields';
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "document_users" */
export type DocumentUsersSumOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** update columns of table "document_users" */
export enum DocumentUsersUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DocumentId = 'documentId',
  /** column name */
  Guest = 'guest',
  /** column name */
  Id = 'id',
  /** column name */
  IsViewOnly = 'isViewOnly',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LastReadDiscussionAt = 'lastReadDiscussionAt',
  /** column name */
  LastViewed = 'lastViewed',
  /** column name */
  Observer = 'observer',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type DocumentUsersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<DocumentUsersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DocumentUsersSetInput>;
  /** filter the rows which have to be updated */
  where: DocumentUsersBoolExp;
};

/** aggregate varPop on columns */
export type DocumentUsersVarPopFields = {
  __typename?: 'DocumentUsersVarPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "document_users" */
export type DocumentUsersVarPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type DocumentUsersVarSampFields = {
  __typename?: 'DocumentUsersVarSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "document_users" */
export type DocumentUsersVarSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type DocumentUsersVarianceFields = {
  __typename?: 'DocumentUsersVarianceFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "document_users" */
export type DocumentUsersVarianceOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** A document is a task. If it does not have any "versions", then the task is simply a project-manager style task with a name, briefing, etc. If the document has one or more versions, the document shows as a full creative asset */
export type Documents = {
  __typename?: 'Documents';
  /** An object relationship */
  account: Accounts;
  accountId: Scalars['uuid']['output'];
  /** [approval][enum] - the current approval status */
  approvalStatus: Scalars['Int']['output'];
  /** [approval] - can users mark the document as approved? */
  approvalsEnabled: Scalars['Boolean']['output'];
  /** [Archive] - has the user moved to archive? */
  archived: Scalars['Boolean']['output'];
  /** An object relationship */
  assignee?: Maybe<Users>;
  /** User that is asigned */
  assigneeId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  assigner?: Maybe<Users>;
  /** [notifications] - User who assigned the assignee */
  assignerId?: Maybe<Scalars['uuid']['output']>;
  /** whether comments have been disabled or not for this document */
  commentsEnabled: Scalars['Boolean']['output'];
  createdAt: Scalars['timestamptz']['output'];
  /** Remove, not used - was previously how the description was stored, prior to moving to task_description */
  description?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  documentLabels: Array<DocumentLabels>;
  /** An aggregate relationship */
  documentLabelsAggregate: DocumentLabelsAggregate;
  /** An array relationship */
  documentUsers: Array<DocumentUsers>;
  /** An aggregate relationship */
  documentUsersAggregate: DocumentUsersAggregate;
  /** Due date */
  dueAt?: Maybe<Scalars['date']['output']>;
  /** remove */
  externalLink?: Maybe<Scalars['String']['output']>;
  /** Remove, not used - used to allow automatic detection of changes in Figma and syncing */
  figmaHash?: Maybe<Scalars['String']['output']>;
  /** [Figma plugin] */
  figmaId?: Maybe<Scalars['String']['output']>;
  /** Remove, not used */
  figmaKeep?: Maybe<Scalars['Boolean']['output']>;
  /** Remove, not used */
  figmaName?: Maybe<Scalars['String']['output']>;
  /** Remove, not used */
  figmaPageUuid?: Maybe<Scalars['String']['output']>;
  /** Remove, not used used to allow automatic detection of changes in Figma and syncing */
  figmaQuickHash?: Maybe<Scalars['String']['output']>;
  /** [Figma] remove */
  figmaSortedIds?: Maybe<Scalars['String']['output']>;
  /** Ordering position of the task in the column on the kanban board. */
  fractionalPosition: Scalars['String']['output'];
  /** [Sharing] - remove - previously defined if the document is accessible, now replaced by has_public_access */
  globalAccess: Scalars['Boolean']['output'];
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessToken?: Maybe<Scalars['String']['output']>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessTokenExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  /** [timeline] - group that the document is in on the Gantt board */
  groupId?: Maybe<Scalars['uuid']['output']>;
  /** [timeline] - position within the group */
  groupPosition?: Maybe<Scalars['Int']['output']>;
  /** [sharing] - is the document accessible by anyone on the internet? */
  hasPublicAccess?: Maybe<Scalars['Boolean']['output']>;
  /** [sharing] - can guest viewers edit, which is to say add or remove versions */
  hasPublicAccessEditing?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['uuid']['output'];
  /** [Analytics] - mark as demo to remove from analytics */
  isDemo: Scalars['Boolean']['output'];
  /** An object relationship */
  lane: Lanes;
  /** Which Kanban stage the task belongs to */
  laneId: Scalars['uuid']['output'];
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  messages: Array<Messages>;
  /** An aggregate relationship */
  messagesAggregate: MessagesAggregate;
  /** An object relationship */
  myDocumentUser?: Maybe<MyDocumentUsers>;
  /** title of the task */
  name: Scalars['String']['output'];
  /** updated_at that tracks nested relationships from documents */
  nested_updated_at?: Maybe<Scalars['String']['output']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position: Scalars['Int']['output'];
  /** [enum] Priority for the task */
  priority?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  project?: Maybe<Projects>;
  /** Project that the task belongs to */
  projectId?: Maybe<Scalars['uuid']['output']>;
  /** Remove, previously allowed email reminders for reviews to be sent */
  reminderSentAt?: Maybe<Scalars['timestamptz']['output']>;
  /** used for the URL, and often used to lookup the docuement from the URL */
  slug: Scalars['String']['output'];
  /** [timeline] - date that task began */
  startAt?: Maybe<Scalars['date']['output']>;
  /** Rename - This stores the date when the document lane is changed. This is used by the "done" column, as the done column groups tasks by the date they were moved to done (e.g. yesterday, last week). Should be renamed to lane_updated_at to match consistent database naming of "lane". */
  statusUpdatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** [notifications] - who updated the status */
  statusUpdatedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  statusUpdater?: Maybe<Users>;
  /** [storage] - which folder, if any, is the document in? */
  storageFolderId?: Maybe<Scalars['uuid']['output']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition: Scalars['Int']['output'];
  /** [storage] - is this document in the Storage app? */
  stored: Scalars['Boolean']['output'];
  /** the task briefing, using the tiptap DSL */
  taskDescription?: Maybe<Scalars['jsonb']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  user?: Maybe<Users>;
  /** Creator of the task */
  userId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  versions: Array<Versions>;
  /** An aggregate relationship */
  versionsAggregate: VersionsAggregate;
};


/** A document is a task. If it does not have any "versions", then the task is simply a project-manager style task with a name, briefing, etc. If the document has one or more versions, the document shows as a full creative asset */
export type DocumentsDocumentLabelsArgs = {
  distinctOn?: InputMaybe<Array<DocumentLabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentLabelsOrderBy>>;
  where?: InputMaybe<DocumentLabelsBoolExp>;
};


/** A document is a task. If it does not have any "versions", then the task is simply a project-manager style task with a name, briefing, etc. If the document has one or more versions, the document shows as a full creative asset */
export type DocumentsDocumentLabelsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentLabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentLabelsOrderBy>>;
  where?: InputMaybe<DocumentLabelsBoolExp>;
};


/** A document is a task. If it does not have any "versions", then the task is simply a project-manager style task with a name, briefing, etc. If the document has one or more versions, the document shows as a full creative asset */
export type DocumentsDocumentUsersArgs = {
  distinctOn?: InputMaybe<Array<DocumentUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentUsersOrderBy>>;
  where?: InputMaybe<DocumentUsersBoolExp>;
};


/** A document is a task. If it does not have any "versions", then the task is simply a project-manager style task with a name, briefing, etc. If the document has one or more versions, the document shows as a full creative asset */
export type DocumentsDocumentUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentUsersOrderBy>>;
  where?: InputMaybe<DocumentUsersBoolExp>;
};


/** A document is a task. If it does not have any "versions", then the task is simply a project-manager style task with a name, briefing, etc. If the document has one or more versions, the document shows as a full creative asset */
export type DocumentsMessagesArgs = {
  distinctOn?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


/** A document is a task. If it does not have any "versions", then the task is simply a project-manager style task with a name, briefing, etc. If the document has one or more versions, the document shows as a full creative asset */
export type DocumentsMessagesAggregateArgs = {
  distinctOn?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


/** A document is a task. If it does not have any "versions", then the task is simply a project-manager style task with a name, briefing, etc. If the document has one or more versions, the document shows as a full creative asset */
export type DocumentsTaskDescriptionArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** A document is a task. If it does not have any "versions", then the task is simply a project-manager style task with a name, briefing, etc. If the document has one or more versions, the document shows as a full creative asset */
export type DocumentsVersionsArgs = {
  distinctOn?: InputMaybe<Array<VersionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VersionsOrderBy>>;
  where?: InputMaybe<VersionsBoolExp>;
};


/** A document is a task. If it does not have any "versions", then the task is simply a project-manager style task with a name, briefing, etc. If the document has one or more versions, the document shows as a full creative asset */
export type DocumentsVersionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<VersionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VersionsOrderBy>>;
  where?: InputMaybe<VersionsBoolExp>;
};

/** aggregated selection of "documents" */
export type DocumentsAggregate = {
  __typename?: 'DocumentsAggregate';
  aggregate?: Maybe<DocumentsAggregateFields>;
  nodes: Array<Documents>;
};

export type DocumentsAggregateBoolExp = {
  bool_and?: InputMaybe<DocumentsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<DocumentsAggregateBoolExpBool_Or>;
  count?: InputMaybe<DocumentsAggregateBoolExpCount>;
};

/** aggregate fields of "documents" */
export type DocumentsAggregateFields = {
  __typename?: 'DocumentsAggregateFields';
  avg?: Maybe<DocumentsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<DocumentsMaxFields>;
  min?: Maybe<DocumentsMinFields>;
  stddev?: Maybe<DocumentsStddevFields>;
  stddevPop?: Maybe<DocumentsStddevPopFields>;
  stddevSamp?: Maybe<DocumentsStddevSampFields>;
  sum?: Maybe<DocumentsSumFields>;
  varPop?: Maybe<DocumentsVarPopFields>;
  varSamp?: Maybe<DocumentsVarSampFields>;
  variance?: Maybe<DocumentsVarianceFields>;
};


/** aggregate fields of "documents" */
export type DocumentsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<DocumentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "documents" */
export type DocumentsAggregateOrderBy = {
  avg?: InputMaybe<DocumentsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<DocumentsMaxOrderBy>;
  min?: InputMaybe<DocumentsMinOrderBy>;
  stddev?: InputMaybe<DocumentsStddevOrderBy>;
  stddevPop?: InputMaybe<DocumentsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<DocumentsStddevSampOrderBy>;
  sum?: InputMaybe<DocumentsSumOrderBy>;
  varPop?: InputMaybe<DocumentsVarPopOrderBy>;
  varSamp?: InputMaybe<DocumentsVarSampOrderBy>;
  variance?: InputMaybe<DocumentsVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type DocumentsAppendInput = {
  /** the task briefing, using the tiptap DSL */
  taskDescription?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "documents" */
export type DocumentsArrRelInsertInput = {
  data: Array<DocumentsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<DocumentsOnConflict>;
};

/** aggregate avg on columns */
export type DocumentsAvgFields = {
  __typename?: 'DocumentsAvgFields';
  /** [approval][enum] - the current approval status */
  approvalStatus?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - position within the group */
  groupPosition?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: Maybe<Scalars['Float']['output']>;
  /** [enum] Priority for the task */
  priority?: Maybe<Scalars['Float']['output']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "documents" */
export type DocumentsAvgOrderBy = {
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<OrderBy>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<OrderBy>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<OrderBy>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "documents". All fields are combined with a logical 'AND'. */
export type DocumentsBoolExp = {
  _and?: InputMaybe<Array<DocumentsBoolExp>>;
  _not?: InputMaybe<DocumentsBoolExp>;
  _or?: InputMaybe<Array<DocumentsBoolExp>>;
  account?: InputMaybe<AccountsBoolExp>;
  accountId?: InputMaybe<UuidComparisonExp>;
  approvalStatus?: InputMaybe<IntComparisonExp>;
  approvalsEnabled?: InputMaybe<BooleanComparisonExp>;
  archived?: InputMaybe<BooleanComparisonExp>;
  assignee?: InputMaybe<UsersBoolExp>;
  assigneeId?: InputMaybe<UuidComparisonExp>;
  assigner?: InputMaybe<UsersBoolExp>;
  assignerId?: InputMaybe<UuidComparisonExp>;
  commentsEnabled?: InputMaybe<BooleanComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  documentLabels?: InputMaybe<DocumentLabelsBoolExp>;
  documentLabelsAggregate?: InputMaybe<DocumentLabelsAggregateBoolExp>;
  documentUsers?: InputMaybe<DocumentUsersBoolExp>;
  documentUsersAggregate?: InputMaybe<DocumentUsersAggregateBoolExp>;
  dueAt?: InputMaybe<DateComparisonExp>;
  externalLink?: InputMaybe<StringComparisonExp>;
  figmaHash?: InputMaybe<StringComparisonExp>;
  figmaId?: InputMaybe<StringComparisonExp>;
  figmaKeep?: InputMaybe<BooleanComparisonExp>;
  figmaName?: InputMaybe<StringComparisonExp>;
  figmaPageUuid?: InputMaybe<StringComparisonExp>;
  figmaQuickHash?: InputMaybe<StringComparisonExp>;
  figmaSortedIds?: InputMaybe<StringComparisonExp>;
  fractionalPosition?: InputMaybe<StringComparisonExp>;
  globalAccess?: InputMaybe<BooleanComparisonExp>;
  globalAccessToken?: InputMaybe<StringComparisonExp>;
  globalAccessTokenExpiresAt?: InputMaybe<TimestamptzComparisonExp>;
  groupId?: InputMaybe<UuidComparisonExp>;
  groupPosition?: InputMaybe<IntComparisonExp>;
  hasPublicAccess?: InputMaybe<BooleanComparisonExp>;
  hasPublicAccessEditing?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isDemo?: InputMaybe<BooleanComparisonExp>;
  lane?: InputMaybe<LanesBoolExp>;
  laneId?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  messages?: InputMaybe<MessagesBoolExp>;
  messagesAggregate?: InputMaybe<MessagesAggregateBoolExp>;
  myDocumentUser?: InputMaybe<MyDocumentUsersBoolExp>;
  name?: InputMaybe<StringComparisonExp>;
  nested_updated_at?: InputMaybe<StringComparisonExp>;
  position?: InputMaybe<IntComparisonExp>;
  priority?: InputMaybe<IntComparisonExp>;
  project?: InputMaybe<ProjectsBoolExp>;
  projectId?: InputMaybe<UuidComparisonExp>;
  reminderSentAt?: InputMaybe<TimestamptzComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  startAt?: InputMaybe<DateComparisonExp>;
  statusUpdatedAt?: InputMaybe<TimestamptzComparisonExp>;
  statusUpdatedBy?: InputMaybe<UuidComparisonExp>;
  statusUpdater?: InputMaybe<UsersBoolExp>;
  storageFolderId?: InputMaybe<UuidComparisonExp>;
  storagePosition?: InputMaybe<IntComparisonExp>;
  stored?: InputMaybe<BooleanComparisonExp>;
  taskDescription?: InputMaybe<JsonbComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  versions?: InputMaybe<VersionsBoolExp>;
  versionsAggregate?: InputMaybe<VersionsAggregateBoolExp>;
};

/** unique or primary key constraints on table "documents" */
export enum DocumentsConstraint {
  /** unique or primary key constraint on columns "id" */
  DocumentsPkey = 'documents_pkey',
  /** unique or primary key constraint on columns "slug" */
  IndexDocumentsOnSlug = 'index_documents_on_slug'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type DocumentsDeleteAtPathInput = {
  /** the task briefing, using the tiptap DSL */
  taskDescription?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type DocumentsDeleteElemInput = {
  /** the task briefing, using the tiptap DSL */
  taskDescription?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type DocumentsDeleteKeyInput = {
  /** the task briefing, using the tiptap DSL */
  taskDescription?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "documents" */
export type DocumentsIncInput = {
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<Scalars['Int']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<Scalars['Int']['input']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "documents" */
export type DocumentsInsertInput = {
  account?: InputMaybe<AccountsObjRelInsertInput>;
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [approval] - can users mark the document as approved? */
  approvalsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** [Archive] - has the user moved to archive? */
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  assignee?: InputMaybe<UsersObjRelInsertInput>;
  /** User that is asigned */
  assigneeId?: InputMaybe<Scalars['uuid']['input']>;
  assigner?: InputMaybe<UsersObjRelInsertInput>;
  /** [notifications] - User who assigned the assignee */
  assignerId?: InputMaybe<Scalars['uuid']['input']>;
  /** whether comments have been disabled or not for this document */
  commentsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Remove, not used - was previously how the description was stored, prior to moving to task_description */
  description?: InputMaybe<Scalars['String']['input']>;
  documentLabels?: InputMaybe<DocumentLabelsArrRelInsertInput>;
  documentUsers?: InputMaybe<DocumentUsersArrRelInsertInput>;
  /** Due date */
  dueAt?: InputMaybe<Scalars['date']['input']>;
  /** remove */
  externalLink?: InputMaybe<Scalars['String']['input']>;
  /** Remove, not used - used to allow automatic detection of changes in Figma and syncing */
  figmaHash?: InputMaybe<Scalars['String']['input']>;
  /** [Figma plugin] */
  figmaId?: InputMaybe<Scalars['String']['input']>;
  /** Remove, not used */
  figmaKeep?: InputMaybe<Scalars['Boolean']['input']>;
  /** Remove, not used */
  figmaName?: InputMaybe<Scalars['String']['input']>;
  /** Remove, not used */
  figmaPageUuid?: InputMaybe<Scalars['String']['input']>;
  /** Remove, not used used to allow automatic detection of changes in Figma and syncing */
  figmaQuickHash?: InputMaybe<Scalars['String']['input']>;
  /** [Figma] remove */
  figmaSortedIds?: InputMaybe<Scalars['String']['input']>;
  /** Ordering position of the task in the column on the kanban board. */
  fractionalPosition?: InputMaybe<Scalars['String']['input']>;
  /** [Sharing] - remove - previously defined if the document is accessible, now replaced by has_public_access */
  globalAccess?: InputMaybe<Scalars['Boolean']['input']>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessToken?: InputMaybe<Scalars['String']['input']>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessTokenExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [timeline] - group that the document is in on the Gantt board */
  groupId?: InputMaybe<Scalars['uuid']['input']>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<Scalars['Int']['input']>;
  /** [sharing] - is the document accessible by anyone on the internet? */
  hasPublicAccess?: InputMaybe<Scalars['Boolean']['input']>;
  /** [sharing] - can guest viewers edit, which is to say add or remove versions */
  hasPublicAccessEditing?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [Analytics] - mark as demo to remove from analytics */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  lane?: InputMaybe<LanesObjRelInsertInput>;
  /** Which Kanban stage the task belongs to */
  laneId?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  messages?: InputMaybe<MessagesArrRelInsertInput>;
  myDocumentUser?: InputMaybe<MyDocumentUsersObjRelInsertInput>;
  /** title of the task */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<Scalars['Int']['input']>;
  project?: InputMaybe<ProjectsObjRelInsertInput>;
  /** Project that the task belongs to */
  projectId?: InputMaybe<Scalars['uuid']['input']>;
  /** Remove, previously allowed email reminders for reviews to be sent */
  reminderSentAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** used for the URL, and often used to lookup the docuement from the URL */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** [timeline] - date that task began */
  startAt?: InputMaybe<Scalars['date']['input']>;
  /** Rename - This stores the date when the document lane is changed. This is used by the "done" column, as the done column groups tasks by the date they were moved to done (e.g. yesterday, last week). Should be renamed to lane_updated_at to match consistent database naming of "lane". */
  statusUpdatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [notifications] - who updated the status */
  statusUpdatedBy?: InputMaybe<Scalars['uuid']['input']>;
  statusUpdater?: InputMaybe<UsersObjRelInsertInput>;
  /** [storage] - which folder, if any, is the document in? */
  storageFolderId?: InputMaybe<Scalars['uuid']['input']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<Scalars['Int']['input']>;
  /** [storage] - is this document in the Storage app? */
  stored?: InputMaybe<Scalars['Boolean']['input']>;
  /** the task briefing, using the tiptap DSL */
  taskDescription?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  /** Creator of the task */
  userId?: InputMaybe<Scalars['uuid']['input']>;
  versions?: InputMaybe<VersionsArrRelInsertInput>;
};

/** aggregate max on columns */
export type DocumentsMaxFields = {
  __typename?: 'DocumentsMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** [approval][enum] - the current approval status */
  approvalStatus?: Maybe<Scalars['Int']['output']>;
  /** User that is asigned */
  assigneeId?: Maybe<Scalars['uuid']['output']>;
  /** [notifications] - User who assigned the assignee */
  assignerId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Remove, not used - was previously how the description was stored, prior to moving to task_description */
  description?: Maybe<Scalars['String']['output']>;
  /** Due date */
  dueAt?: Maybe<Scalars['date']['output']>;
  /** remove */
  externalLink?: Maybe<Scalars['String']['output']>;
  /** Remove, not used - used to allow automatic detection of changes in Figma and syncing */
  figmaHash?: Maybe<Scalars['String']['output']>;
  /** [Figma plugin] */
  figmaId?: Maybe<Scalars['String']['output']>;
  /** Remove, not used */
  figmaName?: Maybe<Scalars['String']['output']>;
  /** Remove, not used */
  figmaPageUuid?: Maybe<Scalars['String']['output']>;
  /** Remove, not used used to allow automatic detection of changes in Figma and syncing */
  figmaQuickHash?: Maybe<Scalars['String']['output']>;
  /** [Figma] remove */
  figmaSortedIds?: Maybe<Scalars['String']['output']>;
  /** Ordering position of the task in the column on the kanban board. */
  fractionalPosition?: Maybe<Scalars['String']['output']>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessToken?: Maybe<Scalars['String']['output']>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessTokenExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  /** [timeline] - group that the document is in on the Gantt board */
  groupId?: Maybe<Scalars['uuid']['output']>;
  /** [timeline] - position within the group */
  groupPosition?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** Which Kanban stage the task belongs to */
  laneId?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** title of the task */
  name?: Maybe<Scalars['String']['output']>;
  /** updated_at that tracks nested relationships from documents */
  nested_updated_at?: Maybe<Scalars['String']['output']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: Maybe<Scalars['Int']['output']>;
  /** [enum] Priority for the task */
  priority?: Maybe<Scalars['Int']['output']>;
  /** Project that the task belongs to */
  projectId?: Maybe<Scalars['uuid']['output']>;
  /** Remove, previously allowed email reminders for reviews to be sent */
  reminderSentAt?: Maybe<Scalars['timestamptz']['output']>;
  /** used for the URL, and often used to lookup the docuement from the URL */
  slug?: Maybe<Scalars['String']['output']>;
  /** [timeline] - date that task began */
  startAt?: Maybe<Scalars['date']['output']>;
  /** Rename - This stores the date when the document lane is changed. This is used by the "done" column, as the done column groups tasks by the date they were moved to done (e.g. yesterday, last week). Should be renamed to lane_updated_at to match consistent database naming of "lane". */
  statusUpdatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** [notifications] - who updated the status */
  statusUpdatedBy?: Maybe<Scalars['uuid']['output']>;
  /** [storage] - which folder, if any, is the document in? */
  storageFolderId?: Maybe<Scalars['uuid']['output']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Creator of the task */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "documents" */
export type DocumentsMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<OrderBy>;
  /** User that is asigned */
  assigneeId?: InputMaybe<OrderBy>;
  /** [notifications] - User who assigned the assignee */
  assignerId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** Remove, not used - was previously how the description was stored, prior to moving to task_description */
  description?: InputMaybe<OrderBy>;
  /** Due date */
  dueAt?: InputMaybe<OrderBy>;
  /** remove */
  externalLink?: InputMaybe<OrderBy>;
  /** Remove, not used - used to allow automatic detection of changes in Figma and syncing */
  figmaHash?: InputMaybe<OrderBy>;
  /** [Figma plugin] */
  figmaId?: InputMaybe<OrderBy>;
  /** Remove, not used */
  figmaName?: InputMaybe<OrderBy>;
  /** Remove, not used */
  figmaPageUuid?: InputMaybe<OrderBy>;
  /** Remove, not used used to allow automatic detection of changes in Figma and syncing */
  figmaQuickHash?: InputMaybe<OrderBy>;
  /** [Figma] remove */
  figmaSortedIds?: InputMaybe<OrderBy>;
  /** Ordering position of the task in the column on the kanban board. */
  fractionalPosition?: InputMaybe<OrderBy>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessToken?: InputMaybe<OrderBy>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessTokenExpiresAt?: InputMaybe<OrderBy>;
  /** [timeline] - group that the document is in on the Gantt board */
  groupId?: InputMaybe<OrderBy>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** Which Kanban stage the task belongs to */
  laneId?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** title of the task */
  name?: InputMaybe<OrderBy>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<OrderBy>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<OrderBy>;
  /** Project that the task belongs to */
  projectId?: InputMaybe<OrderBy>;
  /** Remove, previously allowed email reminders for reviews to be sent */
  reminderSentAt?: InputMaybe<OrderBy>;
  /** used for the URL, and often used to lookup the docuement from the URL */
  slug?: InputMaybe<OrderBy>;
  /** [timeline] - date that task began */
  startAt?: InputMaybe<OrderBy>;
  /** Rename - This stores the date when the document lane is changed. This is used by the "done" column, as the done column groups tasks by the date they were moved to done (e.g. yesterday, last week). Should be renamed to lane_updated_at to match consistent database naming of "lane". */
  statusUpdatedAt?: InputMaybe<OrderBy>;
  /** [notifications] - who updated the status */
  statusUpdatedBy?: InputMaybe<OrderBy>;
  /** [storage] - which folder, if any, is the document in? */
  storageFolderId?: InputMaybe<OrderBy>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** Creator of the task */
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type DocumentsMinFields = {
  __typename?: 'DocumentsMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** [approval][enum] - the current approval status */
  approvalStatus?: Maybe<Scalars['Int']['output']>;
  /** User that is asigned */
  assigneeId?: Maybe<Scalars['uuid']['output']>;
  /** [notifications] - User who assigned the assignee */
  assignerId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Remove, not used - was previously how the description was stored, prior to moving to task_description */
  description?: Maybe<Scalars['String']['output']>;
  /** Due date */
  dueAt?: Maybe<Scalars['date']['output']>;
  /** remove */
  externalLink?: Maybe<Scalars['String']['output']>;
  /** Remove, not used - used to allow automatic detection of changes in Figma and syncing */
  figmaHash?: Maybe<Scalars['String']['output']>;
  /** [Figma plugin] */
  figmaId?: Maybe<Scalars['String']['output']>;
  /** Remove, not used */
  figmaName?: Maybe<Scalars['String']['output']>;
  /** Remove, not used */
  figmaPageUuid?: Maybe<Scalars['String']['output']>;
  /** Remove, not used used to allow automatic detection of changes in Figma and syncing */
  figmaQuickHash?: Maybe<Scalars['String']['output']>;
  /** [Figma] remove */
  figmaSortedIds?: Maybe<Scalars['String']['output']>;
  /** Ordering position of the task in the column on the kanban board. */
  fractionalPosition?: Maybe<Scalars['String']['output']>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessToken?: Maybe<Scalars['String']['output']>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessTokenExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  /** [timeline] - group that the document is in on the Gantt board */
  groupId?: Maybe<Scalars['uuid']['output']>;
  /** [timeline] - position within the group */
  groupPosition?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** Which Kanban stage the task belongs to */
  laneId?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** title of the task */
  name?: Maybe<Scalars['String']['output']>;
  /** updated_at that tracks nested relationships from documents */
  nested_updated_at?: Maybe<Scalars['String']['output']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: Maybe<Scalars['Int']['output']>;
  /** [enum] Priority for the task */
  priority?: Maybe<Scalars['Int']['output']>;
  /** Project that the task belongs to */
  projectId?: Maybe<Scalars['uuid']['output']>;
  /** Remove, previously allowed email reminders for reviews to be sent */
  reminderSentAt?: Maybe<Scalars['timestamptz']['output']>;
  /** used for the URL, and often used to lookup the docuement from the URL */
  slug?: Maybe<Scalars['String']['output']>;
  /** [timeline] - date that task began */
  startAt?: Maybe<Scalars['date']['output']>;
  /** Rename - This stores the date when the document lane is changed. This is used by the "done" column, as the done column groups tasks by the date they were moved to done (e.g. yesterday, last week). Should be renamed to lane_updated_at to match consistent database naming of "lane". */
  statusUpdatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** [notifications] - who updated the status */
  statusUpdatedBy?: Maybe<Scalars['uuid']['output']>;
  /** [storage] - which folder, if any, is the document in? */
  storageFolderId?: Maybe<Scalars['uuid']['output']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Creator of the task */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "documents" */
export type DocumentsMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<OrderBy>;
  /** User that is asigned */
  assigneeId?: InputMaybe<OrderBy>;
  /** [notifications] - User who assigned the assignee */
  assignerId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** Remove, not used - was previously how the description was stored, prior to moving to task_description */
  description?: InputMaybe<OrderBy>;
  /** Due date */
  dueAt?: InputMaybe<OrderBy>;
  /** remove */
  externalLink?: InputMaybe<OrderBy>;
  /** Remove, not used - used to allow automatic detection of changes in Figma and syncing */
  figmaHash?: InputMaybe<OrderBy>;
  /** [Figma plugin] */
  figmaId?: InputMaybe<OrderBy>;
  /** Remove, not used */
  figmaName?: InputMaybe<OrderBy>;
  /** Remove, not used */
  figmaPageUuid?: InputMaybe<OrderBy>;
  /** Remove, not used used to allow automatic detection of changes in Figma and syncing */
  figmaQuickHash?: InputMaybe<OrderBy>;
  /** [Figma] remove */
  figmaSortedIds?: InputMaybe<OrderBy>;
  /** Ordering position of the task in the column on the kanban board. */
  fractionalPosition?: InputMaybe<OrderBy>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessToken?: InputMaybe<OrderBy>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessTokenExpiresAt?: InputMaybe<OrderBy>;
  /** [timeline] - group that the document is in on the Gantt board */
  groupId?: InputMaybe<OrderBy>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** Which Kanban stage the task belongs to */
  laneId?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** title of the task */
  name?: InputMaybe<OrderBy>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<OrderBy>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<OrderBy>;
  /** Project that the task belongs to */
  projectId?: InputMaybe<OrderBy>;
  /** Remove, previously allowed email reminders for reviews to be sent */
  reminderSentAt?: InputMaybe<OrderBy>;
  /** used for the URL, and often used to lookup the docuement from the URL */
  slug?: InputMaybe<OrderBy>;
  /** [timeline] - date that task began */
  startAt?: InputMaybe<OrderBy>;
  /** Rename - This stores the date when the document lane is changed. This is used by the "done" column, as the done column groups tasks by the date they were moved to done (e.g. yesterday, last week). Should be renamed to lane_updated_at to match consistent database naming of "lane". */
  statusUpdatedAt?: InputMaybe<OrderBy>;
  /** [notifications] - who updated the status */
  statusUpdatedBy?: InputMaybe<OrderBy>;
  /** [storage] - which folder, if any, is the document in? */
  storageFolderId?: InputMaybe<OrderBy>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** Creator of the task */
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "documents" */
export type DocumentsMutationResponse = {
  __typename?: 'DocumentsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Documents>;
};

/** input type for inserting object relation for remote table "documents" */
export type DocumentsObjRelInsertInput = {
  data: DocumentsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<DocumentsOnConflict>;
};

/** on_conflict condition type for table "documents" */
export type DocumentsOnConflict = {
  constraint: DocumentsConstraint;
  updateColumns?: Array<DocumentsUpdateColumn>;
  where?: InputMaybe<DocumentsBoolExp>;
};

/** Ordering options when selecting data from "documents". */
export type DocumentsOrderBy = {
  account?: InputMaybe<AccountsOrderBy>;
  accountId?: InputMaybe<OrderBy>;
  approvalStatus?: InputMaybe<OrderBy>;
  approvalsEnabled?: InputMaybe<OrderBy>;
  archived?: InputMaybe<OrderBy>;
  assignee?: InputMaybe<UsersOrderBy>;
  assigneeId?: InputMaybe<OrderBy>;
  assigner?: InputMaybe<UsersOrderBy>;
  assignerId?: InputMaybe<OrderBy>;
  commentsEnabled?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  documentLabelsAggregate?: InputMaybe<DocumentLabelsAggregateOrderBy>;
  documentUsersAggregate?: InputMaybe<DocumentUsersAggregateOrderBy>;
  dueAt?: InputMaybe<OrderBy>;
  externalLink?: InputMaybe<OrderBy>;
  figmaHash?: InputMaybe<OrderBy>;
  figmaId?: InputMaybe<OrderBy>;
  figmaKeep?: InputMaybe<OrderBy>;
  figmaName?: InputMaybe<OrderBy>;
  figmaPageUuid?: InputMaybe<OrderBy>;
  figmaQuickHash?: InputMaybe<OrderBy>;
  figmaSortedIds?: InputMaybe<OrderBy>;
  fractionalPosition?: InputMaybe<OrderBy>;
  globalAccess?: InputMaybe<OrderBy>;
  globalAccessToken?: InputMaybe<OrderBy>;
  globalAccessTokenExpiresAt?: InputMaybe<OrderBy>;
  groupId?: InputMaybe<OrderBy>;
  groupPosition?: InputMaybe<OrderBy>;
  hasPublicAccess?: InputMaybe<OrderBy>;
  hasPublicAccessEditing?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isDemo?: InputMaybe<OrderBy>;
  lane?: InputMaybe<LanesOrderBy>;
  laneId?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  messagesAggregate?: InputMaybe<MessagesAggregateOrderBy>;
  myDocumentUser?: InputMaybe<MyDocumentUsersOrderBy>;
  name?: InputMaybe<OrderBy>;
  nested_updated_at?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  priority?: InputMaybe<OrderBy>;
  project?: InputMaybe<ProjectsOrderBy>;
  projectId?: InputMaybe<OrderBy>;
  reminderSentAt?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  startAt?: InputMaybe<OrderBy>;
  statusUpdatedAt?: InputMaybe<OrderBy>;
  statusUpdatedBy?: InputMaybe<OrderBy>;
  statusUpdater?: InputMaybe<UsersOrderBy>;
  storageFolderId?: InputMaybe<OrderBy>;
  storagePosition?: InputMaybe<OrderBy>;
  stored?: InputMaybe<OrderBy>;
  taskDescription?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  versionsAggregate?: InputMaybe<VersionsAggregateOrderBy>;
};

/** primary key columns input for table: documents */
export type DocumentsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type DocumentsPrependInput = {
  /** the task briefing, using the tiptap DSL */
  taskDescription?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "documents" */
export enum DocumentsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  ApprovalStatus = 'approvalStatus',
  /** column name */
  ApprovalsEnabled = 'approvalsEnabled',
  /** column name */
  Archived = 'archived',
  /** column name */
  AssigneeId = 'assigneeId',
  /** column name */
  AssignerId = 'assignerId',
  /** column name */
  CommentsEnabled = 'commentsEnabled',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  DueAt = 'dueAt',
  /** column name */
  ExternalLink = 'externalLink',
  /** column name */
  FigmaHash = 'figmaHash',
  /** column name */
  FigmaId = 'figmaId',
  /** column name */
  FigmaKeep = 'figmaKeep',
  /** column name */
  FigmaName = 'figmaName',
  /** column name */
  FigmaPageUuid = 'figmaPageUuid',
  /** column name */
  FigmaQuickHash = 'figmaQuickHash',
  /** column name */
  FigmaSortedIds = 'figmaSortedIds',
  /** column name */
  FractionalPosition = 'fractionalPosition',
  /** column name */
  GlobalAccess = 'globalAccess',
  /** column name */
  GlobalAccessToken = 'globalAccessToken',
  /** column name */
  GlobalAccessTokenExpiresAt = 'globalAccessTokenExpiresAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  GroupPosition = 'groupPosition',
  /** column name */
  HasPublicAccess = 'hasPublicAccess',
  /** column name */
  HasPublicAccessEditing = 'hasPublicAccessEditing',
  /** column name */
  Id = 'id',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  LaneId = 'laneId',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  Priority = 'priority',
  /** column name */
  ProjectId = 'projectId',
  /** column name */
  ReminderSentAt = 'reminderSentAt',
  /** column name */
  Slug = 'slug',
  /** column name */
  StartAt = 'startAt',
  /** column name */
  StatusUpdatedAt = 'statusUpdatedAt',
  /** column name */
  StatusUpdatedBy = 'statusUpdatedBy',
  /** column name */
  StorageFolderId = 'storageFolderId',
  /** column name */
  StoragePosition = 'storagePosition',
  /** column name */
  Stored = 'stored',
  /** column name */
  TaskDescription = 'taskDescription',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** select "documentsAggregateBoolExpBool_andArgumentsColumns" columns of table "documents" */
export enum DocumentsSelectColumnDocumentsAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  ApprovalsEnabled = 'approvalsEnabled',
  /** column name */
  Archived = 'archived',
  /** column name */
  CommentsEnabled = 'commentsEnabled',
  /** column name */
  FigmaKeep = 'figmaKeep',
  /** column name */
  GlobalAccess = 'globalAccess',
  /** column name */
  HasPublicAccess = 'hasPublicAccess',
  /** column name */
  HasPublicAccessEditing = 'hasPublicAccessEditing',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  Stored = 'stored'
}

/** select "documentsAggregateBoolExpBool_orArgumentsColumns" columns of table "documents" */
export enum DocumentsSelectColumnDocumentsAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  ApprovalsEnabled = 'approvalsEnabled',
  /** column name */
  Archived = 'archived',
  /** column name */
  CommentsEnabled = 'commentsEnabled',
  /** column name */
  FigmaKeep = 'figmaKeep',
  /** column name */
  GlobalAccess = 'globalAccess',
  /** column name */
  HasPublicAccess = 'hasPublicAccess',
  /** column name */
  HasPublicAccessEditing = 'hasPublicAccessEditing',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  Stored = 'stored'
}

/** input type for updating data in table "documents" */
export type DocumentsSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [approval] - can users mark the document as approved? */
  approvalsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** [Archive] - has the user moved to archive? */
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  /** User that is asigned */
  assigneeId?: InputMaybe<Scalars['uuid']['input']>;
  /** [notifications] - User who assigned the assignee */
  assignerId?: InputMaybe<Scalars['uuid']['input']>;
  /** whether comments have been disabled or not for this document */
  commentsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Remove, not used - was previously how the description was stored, prior to moving to task_description */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Due date */
  dueAt?: InputMaybe<Scalars['date']['input']>;
  /** remove */
  externalLink?: InputMaybe<Scalars['String']['input']>;
  /** Remove, not used - used to allow automatic detection of changes in Figma and syncing */
  figmaHash?: InputMaybe<Scalars['String']['input']>;
  /** [Figma plugin] */
  figmaId?: InputMaybe<Scalars['String']['input']>;
  /** Remove, not used */
  figmaKeep?: InputMaybe<Scalars['Boolean']['input']>;
  /** Remove, not used */
  figmaName?: InputMaybe<Scalars['String']['input']>;
  /** Remove, not used */
  figmaPageUuid?: InputMaybe<Scalars['String']['input']>;
  /** Remove, not used used to allow automatic detection of changes in Figma and syncing */
  figmaQuickHash?: InputMaybe<Scalars['String']['input']>;
  /** [Figma] remove */
  figmaSortedIds?: InputMaybe<Scalars['String']['input']>;
  /** Ordering position of the task in the column on the kanban board. */
  fractionalPosition?: InputMaybe<Scalars['String']['input']>;
  /** [Sharing] - remove - previously defined if the document is accessible, now replaced by has_public_access */
  globalAccess?: InputMaybe<Scalars['Boolean']['input']>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessToken?: InputMaybe<Scalars['String']['input']>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessTokenExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [timeline] - group that the document is in on the Gantt board */
  groupId?: InputMaybe<Scalars['uuid']['input']>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<Scalars['Int']['input']>;
  /** [sharing] - is the document accessible by anyone on the internet? */
  hasPublicAccess?: InputMaybe<Scalars['Boolean']['input']>;
  /** [sharing] - can guest viewers edit, which is to say add or remove versions */
  hasPublicAccessEditing?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [Analytics] - mark as demo to remove from analytics */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Which Kanban stage the task belongs to */
  laneId?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** title of the task */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<Scalars['Int']['input']>;
  /** Project that the task belongs to */
  projectId?: InputMaybe<Scalars['uuid']['input']>;
  /** Remove, previously allowed email reminders for reviews to be sent */
  reminderSentAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** used for the URL, and often used to lookup the docuement from the URL */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** [timeline] - date that task began */
  startAt?: InputMaybe<Scalars['date']['input']>;
  /** Rename - This stores the date when the document lane is changed. This is used by the "done" column, as the done column groups tasks by the date they were moved to done (e.g. yesterday, last week). Should be renamed to lane_updated_at to match consistent database naming of "lane". */
  statusUpdatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [notifications] - who updated the status */
  statusUpdatedBy?: InputMaybe<Scalars['uuid']['input']>;
  /** [storage] - which folder, if any, is the document in? */
  storageFolderId?: InputMaybe<Scalars['uuid']['input']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<Scalars['Int']['input']>;
  /** [storage] - is this document in the Storage app? */
  stored?: InputMaybe<Scalars['Boolean']['input']>;
  /** the task briefing, using the tiptap DSL */
  taskDescription?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Creator of the task */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type DocumentsStddevFields = {
  __typename?: 'DocumentsStddevFields';
  /** [approval][enum] - the current approval status */
  approvalStatus?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - position within the group */
  groupPosition?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: Maybe<Scalars['Float']['output']>;
  /** [enum] Priority for the task */
  priority?: Maybe<Scalars['Float']['output']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "documents" */
export type DocumentsStddevOrderBy = {
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<OrderBy>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<OrderBy>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<OrderBy>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type DocumentsStddevPopFields = {
  __typename?: 'DocumentsStddevPopFields';
  /** [approval][enum] - the current approval status */
  approvalStatus?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - position within the group */
  groupPosition?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: Maybe<Scalars['Float']['output']>;
  /** [enum] Priority for the task */
  priority?: Maybe<Scalars['Float']['output']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "documents" */
export type DocumentsStddevPopOrderBy = {
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<OrderBy>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<OrderBy>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<OrderBy>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type DocumentsStddevSampFields = {
  __typename?: 'DocumentsStddevSampFields';
  /** [approval][enum] - the current approval status */
  approvalStatus?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - position within the group */
  groupPosition?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: Maybe<Scalars['Float']['output']>;
  /** [enum] Priority for the task */
  priority?: Maybe<Scalars['Float']['output']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "documents" */
export type DocumentsStddevSampOrderBy = {
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<OrderBy>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<OrderBy>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<OrderBy>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "documents" */
export type DocumentsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: DocumentsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type DocumentsStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [approval] - can users mark the document as approved? */
  approvalsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** [Archive] - has the user moved to archive? */
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  /** User that is asigned */
  assigneeId?: InputMaybe<Scalars['uuid']['input']>;
  /** [notifications] - User who assigned the assignee */
  assignerId?: InputMaybe<Scalars['uuid']['input']>;
  /** whether comments have been disabled or not for this document */
  commentsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Remove, not used - was previously how the description was stored, prior to moving to task_description */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Due date */
  dueAt?: InputMaybe<Scalars['date']['input']>;
  /** remove */
  externalLink?: InputMaybe<Scalars['String']['input']>;
  /** Remove, not used - used to allow automatic detection of changes in Figma and syncing */
  figmaHash?: InputMaybe<Scalars['String']['input']>;
  /** [Figma plugin] */
  figmaId?: InputMaybe<Scalars['String']['input']>;
  /** Remove, not used */
  figmaKeep?: InputMaybe<Scalars['Boolean']['input']>;
  /** Remove, not used */
  figmaName?: InputMaybe<Scalars['String']['input']>;
  /** Remove, not used */
  figmaPageUuid?: InputMaybe<Scalars['String']['input']>;
  /** Remove, not used used to allow automatic detection of changes in Figma and syncing */
  figmaQuickHash?: InputMaybe<Scalars['String']['input']>;
  /** [Figma] remove */
  figmaSortedIds?: InputMaybe<Scalars['String']['input']>;
  /** Ordering position of the task in the column on the kanban board. */
  fractionalPosition?: InputMaybe<Scalars['String']['input']>;
  /** [Sharing] - remove - previously defined if the document is accessible, now replaced by has_public_access */
  globalAccess?: InputMaybe<Scalars['Boolean']['input']>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessToken?: InputMaybe<Scalars['String']['input']>;
  /** [Sharing] - check and probably remove, previous system for making globally accessible */
  globalAccessTokenExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [timeline] - group that the document is in on the Gantt board */
  groupId?: InputMaybe<Scalars['uuid']['input']>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<Scalars['Int']['input']>;
  /** [sharing] - is the document accessible by anyone on the internet? */
  hasPublicAccess?: InputMaybe<Scalars['Boolean']['input']>;
  /** [sharing] - can guest viewers edit, which is to say add or remove versions */
  hasPublicAccessEditing?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [Analytics] - mark as demo to remove from analytics */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Which Kanban stage the task belongs to */
  laneId?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** title of the task */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<Scalars['Int']['input']>;
  /** Project that the task belongs to */
  projectId?: InputMaybe<Scalars['uuid']['input']>;
  /** Remove, previously allowed email reminders for reviews to be sent */
  reminderSentAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** used for the URL, and often used to lookup the docuement from the URL */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** [timeline] - date that task began */
  startAt?: InputMaybe<Scalars['date']['input']>;
  /** Rename - This stores the date when the document lane is changed. This is used by the "done" column, as the done column groups tasks by the date they were moved to done (e.g. yesterday, last week). Should be renamed to lane_updated_at to match consistent database naming of "lane". */
  statusUpdatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [notifications] - who updated the status */
  statusUpdatedBy?: InputMaybe<Scalars['uuid']['input']>;
  /** [storage] - which folder, if any, is the document in? */
  storageFolderId?: InputMaybe<Scalars['uuid']['input']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<Scalars['Int']['input']>;
  /** [storage] - is this document in the Storage app? */
  stored?: InputMaybe<Scalars['Boolean']['input']>;
  /** the task briefing, using the tiptap DSL */
  taskDescription?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Creator of the task */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type DocumentsSumFields = {
  __typename?: 'DocumentsSumFields';
  /** [approval][enum] - the current approval status */
  approvalStatus?: Maybe<Scalars['Int']['output']>;
  /** [timeline] - position within the group */
  groupPosition?: Maybe<Scalars['Int']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: Maybe<Scalars['Int']['output']>;
  /** [enum] Priority for the task */
  priority?: Maybe<Scalars['Int']['output']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "documents" */
export type DocumentsSumOrderBy = {
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<OrderBy>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<OrderBy>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<OrderBy>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<OrderBy>;
};

/** update columns of table "documents" */
export enum DocumentsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  ApprovalStatus = 'approvalStatus',
  /** column name */
  ApprovalsEnabled = 'approvalsEnabled',
  /** column name */
  Archived = 'archived',
  /** column name */
  AssigneeId = 'assigneeId',
  /** column name */
  AssignerId = 'assignerId',
  /** column name */
  CommentsEnabled = 'commentsEnabled',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  DueAt = 'dueAt',
  /** column name */
  ExternalLink = 'externalLink',
  /** column name */
  FigmaHash = 'figmaHash',
  /** column name */
  FigmaId = 'figmaId',
  /** column name */
  FigmaKeep = 'figmaKeep',
  /** column name */
  FigmaName = 'figmaName',
  /** column name */
  FigmaPageUuid = 'figmaPageUuid',
  /** column name */
  FigmaQuickHash = 'figmaQuickHash',
  /** column name */
  FigmaSortedIds = 'figmaSortedIds',
  /** column name */
  FractionalPosition = 'fractionalPosition',
  /** column name */
  GlobalAccess = 'globalAccess',
  /** column name */
  GlobalAccessToken = 'globalAccessToken',
  /** column name */
  GlobalAccessTokenExpiresAt = 'globalAccessTokenExpiresAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  GroupPosition = 'groupPosition',
  /** column name */
  HasPublicAccess = 'hasPublicAccess',
  /** column name */
  HasPublicAccessEditing = 'hasPublicAccessEditing',
  /** column name */
  Id = 'id',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  LaneId = 'laneId',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  Priority = 'priority',
  /** column name */
  ProjectId = 'projectId',
  /** column name */
  ReminderSentAt = 'reminderSentAt',
  /** column name */
  Slug = 'slug',
  /** column name */
  StartAt = 'startAt',
  /** column name */
  StatusUpdatedAt = 'statusUpdatedAt',
  /** column name */
  StatusUpdatedBy = 'statusUpdatedBy',
  /** column name */
  StorageFolderId = 'storageFolderId',
  /** column name */
  StoragePosition = 'storagePosition',
  /** column name */
  Stored = 'stored',
  /** column name */
  TaskDescription = 'taskDescription',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type DocumentsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<DocumentsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<DocumentsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<DocumentsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<DocumentsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<DocumentsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<DocumentsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DocumentsSetInput>;
  /** filter the rows which have to be updated */
  where: DocumentsBoolExp;
};

/** aggregate varPop on columns */
export type DocumentsVarPopFields = {
  __typename?: 'DocumentsVarPopFields';
  /** [approval][enum] - the current approval status */
  approvalStatus?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - position within the group */
  groupPosition?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: Maybe<Scalars['Float']['output']>;
  /** [enum] Priority for the task */
  priority?: Maybe<Scalars['Float']['output']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "documents" */
export type DocumentsVarPopOrderBy = {
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<OrderBy>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<OrderBy>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<OrderBy>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type DocumentsVarSampFields = {
  __typename?: 'DocumentsVarSampFields';
  /** [approval][enum] - the current approval status */
  approvalStatus?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - position within the group */
  groupPosition?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: Maybe<Scalars['Float']['output']>;
  /** [enum] Priority for the task */
  priority?: Maybe<Scalars['Float']['output']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "documents" */
export type DocumentsVarSampOrderBy = {
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<OrderBy>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<OrderBy>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<OrderBy>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type DocumentsVarianceFields = {
  __typename?: 'DocumentsVarianceFields';
  /** [approval][enum] - the current approval status */
  approvalStatus?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - position within the group */
  groupPosition?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: Maybe<Scalars['Float']['output']>;
  /** [enum] Priority for the task */
  priority?: Maybe<Scalars['Float']['output']>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "documents" */
export type DocumentsVarianceOrderBy = {
  /** [approval][enum] - the current approval status */
  approvalStatus?: InputMaybe<OrderBy>;
  /** [timeline] - position within the group */
  groupPosition?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Check then remove - Old way order of the task in the kanban column was managed, replaced by fractional_position */
  position?: InputMaybe<OrderBy>;
  /** [enum] Priority for the task */
  priority?: InputMaybe<OrderBy>;
  /** [storage] - which position in the folder is the item in? */
  storagePosition?: InputMaybe<OrderBy>;
};

export type DuplicateDocumentInput = {
  documentId: Scalars['String']['input'];
  newDocumentId: Scalars['String']['input'];
  newDocumentName: Scalars['String']['input'];
  newDocumentSlug: Scalars['String']['input'];
};

export type DuplicateDocumentOutput = {
  __typename?: 'DuplicateDocumentOutput';
  documentId: Scalars['String']['output'];
  documentName: Scalars['String']['output'];
  documentSlug: Scalars['String']['output'];
  errors?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  success: Scalars['Boolean']['output'];
};

/** Every transactional email starts as row in the emails table, allowing us to debug sendability issues */
export type Emails = {
  __typename?: 'Emails';
  /** [reference] the account this relates to, if any */
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** response data returned from the email sending service used */
  apiResponseData?: Maybe<Scalars['json']['output']>;
  /** [enum] type of email sent */
  category?: Maybe<Scalars['Int']['output']>;
  createdAt: Scalars['timestamp']['output'];
  /** This is a JSON bundle of data needed to build the email, using ReactEmail, in the workflow email microservice */
  data?: Maybe<Scalars['json']['output']>;
  /** [reference] the document this relates to, if any */
  documentId?: Maybe<Scalars['uuid']['output']>;
  /** [reference] id of any other object that this email relates, e.g. Message */
  emailableId?: Maybe<Scalars['uuid']['output']>;
  /** [reference] type of any other object that this email relates, e.g. Message */
  emailableType?: Maybe<Scalars['String']['output']>;
  id: Scalars['bigint']['output'];
  /** [reference] the project this relates to, if any */
  projectId?: Maybe<Scalars['uuid']['output']>;
  /** Email of receiver to direct reply to if recipient hit reply to the email, ideally should be the user who triggered the email. This means that if a recipient just replies via email rather than inside Workflow, it goes to the right person. */
  replyToEmail?: Maybe<Scalars['String']['output']>;
  /** Name of receiver displayed in recipients email client if recipient hit reply to the email, ideally should be the user who triggered the email. This means that if a recipient just replies via email rather than inside Workflow, it goes to the right person. */
  replyToName?: Maybe<Scalars['String']['output']>;
  /** [review requests] remove, unused */
  requestId?: Maybe<Scalars['uuid']['output']>;
  /** remove - previously emails could belong to  */
  sequenceId?: Maybe<Scalars['bigint']['output']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service: Scalars['Int']['output'];
  /** [enum] The state of this email - initialised, sent, error */
  state?: Maybe<Scalars['Int']['output']>;
  /** template name in the workflow email microervice */
  templateId?: Maybe<Scalars['String']['output']>;
  /** email address sent to */
  to: Scalars['String']['output'];
  updatedAt: Scalars['timestamp']['output'];
  userId?: Maybe<Scalars['uuid']['output']>;
  /** [reference] the version this relates to, if any */
  versionId?: Maybe<Scalars['uuid']['output']>;
};


/** Every transactional email starts as row in the emails table, allowing us to debug sendability issues */
export type EmailsApiResponseDataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Every transactional email starts as row in the emails table, allowing us to debug sendability issues */
export type EmailsDataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "emails" */
export type EmailsAggregate = {
  __typename?: 'EmailsAggregate';
  aggregate?: Maybe<EmailsAggregateFields>;
  nodes: Array<Emails>;
};

/** aggregate fields of "emails" */
export type EmailsAggregateFields = {
  __typename?: 'EmailsAggregateFields';
  avg?: Maybe<EmailsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<EmailsMaxFields>;
  min?: Maybe<EmailsMinFields>;
  stddev?: Maybe<EmailsStddevFields>;
  stddevPop?: Maybe<EmailsStddevPopFields>;
  stddevSamp?: Maybe<EmailsStddevSampFields>;
  sum?: Maybe<EmailsSumFields>;
  varPop?: Maybe<EmailsVarPopFields>;
  varSamp?: Maybe<EmailsVarSampFields>;
  variance?: Maybe<EmailsVarianceFields>;
};


/** aggregate fields of "emails" */
export type EmailsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EmailsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type EmailsAvgFields = {
  __typename?: 'EmailsAvgFields';
  /** [enum] type of email sent */
  category?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** remove - previously emails could belong to  */
  sequenceId?: Maybe<Scalars['Float']['output']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: Maybe<Scalars['Float']['output']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "emails". All fields are combined with a logical 'AND'. */
export type EmailsBoolExp = {
  _and?: InputMaybe<Array<EmailsBoolExp>>;
  _not?: InputMaybe<EmailsBoolExp>;
  _or?: InputMaybe<Array<EmailsBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  apiResponseData?: InputMaybe<JsonComparisonExp>;
  category?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  data?: InputMaybe<JsonComparisonExp>;
  documentId?: InputMaybe<UuidComparisonExp>;
  emailableId?: InputMaybe<UuidComparisonExp>;
  emailableType?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  projectId?: InputMaybe<UuidComparisonExp>;
  replyToEmail?: InputMaybe<StringComparisonExp>;
  replyToName?: InputMaybe<StringComparisonExp>;
  requestId?: InputMaybe<UuidComparisonExp>;
  sequenceId?: InputMaybe<BigintComparisonExp>;
  service?: InputMaybe<IntComparisonExp>;
  state?: InputMaybe<IntComparisonExp>;
  templateId?: InputMaybe<StringComparisonExp>;
  to?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  versionId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "emails" */
export enum EmailsConstraint {
  /** unique or primary key constraint on columns "id" */
  EmailsPkey = 'emails_pkey'
}

/** input type for incrementing numeric columns in table "emails" */
export type EmailsIncInput = {
  /** [enum] type of email sent */
  category?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** remove - previously emails could belong to  */
  sequenceId?: InputMaybe<Scalars['bigint']['input']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "emails" */
export type EmailsInsertInput = {
  /** [reference] the account this relates to, if any */
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** response data returned from the email sending service used */
  apiResponseData?: InputMaybe<Scalars['json']['input']>;
  /** [enum] type of email sent */
  category?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** This is a JSON bundle of data needed to build the email, using ReactEmail, in the workflow email microservice */
  data?: InputMaybe<Scalars['json']['input']>;
  /** [reference] the document this relates to, if any */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** [reference] id of any other object that this email relates, e.g. Message */
  emailableId?: InputMaybe<Scalars['uuid']['input']>;
  /** [reference] type of any other object that this email relates, e.g. Message */
  emailableType?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** [reference] the project this relates to, if any */
  projectId?: InputMaybe<Scalars['uuid']['input']>;
  /** Email of receiver to direct reply to if recipient hit reply to the email, ideally should be the user who triggered the email. This means that if a recipient just replies via email rather than inside Workflow, it goes to the right person. */
  replyToEmail?: InputMaybe<Scalars['String']['input']>;
  /** Name of receiver displayed in recipients email client if recipient hit reply to the email, ideally should be the user who triggered the email. This means that if a recipient just replies via email rather than inside Workflow, it goes to the right person. */
  replyToName?: InputMaybe<Scalars['String']['input']>;
  /** [review requests] remove, unused */
  requestId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove - previously emails could belong to  */
  sequenceId?: InputMaybe<Scalars['bigint']['input']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: InputMaybe<Scalars['Int']['input']>;
  /** template name in the workflow email microervice */
  templateId?: InputMaybe<Scalars['String']['input']>;
  /** email address sent to */
  to?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** [reference] the version this relates to, if any */
  versionId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type EmailsMaxFields = {
  __typename?: 'EmailsMaxFields';
  /** [reference] the account this relates to, if any */
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** [enum] type of email sent */
  category?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** [reference] the document this relates to, if any */
  documentId?: Maybe<Scalars['uuid']['output']>;
  /** [reference] id of any other object that this email relates, e.g. Message */
  emailableId?: Maybe<Scalars['uuid']['output']>;
  /** [reference] type of any other object that this email relates, e.g. Message */
  emailableType?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** [reference] the project this relates to, if any */
  projectId?: Maybe<Scalars['uuid']['output']>;
  /** Email of receiver to direct reply to if recipient hit reply to the email, ideally should be the user who triggered the email. This means that if a recipient just replies via email rather than inside Workflow, it goes to the right person. */
  replyToEmail?: Maybe<Scalars['String']['output']>;
  /** Name of receiver displayed in recipients email client if recipient hit reply to the email, ideally should be the user who triggered the email. This means that if a recipient just replies via email rather than inside Workflow, it goes to the right person. */
  replyToName?: Maybe<Scalars['String']['output']>;
  /** [review requests] remove, unused */
  requestId?: Maybe<Scalars['uuid']['output']>;
  /** remove - previously emails could belong to  */
  sequenceId?: Maybe<Scalars['bigint']['output']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: Maybe<Scalars['Int']['output']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: Maybe<Scalars['Int']['output']>;
  /** template name in the workflow email microervice */
  templateId?: Maybe<Scalars['String']['output']>;
  /** email address sent to */
  to?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
  /** [reference] the version this relates to, if any */
  versionId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type EmailsMinFields = {
  __typename?: 'EmailsMinFields';
  /** [reference] the account this relates to, if any */
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** [enum] type of email sent */
  category?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** [reference] the document this relates to, if any */
  documentId?: Maybe<Scalars['uuid']['output']>;
  /** [reference] id of any other object that this email relates, e.g. Message */
  emailableId?: Maybe<Scalars['uuid']['output']>;
  /** [reference] type of any other object that this email relates, e.g. Message */
  emailableType?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** [reference] the project this relates to, if any */
  projectId?: Maybe<Scalars['uuid']['output']>;
  /** Email of receiver to direct reply to if recipient hit reply to the email, ideally should be the user who triggered the email. This means that if a recipient just replies via email rather than inside Workflow, it goes to the right person. */
  replyToEmail?: Maybe<Scalars['String']['output']>;
  /** Name of receiver displayed in recipients email client if recipient hit reply to the email, ideally should be the user who triggered the email. This means that if a recipient just replies via email rather than inside Workflow, it goes to the right person. */
  replyToName?: Maybe<Scalars['String']['output']>;
  /** [review requests] remove, unused */
  requestId?: Maybe<Scalars['uuid']['output']>;
  /** remove - previously emails could belong to  */
  sequenceId?: Maybe<Scalars['bigint']['output']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: Maybe<Scalars['Int']['output']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: Maybe<Scalars['Int']['output']>;
  /** template name in the workflow email microervice */
  templateId?: Maybe<Scalars['String']['output']>;
  /** email address sent to */
  to?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
  /** [reference] the version this relates to, if any */
  versionId?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "emails" */
export type EmailsMutationResponse = {
  __typename?: 'EmailsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Emails>;
};

/** on_conflict condition type for table "emails" */
export type EmailsOnConflict = {
  constraint: EmailsConstraint;
  updateColumns?: Array<EmailsUpdateColumn>;
  where?: InputMaybe<EmailsBoolExp>;
};

/** Ordering options when selecting data from "emails". */
export type EmailsOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  apiResponseData?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  data?: InputMaybe<OrderBy>;
  documentId?: InputMaybe<OrderBy>;
  emailableId?: InputMaybe<OrderBy>;
  emailableType?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  projectId?: InputMaybe<OrderBy>;
  replyToEmail?: InputMaybe<OrderBy>;
  replyToName?: InputMaybe<OrderBy>;
  requestId?: InputMaybe<OrderBy>;
  sequenceId?: InputMaybe<OrderBy>;
  service?: InputMaybe<OrderBy>;
  state?: InputMaybe<OrderBy>;
  templateId?: InputMaybe<OrderBy>;
  to?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  versionId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: emails */
export type EmailsPkColumnsInput = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "emails" */
export enum EmailsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  ApiResponseData = 'apiResponseData',
  /** column name */
  Category = 'category',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  DocumentId = 'documentId',
  /** column name */
  EmailableId = 'emailableId',
  /** column name */
  EmailableType = 'emailableType',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'projectId',
  /** column name */
  ReplyToEmail = 'replyToEmail',
  /** column name */
  ReplyToName = 'replyToName',
  /** column name */
  RequestId = 'requestId',
  /** column name */
  SequenceId = 'sequenceId',
  /** column name */
  Service = 'service',
  /** column name */
  State = 'state',
  /** column name */
  TemplateId = 'templateId',
  /** column name */
  To = 'to',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  VersionId = 'versionId'
}

/** input type for updating data in table "emails" */
export type EmailsSetInput = {
  /** [reference] the account this relates to, if any */
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** response data returned from the email sending service used */
  apiResponseData?: InputMaybe<Scalars['json']['input']>;
  /** [enum] type of email sent */
  category?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** This is a JSON bundle of data needed to build the email, using ReactEmail, in the workflow email microservice */
  data?: InputMaybe<Scalars['json']['input']>;
  /** [reference] the document this relates to, if any */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** [reference] id of any other object that this email relates, e.g. Message */
  emailableId?: InputMaybe<Scalars['uuid']['input']>;
  /** [reference] type of any other object that this email relates, e.g. Message */
  emailableType?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** [reference] the project this relates to, if any */
  projectId?: InputMaybe<Scalars['uuid']['input']>;
  /** Email of receiver to direct reply to if recipient hit reply to the email, ideally should be the user who triggered the email. This means that if a recipient just replies via email rather than inside Workflow, it goes to the right person. */
  replyToEmail?: InputMaybe<Scalars['String']['input']>;
  /** Name of receiver displayed in recipients email client if recipient hit reply to the email, ideally should be the user who triggered the email. This means that if a recipient just replies via email rather than inside Workflow, it goes to the right person. */
  replyToName?: InputMaybe<Scalars['String']['input']>;
  /** [review requests] remove, unused */
  requestId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove - previously emails could belong to  */
  sequenceId?: InputMaybe<Scalars['bigint']['input']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: InputMaybe<Scalars['Int']['input']>;
  /** template name in the workflow email microervice */
  templateId?: InputMaybe<Scalars['String']['input']>;
  /** email address sent to */
  to?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** [reference] the version this relates to, if any */
  versionId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type EmailsStddevFields = {
  __typename?: 'EmailsStddevFields';
  /** [enum] type of email sent */
  category?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** remove - previously emails could belong to  */
  sequenceId?: Maybe<Scalars['Float']['output']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: Maybe<Scalars['Float']['output']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type EmailsStddevPopFields = {
  __typename?: 'EmailsStddevPopFields';
  /** [enum] type of email sent */
  category?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** remove - previously emails could belong to  */
  sequenceId?: Maybe<Scalars['Float']['output']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: Maybe<Scalars['Float']['output']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type EmailsStddevSampFields = {
  __typename?: 'EmailsStddevSampFields';
  /** [enum] type of email sent */
  category?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** remove - previously emails could belong to  */
  sequenceId?: Maybe<Scalars['Float']['output']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: Maybe<Scalars['Float']['output']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "emails" */
export type EmailsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EmailsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EmailsStreamCursorValueInput = {
  /** [reference] the account this relates to, if any */
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** response data returned from the email sending service used */
  apiResponseData?: InputMaybe<Scalars['json']['input']>;
  /** [enum] type of email sent */
  category?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** This is a JSON bundle of data needed to build the email, using ReactEmail, in the workflow email microservice */
  data?: InputMaybe<Scalars['json']['input']>;
  /** [reference] the document this relates to, if any */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** [reference] id of any other object that this email relates, e.g. Message */
  emailableId?: InputMaybe<Scalars['uuid']['input']>;
  /** [reference] type of any other object that this email relates, e.g. Message */
  emailableType?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** [reference] the project this relates to, if any */
  projectId?: InputMaybe<Scalars['uuid']['input']>;
  /** Email of receiver to direct reply to if recipient hit reply to the email, ideally should be the user who triggered the email. This means that if a recipient just replies via email rather than inside Workflow, it goes to the right person. */
  replyToEmail?: InputMaybe<Scalars['String']['input']>;
  /** Name of receiver displayed in recipients email client if recipient hit reply to the email, ideally should be the user who triggered the email. This means that if a recipient just replies via email rather than inside Workflow, it goes to the right person. */
  replyToName?: InputMaybe<Scalars['String']['input']>;
  /** [review requests] remove, unused */
  requestId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove - previously emails could belong to  */
  sequenceId?: InputMaybe<Scalars['bigint']['input']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: InputMaybe<Scalars['Int']['input']>;
  /** template name in the workflow email microervice */
  templateId?: InputMaybe<Scalars['String']['input']>;
  /** email address sent to */
  to?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** [reference] the version this relates to, if any */
  versionId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type EmailsSumFields = {
  __typename?: 'EmailsSumFields';
  /** [enum] type of email sent */
  category?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** remove - previously emails could belong to  */
  sequenceId?: Maybe<Scalars['bigint']['output']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: Maybe<Scalars['Int']['output']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "emails" */
export enum EmailsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  ApiResponseData = 'apiResponseData',
  /** column name */
  Category = 'category',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  DocumentId = 'documentId',
  /** column name */
  EmailableId = 'emailableId',
  /** column name */
  EmailableType = 'emailableType',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'projectId',
  /** column name */
  ReplyToEmail = 'replyToEmail',
  /** column name */
  ReplyToName = 'replyToName',
  /** column name */
  RequestId = 'requestId',
  /** column name */
  SequenceId = 'sequenceId',
  /** column name */
  Service = 'service',
  /** column name */
  State = 'state',
  /** column name */
  TemplateId = 'templateId',
  /** column name */
  To = 'to',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  VersionId = 'versionId'
}

export type EmailsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EmailsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EmailsSetInput>;
  /** filter the rows which have to be updated */
  where: EmailsBoolExp;
};

/** aggregate varPop on columns */
export type EmailsVarPopFields = {
  __typename?: 'EmailsVarPopFields';
  /** [enum] type of email sent */
  category?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** remove - previously emails could belong to  */
  sequenceId?: Maybe<Scalars['Float']['output']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: Maybe<Scalars['Float']['output']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type EmailsVarSampFields = {
  __typename?: 'EmailsVarSampFields';
  /** [enum] type of email sent */
  category?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** remove - previously emails could belong to  */
  sequenceId?: Maybe<Scalars['Float']['output']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: Maybe<Scalars['Float']['output']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type EmailsVarianceFields = {
  __typename?: 'EmailsVarianceFields';
  /** [enum] type of email sent */
  category?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  /** remove - previously emails could belong to  */
  sequenceId?: Maybe<Scalars['Float']['output']>;
  /** email service use to send email, Resend, CustomerIo, Sendgrid. As of 23/11/24, all emails are sent by Resend */
  service?: Maybe<Scalars['Float']['output']>;
  /** [enum] The state of this email - initialised, sent, error */
  state?: Maybe<Scalars['Float']['output']>;
};

/** CanvasItem subtype that stores the metadata relating to file item. In future this will be used as a basic building block for all file attachments, such as attachments for messages. */
export type FileItems = {
  __typename?: 'FileItems';
  accountId: Scalars['uuid']['output'];
  /** URL pointing to the asset file */
  assetUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  canvasItem?: Maybe<CanvasItems>;
  /** The parent canvas item */
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  canvasVersion: Scalars['Int']['output'];
  /** The content type of the file item. */
  contentType: Scalars['String']['output'];
  createdAt: Scalars['timestamp']['output'];
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Int']['output']>;
  id: Scalars['uuid']['output'];
  /** Sections in Figma are exported with a 40px trim. This flag is used to determine if the file item is a section so that the sync can place comments correctly. */
  isFigmaSection: Scalars['Boolean']['output'];
  lastModifiedVersion: Scalars['Int']['output'];
  /** Optimistic locking for concurrent processing. */
  lockVersion: Scalars['Int']['output'];
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: Maybe<Scalars['Int']['output']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: Maybe<Scalars['Int']['output']>;
  /** The error reason of the file item processing, if applicable. */
  processingErrorReason?: Maybe<Scalars['String']['output']>;
  /** The processing status of the file item/ */
  processingStatus: Scalars['Int']['output'];
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus: Scalars['Int']['output'];
  /** Thumbnail presigned URL */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt: Scalars['timestamp']['output'];
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "file_items" */
export type FileItemsAggregate = {
  __typename?: 'FileItemsAggregate';
  aggregate?: Maybe<FileItemsAggregateFields>;
  nodes: Array<FileItems>;
};

/** aggregate fields of "file_items" */
export type FileItemsAggregateFields = {
  __typename?: 'FileItemsAggregateFields';
  avg?: Maybe<FileItemsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<FileItemsMaxFields>;
  min?: Maybe<FileItemsMinFields>;
  stddev?: Maybe<FileItemsStddevFields>;
  stddevPop?: Maybe<FileItemsStddevPopFields>;
  stddevSamp?: Maybe<FileItemsStddevSampFields>;
  sum?: Maybe<FileItemsSumFields>;
  varPop?: Maybe<FileItemsVarPopFields>;
  varSamp?: Maybe<FileItemsVarSampFields>;
  variance?: Maybe<FileItemsVarianceFields>;
};


/** aggregate fields of "file_items" */
export type FileItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<FileItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type FileItemsAvgFields = {
  __typename?: 'FileItemsAvgFields';
  canvasVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: Maybe<Scalars['Float']['output']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item/ */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "file_items". All fields are combined with a logical 'AND'. */
export type FileItemsBoolExp = {
  _and?: InputMaybe<Array<FileItemsBoolExp>>;
  _not?: InputMaybe<FileItemsBoolExp>;
  _or?: InputMaybe<Array<FileItemsBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  assetUrl?: InputMaybe<StringComparisonExp>;
  assetUrlExpiresAt?: InputMaybe<TimestamptzComparisonExp>;
  canvasItem?: InputMaybe<CanvasItemsBoolExp>;
  canvasItemId?: InputMaybe<UuidComparisonExp>;
  canvasVersion?: InputMaybe<IntComparisonExp>;
  contentType?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  height?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isFigmaSection?: InputMaybe<BooleanComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  lockVersion?: InputMaybe<IntComparisonExp>;
  pageWidth?: InputMaybe<IntComparisonExp>;
  pages?: InputMaybe<IntComparisonExp>;
  processingErrorReason?: InputMaybe<StringComparisonExp>;
  processingStatus?: InputMaybe<IntComparisonExp>;
  thumbnailProcessingError?: InputMaybe<StringComparisonExp>;
  thumbnailProcessingStatus?: InputMaybe<IntComparisonExp>;
  thumbnailUrl?: InputMaybe<StringComparisonExp>;
  thumbnailUrlExpiresAt?: InputMaybe<TimestamptzComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  width?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "file_items" */
export enum FileItemsConstraint {
  /** unique or primary key constraint on columns "id" */
  FileItemsPkey = 'file_items_pkey',
  /** unique or primary key constraint on columns "canvas_item_id" */
  IndexFileItemsOnCanvasItemId = 'index_file_items_on_canvas_item_id'
}

/** input type for incrementing numeric columns in table "file_items" */
export type FileItemsIncInput = {
  canvasVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The width of the item. Calculated async. */
  height?: InputMaybe<Scalars['Int']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: InputMaybe<Scalars['Int']['input']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: InputMaybe<Scalars['Int']['input']>;
  /** The processing status of the file item/ */
  processingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** The width of the item. Calculated async. */
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "file_items" */
export type FileItemsInsertInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** URL pointing to the asset file */
  assetUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  canvasItem?: InputMaybe<CanvasItemsObjRelInsertInput>;
  /** The parent canvas item */
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  canvasVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The content type of the file item. */
  contentType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The width of the item. Calculated async. */
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Sections in Figma are exported with a 40px trim. This flag is used to determine if the file item is a section so that the sync can place comments correctly. */
  isFigmaSection?: InputMaybe<Scalars['Boolean']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: InputMaybe<Scalars['Int']['input']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: InputMaybe<Scalars['Int']['input']>;
  /** The error reason of the file item processing, if applicable. */
  processingErrorReason?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the file item/ */
  processingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** Thumbnail presigned URL */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The width of the item. Calculated async. */
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type FileItemsMaxFields = {
  __typename?: 'FileItemsMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** URL pointing to the asset file */
  assetUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  /** The parent canvas item */
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  canvasVersion?: Maybe<Scalars['Int']['output']>;
  /** The content type of the file item. */
  contentType?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Int']['output']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: Maybe<Scalars['Int']['output']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: Maybe<Scalars['Int']['output']>;
  /** The error reason of the file item processing, if applicable. */
  processingErrorReason?: Maybe<Scalars['String']['output']>;
  /** The processing status of the file item/ */
  processingStatus?: Maybe<Scalars['Int']['output']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** Thumbnail presigned URL */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type FileItemsMinFields = {
  __typename?: 'FileItemsMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** URL pointing to the asset file */
  assetUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  /** The parent canvas item */
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  canvasVersion?: Maybe<Scalars['Int']['output']>;
  /** The content type of the file item. */
  contentType?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Int']['output']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: Maybe<Scalars['Int']['output']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: Maybe<Scalars['Int']['output']>;
  /** The error reason of the file item processing, if applicable. */
  processingErrorReason?: Maybe<Scalars['String']['output']>;
  /** The processing status of the file item/ */
  processingStatus?: Maybe<Scalars['Int']['output']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** Thumbnail presigned URL */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "file_items" */
export type FileItemsMutationResponse = {
  __typename?: 'FileItemsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<FileItems>;
};

/** input type for inserting object relation for remote table "file_items" */
export type FileItemsObjRelInsertInput = {
  data: FileItemsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<FileItemsOnConflict>;
};

/** on_conflict condition type for table "file_items" */
export type FileItemsOnConflict = {
  constraint: FileItemsConstraint;
  updateColumns?: Array<FileItemsUpdateColumn>;
  where?: InputMaybe<FileItemsBoolExp>;
};

/** Ordering options when selecting data from "file_items". */
export type FileItemsOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  assetUrl?: InputMaybe<OrderBy>;
  assetUrlExpiresAt?: InputMaybe<OrderBy>;
  canvasItem?: InputMaybe<CanvasItemsOrderBy>;
  canvasItemId?: InputMaybe<OrderBy>;
  canvasVersion?: InputMaybe<OrderBy>;
  contentType?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isFigmaSection?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  lockVersion?: InputMaybe<OrderBy>;
  pageWidth?: InputMaybe<OrderBy>;
  pages?: InputMaybe<OrderBy>;
  processingErrorReason?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  thumbnailProcessingError?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  thumbnailUrl?: InputMaybe<OrderBy>;
  thumbnailUrlExpiresAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: file_items */
export type FileItemsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "file_items" */
export enum FileItemsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  AssetUrl = 'assetUrl',
  /** column name */
  AssetUrlExpiresAt = 'assetUrlExpiresAt',
  /** column name */
  CanvasItemId = 'canvasItemId',
  /** column name */
  CanvasVersion = 'canvasVersion',
  /** column name */
  ContentType = 'contentType',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Height = 'height',
  /** column name */
  Id = 'id',
  /** column name */
  IsFigmaSection = 'isFigmaSection',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LockVersion = 'lockVersion',
  /** column name */
  PageWidth = 'pageWidth',
  /** column name */
  Pages = 'pages',
  /** column name */
  ProcessingErrorReason = 'processingErrorReason',
  /** column name */
  ProcessingStatus = 'processingStatus',
  /** column name */
  ThumbnailProcessingError = 'thumbnailProcessingError',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  ThumbnailUrl = 'thumbnailUrl',
  /** column name */
  ThumbnailUrlExpiresAt = 'thumbnailUrlExpiresAt',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Width = 'width'
}

/** input type for updating data in table "file_items" */
export type FileItemsSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** URL pointing to the asset file */
  assetUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The parent canvas item */
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  canvasVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The content type of the file item. */
  contentType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The width of the item. Calculated async. */
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Sections in Figma are exported with a 40px trim. This flag is used to determine if the file item is a section so that the sync can place comments correctly. */
  isFigmaSection?: InputMaybe<Scalars['Boolean']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: InputMaybe<Scalars['Int']['input']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: InputMaybe<Scalars['Int']['input']>;
  /** The error reason of the file item processing, if applicable. */
  processingErrorReason?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the file item/ */
  processingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** Thumbnail presigned URL */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The width of the item. Calculated async. */
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type FileItemsStddevFields = {
  __typename?: 'FileItemsStddevFields';
  canvasVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: Maybe<Scalars['Float']['output']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item/ */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type FileItemsStddevPopFields = {
  __typename?: 'FileItemsStddevPopFields';
  canvasVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: Maybe<Scalars['Float']['output']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item/ */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type FileItemsStddevSampFields = {
  __typename?: 'FileItemsStddevSampFields';
  canvasVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: Maybe<Scalars['Float']['output']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item/ */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "file_items" */
export type FileItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: FileItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type FileItemsStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** URL pointing to the asset file */
  assetUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The parent canvas item */
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  canvasVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The content type of the file item. */
  contentType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The width of the item. Calculated async. */
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Sections in Figma are exported with a 40px trim. This flag is used to determine if the file item is a section so that the sync can place comments correctly. */
  isFigmaSection?: InputMaybe<Scalars['Boolean']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: InputMaybe<Scalars['Int']['input']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: InputMaybe<Scalars['Int']['input']>;
  /** The error reason of the file item processing, if applicable. */
  processingErrorReason?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the file item/ */
  processingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** Thumbnail presigned URL */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The width of the item. Calculated async. */
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type FileItemsSumFields = {
  __typename?: 'FileItemsSumFields';
  canvasVersion?: Maybe<Scalars['Int']['output']>;
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Int']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Int']['output']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: Maybe<Scalars['Int']['output']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: Maybe<Scalars['Int']['output']>;
  /** The processing status of the file item/ */
  processingStatus?: Maybe<Scalars['Int']['output']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "file_items" */
export enum FileItemsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  AssetUrl = 'assetUrl',
  /** column name */
  AssetUrlExpiresAt = 'assetUrlExpiresAt',
  /** column name */
  CanvasItemId = 'canvasItemId',
  /** column name */
  CanvasVersion = 'canvasVersion',
  /** column name */
  ContentType = 'contentType',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Height = 'height',
  /** column name */
  Id = 'id',
  /** column name */
  IsFigmaSection = 'isFigmaSection',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LockVersion = 'lockVersion',
  /** column name */
  PageWidth = 'pageWidth',
  /** column name */
  Pages = 'pages',
  /** column name */
  ProcessingErrorReason = 'processingErrorReason',
  /** column name */
  ProcessingStatus = 'processingStatus',
  /** column name */
  ThumbnailProcessingError = 'thumbnailProcessingError',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  ThumbnailUrl = 'thumbnailUrl',
  /** column name */
  ThumbnailUrlExpiresAt = 'thumbnailUrlExpiresAt',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Width = 'width'
}

export type FileItemsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<FileItemsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FileItemsSetInput>;
  /** filter the rows which have to be updated */
  where: FileItemsBoolExp;
};

/** aggregate varPop on columns */
export type FileItemsVarPopFields = {
  __typename?: 'FileItemsVarPopFields';
  canvasVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: Maybe<Scalars['Float']['output']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item/ */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type FileItemsVarSampFields = {
  __typename?: 'FileItemsVarSampFields';
  canvasVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: Maybe<Scalars['Float']['output']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item/ */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type FileItemsVarianceFields = {
  __typename?: 'FileItemsVarianceFields';
  canvasVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The width of the page in the file item if applicable. Calculated async. */
  pageWidth?: Maybe<Scalars['Float']['output']>;
  /** Number of pages in the file item if applicable. Calculated async. */
  pages?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item/ */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the file item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8ComparisonExp = {
  _eq?: InputMaybe<Scalars['float8']['input']>;
  _gt?: InputMaybe<Scalars['float8']['input']>;
  _gte?: InputMaybe<Scalars['float8']['input']>;
  _in?: InputMaybe<Array<Scalars['float8']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['float8']['input']>;
  _lte?: InputMaybe<Scalars['float8']['input']>;
  _neq?: InputMaybe<Scalars['float8']['input']>;
  _nin?: InputMaybe<Array<Scalars['float8']['input']>>;
};

export type FreeTrial = {
  __typename?: 'FreeTrial';
  discount?: Maybe<Discount>;
  endsAt: Scalars['String']['output'];
  numberOfUnlimitedAccountsLeft: Scalars['Int']['output'];
  seatPrices: Prices;
  storagePrices: Array<StoragePrice>;
};

export type GetDocumentPermissionsInput = {
  documentId: Scalars['uuid']['input'];
};

export type GetDocumentPermissionsOutput = {
  __typename?: 'GetDocumentPermissionsOutput';
  canAccessProject: Scalars['Boolean']['output'];
  canAddVersion: Scalars['Boolean']['output'];
  canArchive: Scalars['Boolean']['output'];
  canCreateScreenRecording: Scalars['Boolean']['output'];
  canDeleteVersion: Scalars['Boolean']['output'];
  canDuplicateTask: Scalars['Boolean']['output'];
  canEditDocument: Scalars['Boolean']['output'];
  canEditVersion: Scalars['Boolean']['output'];
  canShare: Scalars['Boolean']['output'];
  canSubscribeToTask: Scalars['Boolean']['output'];
  canWriteComment: Scalars['Boolean']['output'];
};

export type GetPresignedUrlForMultipartUploadInput = {
  bucket: Scalars['String']['input'];
  key: Scalars['String']['input'];
  partNumber: Scalars['Int']['input'];
  uploadId: Scalars['String']['input'];
};

export type GetPresignedUrlForMultipartUploadOutput = {
  __typename?: 'GetPresignedUrlForMultipartUploadOutput';
  signedUrl: Scalars['String']['output'];
};

/** Stores the current viewed status of the various tours */
export type GuidedTours = {
  __typename?: 'GuidedTours';
  createdAt: Scalars['timestamp']['output'];
  id: Scalars['uuid']['output'];
  /** Whether the user should see the default asset type tour */
  shouldSeeDefaultAssetTypeTour: Scalars['Boolean']['output'];
  /** Whether the user has seen the livesite tour */
  shouldSeeLivesiteTour: Scalars['Boolean']['output'];
  /** Whether the user has seen the onboarding tour */
  shouldSeeOnboardingTour: Scalars['Boolean']['output'];
  /** Whether the user has seen the project tour */
  shouldSeeProjectTour: Scalars['Boolean']['output'];
  /** Whether the user has seen the share link tour */
  shouldSeeShareLinkTour: Scalars['Boolean']['output'];
  updatedAt: Scalars['timestamp']['output'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid']['output'];
};

/** aggregated selection of "guided_tours" */
export type GuidedToursAggregate = {
  __typename?: 'GuidedToursAggregate';
  aggregate?: Maybe<GuidedToursAggregateFields>;
  nodes: Array<GuidedTours>;
};

/** aggregate fields of "guided_tours" */
export type GuidedToursAggregateFields = {
  __typename?: 'GuidedToursAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<GuidedToursMaxFields>;
  min?: Maybe<GuidedToursMinFields>;
};


/** aggregate fields of "guided_tours" */
export type GuidedToursAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GuidedToursSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "guided_tours". All fields are combined with a logical 'AND'. */
export type GuidedToursBoolExp = {
  _and?: InputMaybe<Array<GuidedToursBoolExp>>;
  _not?: InputMaybe<GuidedToursBoolExp>;
  _or?: InputMaybe<Array<GuidedToursBoolExp>>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  shouldSeeDefaultAssetTypeTour?: InputMaybe<BooleanComparisonExp>;
  shouldSeeLivesiteTour?: InputMaybe<BooleanComparisonExp>;
  shouldSeeOnboardingTour?: InputMaybe<BooleanComparisonExp>;
  shouldSeeProjectTour?: InputMaybe<BooleanComparisonExp>;
  shouldSeeShareLinkTour?: InputMaybe<BooleanComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "guided_tours" */
export enum GuidedToursConstraint {
  /** unique or primary key constraint on columns "id" */
  GuidedToursPkey = 'guided_tours_pkey',
  /** unique or primary key constraint on columns "user_id" */
  IndexGuidedToursOnUserId = 'index_guided_tours_on_user_id'
}

/** input type for inserting data into table "guided_tours" */
export type GuidedToursInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the user should see the default asset type tour */
  shouldSeeDefaultAssetTypeTour?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has seen the livesite tour */
  shouldSeeLivesiteTour?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has seen the onboarding tour */
  shouldSeeOnboardingTour?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has seen the project tour */
  shouldSeeProjectTour?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has seen the share link tour */
  shouldSeeShareLinkTour?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type GuidedToursMaxFields = {
  __typename?: 'GuidedToursMaxFields';
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type GuidedToursMinFields = {
  __typename?: 'GuidedToursMinFields';
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "guided_tours" */
export type GuidedToursMutationResponse = {
  __typename?: 'GuidedToursMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<GuidedTours>;
};

/** input type for inserting object relation for remote table "guided_tours" */
export type GuidedToursObjRelInsertInput = {
  data: GuidedToursInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<GuidedToursOnConflict>;
};

/** on_conflict condition type for table "guided_tours" */
export type GuidedToursOnConflict = {
  constraint: GuidedToursConstraint;
  updateColumns?: Array<GuidedToursUpdateColumn>;
  where?: InputMaybe<GuidedToursBoolExp>;
};

/** Ordering options when selecting data from "guided_tours". */
export type GuidedToursOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  shouldSeeDefaultAssetTypeTour?: InputMaybe<OrderBy>;
  shouldSeeLivesiteTour?: InputMaybe<OrderBy>;
  shouldSeeOnboardingTour?: InputMaybe<OrderBy>;
  shouldSeeProjectTour?: InputMaybe<OrderBy>;
  shouldSeeShareLinkTour?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: guided_tours */
export type GuidedToursPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "guided_tours" */
export enum GuidedToursSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  ShouldSeeDefaultAssetTypeTour = 'shouldSeeDefaultAssetTypeTour',
  /** column name */
  ShouldSeeLivesiteTour = 'shouldSeeLivesiteTour',
  /** column name */
  ShouldSeeOnboardingTour = 'shouldSeeOnboardingTour',
  /** column name */
  ShouldSeeProjectTour = 'shouldSeeProjectTour',
  /** column name */
  ShouldSeeShareLinkTour = 'shouldSeeShareLinkTour',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "guided_tours" */
export type GuidedToursSetInput = {
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the user should see the default asset type tour */
  shouldSeeDefaultAssetTypeTour?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has seen the livesite tour */
  shouldSeeLivesiteTour?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has seen the onboarding tour */
  shouldSeeOnboardingTour?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has seen the project tour */
  shouldSeeProjectTour?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has seen the share link tour */
  shouldSeeShareLinkTour?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "guided_tours" */
export type GuidedToursStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: GuidedToursStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GuidedToursStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the user should see the default asset type tour */
  shouldSeeDefaultAssetTypeTour?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has seen the livesite tour */
  shouldSeeLivesiteTour?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has seen the onboarding tour */
  shouldSeeOnboardingTour?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has seen the project tour */
  shouldSeeProjectTour?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has seen the share link tour */
  shouldSeeShareLinkTour?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "guided_tours" */
export enum GuidedToursUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  ShouldSeeDefaultAssetTypeTour = 'shouldSeeDefaultAssetTypeTour',
  /** column name */
  ShouldSeeLivesiteTour = 'shouldSeeLivesiteTour',
  /** column name */
  ShouldSeeOnboardingTour = 'shouldSeeOnboardingTour',
  /** column name */
  ShouldSeeProjectTour = 'shouldSeeProjectTour',
  /** column name */
  ShouldSeeShareLinkTour = 'shouldSeeShareLinkTour',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type GuidedToursUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GuidedToursSetInput>;
  /** filter the rows which have to be updated */
  where: GuidedToursBoolExp;
};

export type InitiateMultipartUploadOutput = {
  __typename?: 'InitiateMultipartUploadOutput';
  bucket: Scalars['String']['output'];
  key: Scalars['String']['output'];
  uploadId: Scalars['String']['output'];
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type IntComparisonExp = {
  _eq?: InputMaybe<Scalars['Int']['input']>;
  _gt?: InputMaybe<Scalars['Int']['input']>;
  _gte?: InputMaybe<Scalars['Int']['input']>;
  _in?: InputMaybe<Array<Scalars['Int']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Int']['input']>;
  _lte?: InputMaybe<Scalars['Int']['input']>;
  _neq?: InputMaybe<Scalars['Int']['input']>;
  _nin?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type InvoiceUrl = {
  __typename?: 'InvoiceUrl';
  url: Scalars['String']['output'];
};

/** [Displaying assets] - remove, replaced by new canvas_items system */
export type Items = {
  __typename?: 'Items';
  accountId?: Maybe<Scalars['uuid']['output']>;
  contentType?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['timestamp']['output'];
  figmaHash?: Maybe<Scalars['String']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: Maybe<Scalars['Int']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: Maybe<Scalars['Int']['output']>;
  figmaQuickHash?: Maybe<Scalars['String']['output']>;
  height?: Maybe<Scalars['Int']['output']>;
  id: Scalars['uuid']['output'];
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  pageWidth?: Maybe<Scalars['Int']['output']>;
  pages?: Maybe<Scalars['Int']['output']>;
  position: Scalars['Int']['output'];
  positionX?: Maybe<Scalars['Int']['output']>;
  positionY?: Maybe<Scalars['Int']['output']>;
  processingErrorReason?: Maybe<Scalars['String']['output']>;
  processingStatus: Scalars['Int']['output'];
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  thumbnailProcessingStatus: Scalars['Int']['output'];
  type?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['timestamp']['output'];
  url?: Maybe<Scalars['String']['output']>;
  versionId?: Maybe<Scalars['uuid']['output']>;
  width?: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "items" */
export type ItemsAggregate = {
  __typename?: 'ItemsAggregate';
  aggregate?: Maybe<ItemsAggregateFields>;
  nodes: Array<Items>;
};

export type ItemsAggregateBoolExp = {
  count?: InputMaybe<ItemsAggregateBoolExpCount>;
};

/** aggregate fields of "items" */
export type ItemsAggregateFields = {
  __typename?: 'ItemsAggregateFields';
  avg?: Maybe<ItemsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ItemsMaxFields>;
  min?: Maybe<ItemsMinFields>;
  stddev?: Maybe<ItemsStddevFields>;
  stddevPop?: Maybe<ItemsStddevPopFields>;
  stddevSamp?: Maybe<ItemsStddevSampFields>;
  sum?: Maybe<ItemsSumFields>;
  varPop?: Maybe<ItemsVarPopFields>;
  varSamp?: Maybe<ItemsVarSampFields>;
  variance?: Maybe<ItemsVarianceFields>;
};


/** aggregate fields of "items" */
export type ItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "items" */
export type ItemsAggregateOrderBy = {
  avg?: InputMaybe<ItemsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ItemsMaxOrderBy>;
  min?: InputMaybe<ItemsMinOrderBy>;
  stddev?: InputMaybe<ItemsStddevOrderBy>;
  stddevPop?: InputMaybe<ItemsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<ItemsStddevSampOrderBy>;
  sum?: InputMaybe<ItemsSumOrderBy>;
  varPop?: InputMaybe<ItemsVarPopOrderBy>;
  varSamp?: InputMaybe<ItemsVarSampOrderBy>;
  variance?: InputMaybe<ItemsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "items" */
export type ItemsArrRelInsertInput = {
  data: Array<ItemsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<ItemsOnConflict>;
};

/** aggregate avg on columns */
export type ItemsAvgFields = {
  __typename?: 'ItemsAvgFields';
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  pageWidth?: Maybe<Scalars['Float']['output']>;
  pages?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  positionX?: Maybe<Scalars['Float']['output']>;
  positionY?: Maybe<Scalars['Float']['output']>;
  processingStatus?: Maybe<Scalars['Float']['output']>;
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "items" */
export type ItemsAvgOrderBy = {
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  pageWidth?: InputMaybe<OrderBy>;
  pages?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  positionX?: InputMaybe<OrderBy>;
  positionY?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "items". All fields are combined with a logical 'AND'. */
export type ItemsBoolExp = {
  _and?: InputMaybe<Array<ItemsBoolExp>>;
  _not?: InputMaybe<ItemsBoolExp>;
  _or?: InputMaybe<Array<ItemsBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  contentType?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  figmaHash?: InputMaybe<StringComparisonExp>;
  figmaPositionX?: InputMaybe<IntComparisonExp>;
  figmaPositionY?: InputMaybe<IntComparisonExp>;
  figmaQuickHash?: InputMaybe<StringComparisonExp>;
  height?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  pageWidth?: InputMaybe<IntComparisonExp>;
  pages?: InputMaybe<IntComparisonExp>;
  position?: InputMaybe<IntComparisonExp>;
  positionX?: InputMaybe<IntComparisonExp>;
  positionY?: InputMaybe<IntComparisonExp>;
  processingErrorReason?: InputMaybe<StringComparisonExp>;
  processingStatus?: InputMaybe<IntComparisonExp>;
  thumbnailProcessingError?: InputMaybe<StringComparisonExp>;
  thumbnailProcessingStatus?: InputMaybe<IntComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  url?: InputMaybe<StringComparisonExp>;
  versionId?: InputMaybe<UuidComparisonExp>;
  width?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "items" */
export enum ItemsConstraint {
  /** unique or primary key constraint on columns "id" */
  ItemsPkey = 'items_pkey'
}

/** input type for incrementing numeric columns in table "items" */
export type ItemsIncInput = {
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<Scalars['Int']['input']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<Scalars['Int']['input']>;
  height?: InputMaybe<Scalars['Int']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  pageWidth?: InputMaybe<Scalars['Int']['input']>;
  pages?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  positionX?: InputMaybe<Scalars['Int']['input']>;
  positionY?: InputMaybe<Scalars['Int']['input']>;
  processingStatus?: InputMaybe<Scalars['Int']['input']>;
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "items" */
export type ItemsInsertInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  figmaHash?: InputMaybe<Scalars['String']['input']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<Scalars['Int']['input']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<Scalars['Int']['input']>;
  figmaQuickHash?: InputMaybe<Scalars['String']['input']>;
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  pageWidth?: InputMaybe<Scalars['Int']['input']>;
  pages?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  positionX?: InputMaybe<Scalars['Int']['input']>;
  positionY?: InputMaybe<Scalars['Int']['input']>;
  processingErrorReason?: InputMaybe<Scalars['String']['input']>;
  processingStatus?: InputMaybe<Scalars['Int']['input']>;
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  versionId?: InputMaybe<Scalars['uuid']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type ItemsMaxFields = {
  __typename?: 'ItemsMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  contentType?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  figmaHash?: Maybe<Scalars['String']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: Maybe<Scalars['Int']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: Maybe<Scalars['Int']['output']>;
  figmaQuickHash?: Maybe<Scalars['String']['output']>;
  height?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  pageWidth?: Maybe<Scalars['Int']['output']>;
  pages?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  positionX?: Maybe<Scalars['Int']['output']>;
  positionY?: Maybe<Scalars['Int']['output']>;
  processingErrorReason?: Maybe<Scalars['String']['output']>;
  processingStatus?: Maybe<Scalars['Int']['output']>;
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  url?: Maybe<Scalars['String']['output']>;
  versionId?: Maybe<Scalars['uuid']['output']>;
  width?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "items" */
export type ItemsMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  contentType?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  figmaHash?: InputMaybe<OrderBy>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<OrderBy>;
  figmaQuickHash?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  pageWidth?: InputMaybe<OrderBy>;
  pages?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  positionX?: InputMaybe<OrderBy>;
  positionY?: InputMaybe<OrderBy>;
  processingErrorReason?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  thumbnailProcessingError?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  versionId?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ItemsMinFields = {
  __typename?: 'ItemsMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  contentType?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  figmaHash?: Maybe<Scalars['String']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: Maybe<Scalars['Int']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: Maybe<Scalars['Int']['output']>;
  figmaQuickHash?: Maybe<Scalars['String']['output']>;
  height?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  pageWidth?: Maybe<Scalars['Int']['output']>;
  pages?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  positionX?: Maybe<Scalars['Int']['output']>;
  positionY?: Maybe<Scalars['Int']['output']>;
  processingErrorReason?: Maybe<Scalars['String']['output']>;
  processingStatus?: Maybe<Scalars['Int']['output']>;
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  url?: Maybe<Scalars['String']['output']>;
  versionId?: Maybe<Scalars['uuid']['output']>;
  width?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "items" */
export type ItemsMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  contentType?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  figmaHash?: InputMaybe<OrderBy>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<OrderBy>;
  figmaQuickHash?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  pageWidth?: InputMaybe<OrderBy>;
  pages?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  positionX?: InputMaybe<OrderBy>;
  positionY?: InputMaybe<OrderBy>;
  processingErrorReason?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  thumbnailProcessingError?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  versionId?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "items" */
export type ItemsMutationResponse = {
  __typename?: 'ItemsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Items>;
};

/** on_conflict condition type for table "items" */
export type ItemsOnConflict = {
  constraint: ItemsConstraint;
  updateColumns?: Array<ItemsUpdateColumn>;
  where?: InputMaybe<ItemsBoolExp>;
};

/** Ordering options when selecting data from "items". */
export type ItemsOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  contentType?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  figmaHash?: InputMaybe<OrderBy>;
  figmaPositionX?: InputMaybe<OrderBy>;
  figmaPositionY?: InputMaybe<OrderBy>;
  figmaQuickHash?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  pageWidth?: InputMaybe<OrderBy>;
  pages?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  positionX?: InputMaybe<OrderBy>;
  positionY?: InputMaybe<OrderBy>;
  processingErrorReason?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  thumbnailProcessingError?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
  versionId?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: items */
export type ItemsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "items" */
export enum ItemsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  ContentType = 'contentType',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FigmaHash = 'figmaHash',
  /** column name */
  FigmaPositionX = 'figmaPositionX',
  /** column name */
  FigmaPositionY = 'figmaPositionY',
  /** column name */
  FigmaQuickHash = 'figmaQuickHash',
  /** column name */
  Height = 'height',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  PageWidth = 'pageWidth',
  /** column name */
  Pages = 'pages',
  /** column name */
  Position = 'position',
  /** column name */
  PositionX = 'positionX',
  /** column name */
  PositionY = 'positionY',
  /** column name */
  ProcessingErrorReason = 'processingErrorReason',
  /** column name */
  ProcessingStatus = 'processingStatus',
  /** column name */
  ThumbnailProcessingError = 'thumbnailProcessingError',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Url = 'url',
  /** column name */
  VersionId = 'versionId',
  /** column name */
  Width = 'width'
}

/** input type for updating data in table "items" */
export type ItemsSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  figmaHash?: InputMaybe<Scalars['String']['input']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<Scalars['Int']['input']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<Scalars['Int']['input']>;
  figmaQuickHash?: InputMaybe<Scalars['String']['input']>;
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  pageWidth?: InputMaybe<Scalars['Int']['input']>;
  pages?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  positionX?: InputMaybe<Scalars['Int']['input']>;
  positionY?: InputMaybe<Scalars['Int']['input']>;
  processingErrorReason?: InputMaybe<Scalars['String']['input']>;
  processingStatus?: InputMaybe<Scalars['Int']['input']>;
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  versionId?: InputMaybe<Scalars['uuid']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type ItemsStddevFields = {
  __typename?: 'ItemsStddevFields';
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  pageWidth?: Maybe<Scalars['Float']['output']>;
  pages?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  positionX?: Maybe<Scalars['Float']['output']>;
  positionY?: Maybe<Scalars['Float']['output']>;
  processingStatus?: Maybe<Scalars['Float']['output']>;
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "items" */
export type ItemsStddevOrderBy = {
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  pageWidth?: InputMaybe<OrderBy>;
  pages?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  positionX?: InputMaybe<OrderBy>;
  positionY?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type ItemsStddevPopFields = {
  __typename?: 'ItemsStddevPopFields';
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  pageWidth?: Maybe<Scalars['Float']['output']>;
  pages?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  positionX?: Maybe<Scalars['Float']['output']>;
  positionY?: Maybe<Scalars['Float']['output']>;
  processingStatus?: Maybe<Scalars['Float']['output']>;
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "items" */
export type ItemsStddevPopOrderBy = {
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  pageWidth?: InputMaybe<OrderBy>;
  pages?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  positionX?: InputMaybe<OrderBy>;
  positionY?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type ItemsStddevSampFields = {
  __typename?: 'ItemsStddevSampFields';
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  pageWidth?: Maybe<Scalars['Float']['output']>;
  pages?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  positionX?: Maybe<Scalars['Float']['output']>;
  positionY?: Maybe<Scalars['Float']['output']>;
  processingStatus?: Maybe<Scalars['Float']['output']>;
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "items" */
export type ItemsStddevSampOrderBy = {
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  pageWidth?: InputMaybe<OrderBy>;
  pages?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  positionX?: InputMaybe<OrderBy>;
  positionY?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "items" */
export type ItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ItemsStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  figmaHash?: InputMaybe<Scalars['String']['input']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<Scalars['Int']['input']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<Scalars['Int']['input']>;
  figmaQuickHash?: InputMaybe<Scalars['String']['input']>;
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  pageWidth?: InputMaybe<Scalars['Int']['input']>;
  pages?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  positionX?: InputMaybe<Scalars['Int']['input']>;
  positionY?: InputMaybe<Scalars['Int']['input']>;
  processingErrorReason?: InputMaybe<Scalars['String']['input']>;
  processingStatus?: InputMaybe<Scalars['Int']['input']>;
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  versionId?: InputMaybe<Scalars['uuid']['input']>;
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type ItemsSumFields = {
  __typename?: 'ItemsSumFields';
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: Maybe<Scalars['Int']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: Maybe<Scalars['Int']['output']>;
  height?: Maybe<Scalars['Int']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  pageWidth?: Maybe<Scalars['Int']['output']>;
  pages?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  positionX?: Maybe<Scalars['Int']['output']>;
  positionY?: Maybe<Scalars['Int']['output']>;
  processingStatus?: Maybe<Scalars['Int']['output']>;
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  width?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "items" */
export type ItemsSumOrderBy = {
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  pageWidth?: InputMaybe<OrderBy>;
  pages?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  positionX?: InputMaybe<OrderBy>;
  positionY?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
};

/** update columns of table "items" */
export enum ItemsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  ContentType = 'contentType',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FigmaHash = 'figmaHash',
  /** column name */
  FigmaPositionX = 'figmaPositionX',
  /** column name */
  FigmaPositionY = 'figmaPositionY',
  /** column name */
  FigmaQuickHash = 'figmaQuickHash',
  /** column name */
  Height = 'height',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  PageWidth = 'pageWidth',
  /** column name */
  Pages = 'pages',
  /** column name */
  Position = 'position',
  /** column name */
  PositionX = 'positionX',
  /** column name */
  PositionY = 'positionY',
  /** column name */
  ProcessingErrorReason = 'processingErrorReason',
  /** column name */
  ProcessingStatus = 'processingStatus',
  /** column name */
  ThumbnailProcessingError = 'thumbnailProcessingError',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Url = 'url',
  /** column name */
  VersionId = 'versionId',
  /** column name */
  Width = 'width'
}

export type ItemsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ItemsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ItemsSetInput>;
  /** filter the rows which have to be updated */
  where: ItemsBoolExp;
};

/** aggregate varPop on columns */
export type ItemsVarPopFields = {
  __typename?: 'ItemsVarPopFields';
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  pageWidth?: Maybe<Scalars['Float']['output']>;
  pages?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  positionX?: Maybe<Scalars['Float']['output']>;
  positionY?: Maybe<Scalars['Float']['output']>;
  processingStatus?: Maybe<Scalars['Float']['output']>;
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "items" */
export type ItemsVarPopOrderBy = {
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  pageWidth?: InputMaybe<OrderBy>;
  pages?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  positionX?: InputMaybe<OrderBy>;
  positionY?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type ItemsVarSampFields = {
  __typename?: 'ItemsVarSampFields';
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  pageWidth?: Maybe<Scalars['Float']['output']>;
  pages?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  positionX?: Maybe<Scalars['Float']['output']>;
  positionY?: Maybe<Scalars['Float']['output']>;
  processingStatus?: Maybe<Scalars['Float']['output']>;
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "items" */
export type ItemsVarSampOrderBy = {
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  pageWidth?: InputMaybe<OrderBy>;
  pages?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  positionX?: InputMaybe<OrderBy>;
  positionY?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ItemsVarianceFields = {
  __typename?: 'ItemsVarianceFields';
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: Maybe<Scalars['Float']['output']>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: Maybe<Scalars['Float']['output']>;
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  pageWidth?: Maybe<Scalars['Float']['output']>;
  pages?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  positionX?: Maybe<Scalars['Float']['output']>;
  positionY?: Maybe<Scalars['Float']['output']>;
  processingStatus?: Maybe<Scalars['Float']['output']>;
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  width?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "items" */
export type ItemsVarianceOrderBy = {
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionX?: InputMaybe<OrderBy>;
  /** This column ensures backwards compatibility for Canvas v1 vs v2, and is not to be used generally. When migrating from Canvas v1 to v2, some of the messages would become incorrectly positioned on any Figma work which was imported from the plugin. This column saves the original Figma position of file_items for which on-asset comments would be incorrectly positioned, and where we have had to reset the position of the file_items to ensure comments line up before and after the switch. Can be decommissioned by the end of 2025. */
  figmaPositionY?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  pageWidth?: InputMaybe<OrderBy>;
  pages?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  positionX?: InputMaybe<OrderBy>;
  positionY?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
};

/** Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'. */
export type JsonComparisonExp = {
  _eq?: InputMaybe<Scalars['json']['input']>;
  _gt?: InputMaybe<Scalars['json']['input']>;
  _gte?: InputMaybe<Scalars['json']['input']>;
  _in?: InputMaybe<Array<Scalars['json']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['json']['input']>;
  _lte?: InputMaybe<Scalars['json']['input']>;
  _neq?: InputMaybe<Scalars['json']['input']>;
  _nin?: InputMaybe<Array<Scalars['json']['input']>>;
};

export type JsonbCastExp = {
  String?: InputMaybe<StringComparisonExp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type JsonbComparisonExp = {
  _cast?: InputMaybe<JsonbCastExp>;
  /** is the column contained in the given json value */
  _containedIn?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars['jsonb']['input']>;
  _eq?: InputMaybe<Scalars['jsonb']['input']>;
  _gt?: InputMaybe<Scalars['jsonb']['input']>;
  _gte?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the string exist as a top-level key in the column */
  _hasKey?: InputMaybe<Scalars['String']['input']>;
  /** do all of these strings exist as top-level keys in the column */
  _hasKeysAll?: InputMaybe<Array<Scalars['String']['input']>>;
  /** do any of these strings exist as top-level keys in the column */
  _hasKeysAny?: InputMaybe<Array<Scalars['String']['input']>>;
  _in?: InputMaybe<Array<Scalars['jsonb']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['jsonb']['input']>;
  _lte?: InputMaybe<Scalars['jsonb']['input']>;
  _neq?: InputMaybe<Scalars['jsonb']['input']>;
  _nin?: InputMaybe<Array<Scalars['jsonb']['input']>>;
};

/** The labels that have been created within a given account. Labels are used by users to tag documents */
export type Labels = {
  __typename?: 'Labels';
  accountId: Scalars['uuid']['output'];
  color: Scalars['String']['output'];
  createdAt: Scalars['timestamp']['output'];
  /** An array relationship */
  documentLabels: Array<DocumentLabels>;
  /** An aggregate relationship */
  documentLabelsAggregate: DocumentLabelsAggregate;
  id: Scalars['uuid']['output'];
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  name: Scalars['String']['output'];
  updatedAt: Scalars['timestamp']['output'];
};


/** The labels that have been created within a given account. Labels are used by users to tag documents */
export type LabelsDocumentLabelsArgs = {
  distinctOn?: InputMaybe<Array<DocumentLabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentLabelsOrderBy>>;
  where?: InputMaybe<DocumentLabelsBoolExp>;
};


/** The labels that have been created within a given account. Labels are used by users to tag documents */
export type LabelsDocumentLabelsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentLabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentLabelsOrderBy>>;
  where?: InputMaybe<DocumentLabelsBoolExp>;
};

/** aggregated selection of "labels" */
export type LabelsAggregate = {
  __typename?: 'LabelsAggregate';
  aggregate?: Maybe<LabelsAggregateFields>;
  nodes: Array<Labels>;
};

export type LabelsAggregateBoolExp = {
  count?: InputMaybe<LabelsAggregateBoolExpCount>;
};

/** aggregate fields of "labels" */
export type LabelsAggregateFields = {
  __typename?: 'LabelsAggregateFields';
  avg?: Maybe<LabelsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<LabelsMaxFields>;
  min?: Maybe<LabelsMinFields>;
  stddev?: Maybe<LabelsStddevFields>;
  stddevPop?: Maybe<LabelsStddevPopFields>;
  stddevSamp?: Maybe<LabelsStddevSampFields>;
  sum?: Maybe<LabelsSumFields>;
  varPop?: Maybe<LabelsVarPopFields>;
  varSamp?: Maybe<LabelsVarSampFields>;
  variance?: Maybe<LabelsVarianceFields>;
};


/** aggregate fields of "labels" */
export type LabelsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LabelsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "labels" */
export type LabelsAggregateOrderBy = {
  avg?: InputMaybe<LabelsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LabelsMaxOrderBy>;
  min?: InputMaybe<LabelsMinOrderBy>;
  stddev?: InputMaybe<LabelsStddevOrderBy>;
  stddevPop?: InputMaybe<LabelsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<LabelsStddevSampOrderBy>;
  sum?: InputMaybe<LabelsSumOrderBy>;
  varPop?: InputMaybe<LabelsVarPopOrderBy>;
  varSamp?: InputMaybe<LabelsVarSampOrderBy>;
  variance?: InputMaybe<LabelsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "labels" */
export type LabelsArrRelInsertInput = {
  data: Array<LabelsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LabelsOnConflict>;
};

/** aggregate avg on columns */
export type LabelsAvgFields = {
  __typename?: 'LabelsAvgFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "labels" */
export type LabelsAvgOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "labels". All fields are combined with a logical 'AND'. */
export type LabelsBoolExp = {
  _and?: InputMaybe<Array<LabelsBoolExp>>;
  _not?: InputMaybe<LabelsBoolExp>;
  _or?: InputMaybe<Array<LabelsBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  color?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  documentLabels?: InputMaybe<DocumentLabelsBoolExp>;
  documentLabelsAggregate?: InputMaybe<DocumentLabelsAggregateBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
};

/** unique or primary key constraints on table "labels" */
export enum LabelsConstraint {
  /** unique or primary key constraint on columns "id" */
  LabelsPkey = 'labels_pkey'
}

/** input type for incrementing numeric columns in table "labels" */
export type LabelsIncInput = {
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "labels" */
export type LabelsInsertInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  color?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  documentLabels?: InputMaybe<DocumentLabelsArrRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate max on columns */
export type LabelsMaxFields = {
  __typename?: 'LabelsMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  color?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by max() on columns of table "labels" */
export type LabelsMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  color?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LabelsMinFields = {
  __typename?: 'LabelsMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  color?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by min() on columns of table "labels" */
export type LabelsMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  color?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "labels" */
export type LabelsMutationResponse = {
  __typename?: 'LabelsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Labels>;
};

/** input type for inserting object relation for remote table "labels" */
export type LabelsObjRelInsertInput = {
  data: LabelsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<LabelsOnConflict>;
};

/** on_conflict condition type for table "labels" */
export type LabelsOnConflict = {
  constraint: LabelsConstraint;
  updateColumns?: Array<LabelsUpdateColumn>;
  where?: InputMaybe<LabelsBoolExp>;
};

/** Ordering options when selecting data from "labels". */
export type LabelsOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  color?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  documentLabelsAggregate?: InputMaybe<DocumentLabelsAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: labels */
export type LabelsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "labels" */
export enum LabelsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  Color = 'color',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "labels" */
export type LabelsSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  color?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate stddev on columns */
export type LabelsStddevFields = {
  __typename?: 'LabelsStddevFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "labels" */
export type LabelsStddevOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type LabelsStddevPopFields = {
  __typename?: 'LabelsStddevPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "labels" */
export type LabelsStddevPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type LabelsStddevSampFields = {
  __typename?: 'LabelsStddevSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "labels" */
export type LabelsStddevSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "labels" */
export type LabelsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LabelsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LabelsStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  color?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate sum on columns */
export type LabelsSumFields = {
  __typename?: 'LabelsSumFields';
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "labels" */
export type LabelsSumOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** update columns of table "labels" */
export enum LabelsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  Color = 'color',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type LabelsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LabelsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LabelsSetInput>;
  /** filter the rows which have to be updated */
  where: LabelsBoolExp;
};

/** aggregate varPop on columns */
export type LabelsVarPopFields = {
  __typename?: 'LabelsVarPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "labels" */
export type LabelsVarPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type LabelsVarSampFields = {
  __typename?: 'LabelsVarSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "labels" */
export type LabelsVarSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type LabelsVarianceFields = {
  __typename?: 'LabelsVarianceFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "labels" */
export type LabelsVarianceOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** The stages (columns) on the kanban board. On a given task, this is called the Status for the task. Currently we have taken a Linear-style opinionated stance that all projects in an account have the same lanes, which allows teams to start new projects quickly with sensible defaults, and allows teams to see an overview across all of their projects. In the future we will likely make this more flexible on a per-project basis */
export type Lanes = {
  __typename?: 'Lanes';
  /** An object relationship */
  account: Accounts;
  accountId: Scalars['uuid']['output'];
  /** the last column, typically called Done, can be minimimised or explanded to show all tasks */
  columnCollapsed?: Maybe<Scalars['Boolean']['output']>;
  createdAt: Scalars['timestamp']['output'];
  /** An array relationship */
  documents: Array<Documents>;
  /** An aggregate relationship */
  documentsAggregate: DocumentsAggregate;
  id: Scalars['uuid']['output'];
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** order of the lane on the kanban board */
  position: Scalars['Int']['output'];
  /** the last column, typically called Done, does not sent reminder notifications for due dates */
  skipDueDateReminders?: Maybe<Scalars['Boolean']['output']>;
  updatedAt: Scalars['timestamp']['output'];
};


/** The stages (columns) on the kanban board. On a given task, this is called the Status for the task. Currently we have taken a Linear-style opinionated stance that all projects in an account have the same lanes, which allows teams to start new projects quickly with sensible defaults, and allows teams to see an overview across all of their projects. In the future we will likely make this more flexible on a per-project basis */
export type LanesDocumentsArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


/** The stages (columns) on the kanban board. On a given task, this is called the Status for the task. Currently we have taken a Linear-style opinionated stance that all projects in an account have the same lanes, which allows teams to start new projects quickly with sensible defaults, and allows teams to see an overview across all of their projects. In the future we will likely make this more flexible on a per-project basis */
export type LanesDocumentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};

/** aggregated selection of "lanes" */
export type LanesAggregate = {
  __typename?: 'LanesAggregate';
  aggregate?: Maybe<LanesAggregateFields>;
  nodes: Array<Lanes>;
};

export type LanesAggregateBoolExp = {
  bool_and?: InputMaybe<LanesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<LanesAggregateBoolExpBool_Or>;
  count?: InputMaybe<LanesAggregateBoolExpCount>;
};

/** aggregate fields of "lanes" */
export type LanesAggregateFields = {
  __typename?: 'LanesAggregateFields';
  avg?: Maybe<LanesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<LanesMaxFields>;
  min?: Maybe<LanesMinFields>;
  stddev?: Maybe<LanesStddevFields>;
  stddevPop?: Maybe<LanesStddevPopFields>;
  stddevSamp?: Maybe<LanesStddevSampFields>;
  sum?: Maybe<LanesSumFields>;
  varPop?: Maybe<LanesVarPopFields>;
  varSamp?: Maybe<LanesVarSampFields>;
  variance?: Maybe<LanesVarianceFields>;
};


/** aggregate fields of "lanes" */
export type LanesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LanesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "lanes" */
export type LanesAggregateOrderBy = {
  avg?: InputMaybe<LanesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LanesMaxOrderBy>;
  min?: InputMaybe<LanesMinOrderBy>;
  stddev?: InputMaybe<LanesStddevOrderBy>;
  stddevPop?: InputMaybe<LanesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<LanesStddevSampOrderBy>;
  sum?: InputMaybe<LanesSumOrderBy>;
  varPop?: InputMaybe<LanesVarPopOrderBy>;
  varSamp?: InputMaybe<LanesVarSampOrderBy>;
  variance?: InputMaybe<LanesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "lanes" */
export type LanesArrRelInsertInput = {
  data: Array<LanesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LanesOnConflict>;
};

/** aggregate avg on columns */
export type LanesAvgFields = {
  __typename?: 'LanesAvgFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** order of the lane on the kanban board */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "lanes" */
export type LanesAvgOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "lanes". All fields are combined with a logical 'AND'. */
export type LanesBoolExp = {
  _and?: InputMaybe<Array<LanesBoolExp>>;
  _not?: InputMaybe<LanesBoolExp>;
  _or?: InputMaybe<Array<LanesBoolExp>>;
  account?: InputMaybe<AccountsBoolExp>;
  accountId?: InputMaybe<UuidComparisonExp>;
  columnCollapsed?: InputMaybe<BooleanComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  documents?: InputMaybe<DocumentsBoolExp>;
  documentsAggregate?: InputMaybe<DocumentsAggregateBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  position?: InputMaybe<IntComparisonExp>;
  skipDueDateReminders?: InputMaybe<BooleanComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
};

/** unique or primary key constraints on table "lanes" */
export enum LanesConstraint {
  /** unique or primary key constraint on columns "id" */
  LanesPkey = 'lanes_pkey'
}

/** input type for incrementing numeric columns in table "lanes" */
export type LanesIncInput = {
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "lanes" */
export type LanesInsertInput = {
  account?: InputMaybe<AccountsObjRelInsertInput>;
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** the last column, typically called Done, can be minimimised or explanded to show all tasks */
  columnCollapsed?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  documents?: InputMaybe<DocumentsArrRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** the last column, typically called Done, does not sent reminder notifications for due dates */
  skipDueDateReminders?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate max on columns */
export type LanesMaxFields = {
  __typename?: 'LanesMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** order of the lane on the kanban board */
  position?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by max() on columns of table "lanes" */
export type LanesMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LanesMinFields = {
  __typename?: 'LanesMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** order of the lane on the kanban board */
  position?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by min() on columns of table "lanes" */
export type LanesMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "lanes" */
export type LanesMutationResponse = {
  __typename?: 'LanesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Lanes>;
};

/** input type for inserting object relation for remote table "lanes" */
export type LanesObjRelInsertInput = {
  data: LanesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<LanesOnConflict>;
};

/** on_conflict condition type for table "lanes" */
export type LanesOnConflict = {
  constraint: LanesConstraint;
  updateColumns?: Array<LanesUpdateColumn>;
  where?: InputMaybe<LanesBoolExp>;
};

/** Ordering options when selecting data from "lanes". */
export type LanesOrderBy = {
  account?: InputMaybe<AccountsOrderBy>;
  accountId?: InputMaybe<OrderBy>;
  columnCollapsed?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  documentsAggregate?: InputMaybe<DocumentsAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  skipDueDateReminders?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: lanes */
export type LanesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "lanes" */
export enum LanesSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  ColumnCollapsed = 'columnCollapsed',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  SkipDueDateReminders = 'skipDueDateReminders',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "lanesAggregateBoolExpBool_andArgumentsColumns" columns of table "lanes" */
export enum LanesSelectColumnLanesAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  ColumnCollapsed = 'columnCollapsed',
  /** column name */
  SkipDueDateReminders = 'skipDueDateReminders'
}

/** select "lanesAggregateBoolExpBool_orArgumentsColumns" columns of table "lanes" */
export enum LanesSelectColumnLanesAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  ColumnCollapsed = 'columnCollapsed',
  /** column name */
  SkipDueDateReminders = 'skipDueDateReminders'
}

/** input type for updating data in table "lanes" */
export type LanesSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** the last column, typically called Done, can be minimimised or explanded to show all tasks */
  columnCollapsed?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** the last column, typically called Done, does not sent reminder notifications for due dates */
  skipDueDateReminders?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate stddev on columns */
export type LanesStddevFields = {
  __typename?: 'LanesStddevFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** order of the lane on the kanban board */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "lanes" */
export type LanesStddevOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type LanesStddevPopFields = {
  __typename?: 'LanesStddevPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** order of the lane on the kanban board */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "lanes" */
export type LanesStddevPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type LanesStddevSampFields = {
  __typename?: 'LanesStddevSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** order of the lane on the kanban board */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "lanes" */
export type LanesStddevSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "lanes" */
export type LanesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LanesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LanesStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** the last column, typically called Done, can be minimimised or explanded to show all tasks */
  columnCollapsed?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<Scalars['Int']['input']>;
  /** the last column, typically called Done, does not sent reminder notifications for due dates */
  skipDueDateReminders?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate sum on columns */
export type LanesSumFields = {
  __typename?: 'LanesSumFields';
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** order of the lane on the kanban board */
  position?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "lanes" */
export type LanesSumOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<OrderBy>;
};

/** update columns of table "lanes" */
export enum LanesUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  ColumnCollapsed = 'columnCollapsed',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  SkipDueDateReminders = 'skipDueDateReminders',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type LanesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LanesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LanesSetInput>;
  /** filter the rows which have to be updated */
  where: LanesBoolExp;
};

/** aggregate varPop on columns */
export type LanesVarPopFields = {
  __typename?: 'LanesVarPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** order of the lane on the kanban board */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "lanes" */
export type LanesVarPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type LanesVarSampFields = {
  __typename?: 'LanesVarSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** order of the lane on the kanban board */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "lanes" */
export type LanesVarSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type LanesVarianceFields = {
  __typename?: 'LanesVarianceFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** order of the lane on the kanban board */
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "lanes" */
export type LanesVarianceOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** order of the lane on the kanban board */
  position?: InputMaybe<OrderBy>;
};

export type LiveSitescreenshotInput = {
  messageId: Scalars['String']['input'];
  pageEvents: Array<PageEvent>;
  scroll: Scroll;
  url: Scalars['String']['input'];
  viewport: Viewport;
};

/** @tagging a user creates a mention for that user and sends them a notification */
export type Mentions = {
  __typename?: 'Mentions';
  createdAt: Scalars['timestamp']['output'];
  /** An object relationship */
  document?: Maybe<Documents>;
  id: Scalars['uuid']['output'];
  mentionableDocumentId?: Maybe<Scalars['uuid']['output']>;
  /** ID of the object that the the mention happened on */
  mentionableId?: Maybe<Scalars['uuid']['output']>;
  mentionableMessageId?: Maybe<Scalars['uuid']['output']>;
  /** The object type that the mention happened on, e.g. Message, Document (if in briefing), Project (if in briefing) and so on */
  mentionableType?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  message?: Maybe<Messages>;
  updatedAt: Scalars['timestamp']['output'];
  /** An object relationship */
  user: Users;
  /** user mentioned */
  userId: Scalars['uuid']['output'];
};

/** aggregated selection of "mentions" */
export type MentionsAggregate = {
  __typename?: 'MentionsAggregate';
  aggregate?: Maybe<MentionsAggregateFields>;
  nodes: Array<Mentions>;
};

/** aggregate fields of "mentions" */
export type MentionsAggregateFields = {
  __typename?: 'MentionsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<MentionsMaxFields>;
  min?: Maybe<MentionsMinFields>;
};


/** aggregate fields of "mentions" */
export type MentionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MentionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "mentions". All fields are combined with a logical 'AND'. */
export type MentionsBoolExp = {
  _and?: InputMaybe<Array<MentionsBoolExp>>;
  _not?: InputMaybe<MentionsBoolExp>;
  _or?: InputMaybe<Array<MentionsBoolExp>>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  document?: InputMaybe<DocumentsBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  mentionableDocumentId?: InputMaybe<UuidComparisonExp>;
  mentionableId?: InputMaybe<UuidComparisonExp>;
  mentionableMessageId?: InputMaybe<UuidComparisonExp>;
  mentionableType?: InputMaybe<StringComparisonExp>;
  message?: InputMaybe<MessagesBoolExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "mentions" */
export enum MentionsConstraint {
  /** unique or primary key constraint on columns "id" */
  MentionsPkey = 'mentions_pkey'
}

/** input type for inserting data into table "mentions" */
export type MentionsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  document?: InputMaybe<DocumentsObjRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  mentionableDocumentId?: InputMaybe<Scalars['uuid']['input']>;
  /** ID of the object that the the mention happened on */
  mentionableId?: InputMaybe<Scalars['uuid']['input']>;
  mentionableMessageId?: InputMaybe<Scalars['uuid']['input']>;
  /** The object type that the mention happened on, e.g. Message, Document (if in briefing), Project (if in briefing) and so on */
  mentionableType?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<MessagesObjRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  /** user mentioned */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type MentionsMaxFields = {
  __typename?: 'MentionsMaxFields';
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  mentionableDocumentId?: Maybe<Scalars['uuid']['output']>;
  /** ID of the object that the the mention happened on */
  mentionableId?: Maybe<Scalars['uuid']['output']>;
  mentionableMessageId?: Maybe<Scalars['uuid']['output']>;
  /** The object type that the mention happened on, e.g. Message, Document (if in briefing), Project (if in briefing) and so on */
  mentionableType?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** user mentioned */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type MentionsMinFields = {
  __typename?: 'MentionsMinFields';
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  mentionableDocumentId?: Maybe<Scalars['uuid']['output']>;
  /** ID of the object that the the mention happened on */
  mentionableId?: Maybe<Scalars['uuid']['output']>;
  mentionableMessageId?: Maybe<Scalars['uuid']['output']>;
  /** The object type that the mention happened on, e.g. Message, Document (if in briefing), Project (if in briefing) and so on */
  mentionableType?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** user mentioned */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "mentions" */
export type MentionsMutationResponse = {
  __typename?: 'MentionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Mentions>;
};

/** input type for inserting object relation for remote table "mentions" */
export type MentionsObjRelInsertInput = {
  data: MentionsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<MentionsOnConflict>;
};

/** on_conflict condition type for table "mentions" */
export type MentionsOnConflict = {
  constraint: MentionsConstraint;
  updateColumns?: Array<MentionsUpdateColumn>;
  where?: InputMaybe<MentionsBoolExp>;
};

/** Ordering options when selecting data from "mentions". */
export type MentionsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  document?: InputMaybe<DocumentsOrderBy>;
  id?: InputMaybe<OrderBy>;
  mentionableDocumentId?: InputMaybe<OrderBy>;
  mentionableId?: InputMaybe<OrderBy>;
  mentionableMessageId?: InputMaybe<OrderBy>;
  mentionableType?: InputMaybe<OrderBy>;
  message?: InputMaybe<MessagesOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: mentions */
export type MentionsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "mentions" */
export enum MentionsSelectColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  MentionableDocumentId = 'mentionableDocumentId',
  /** column name */
  MentionableId = 'mentionableId',
  /** column name */
  MentionableMessageId = 'mentionableMessageId',
  /** column name */
  MentionableType = 'mentionableType',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "mentions" */
export type MentionsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  mentionableDocumentId?: InputMaybe<Scalars['uuid']['input']>;
  /** ID of the object that the the mention happened on */
  mentionableId?: InputMaybe<Scalars['uuid']['input']>;
  mentionableMessageId?: InputMaybe<Scalars['uuid']['input']>;
  /** The object type that the mention happened on, e.g. Message, Document (if in briefing), Project (if in briefing) and so on */
  mentionableType?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** user mentioned */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "mentions" */
export type MentionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: MentionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MentionsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  mentionableDocumentId?: InputMaybe<Scalars['uuid']['input']>;
  /** ID of the object that the the mention happened on */
  mentionableId?: InputMaybe<Scalars['uuid']['input']>;
  mentionableMessageId?: InputMaybe<Scalars['uuid']['input']>;
  /** The object type that the mention happened on, e.g. Message, Document (if in briefing), Project (if in briefing) and so on */
  mentionableType?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** user mentioned */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "mentions" */
export enum MentionsUpdateColumn {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  MentionableDocumentId = 'mentionableDocumentId',
  /** column name */
  MentionableId = 'mentionableId',
  /** column name */
  MentionableMessageId = 'mentionableMessageId',
  /** column name */
  MentionableType = 'mentionableType',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type MentionsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MentionsSetInput>;
  /** filter the rows which have to be updated */
  where: MentionsBoolExp;
};

/** When a file is attached or pasted into a message, it is stored as a message file */
export type MessageFiles = {
  __typename?: 'MessageFiles';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** URL pointing to the full resolution asset (image, video, etc.) */
  assetUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  createdAt: Scalars['timestamp']['output'];
  id: Scalars['uuid']['output'];
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  message?: Maybe<Messages>;
  /** The message that the file belongs to */
  messageId?: Maybe<Scalars['uuid']['output']>;
  /** name of the file - used if file is downloaded */
  name: Scalars['String']['output'];
  /** files are processed to give them optimised thumbnails. this column tracks if there was an error during processing (e.g. invalid upload) */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus: Scalars['Int']['output'];
  /** URL for a smaller preview/thumbnail version of the asset */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  updatedAt: Scalars['timestamp']['output'];
};

/** aggregated selection of "message_files" */
export type MessageFilesAggregate = {
  __typename?: 'MessageFilesAggregate';
  aggregate?: Maybe<MessageFilesAggregateFields>;
  nodes: Array<MessageFiles>;
};

export type MessageFilesAggregateBoolExp = {
  count?: InputMaybe<MessageFilesAggregateBoolExpCount>;
};

/** aggregate fields of "message_files" */
export type MessageFilesAggregateFields = {
  __typename?: 'MessageFilesAggregateFields';
  avg?: Maybe<MessageFilesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<MessageFilesMaxFields>;
  min?: Maybe<MessageFilesMinFields>;
  stddev?: Maybe<MessageFilesStddevFields>;
  stddevPop?: Maybe<MessageFilesStddevPopFields>;
  stddevSamp?: Maybe<MessageFilesStddevSampFields>;
  sum?: Maybe<MessageFilesSumFields>;
  varPop?: Maybe<MessageFilesVarPopFields>;
  varSamp?: Maybe<MessageFilesVarSampFields>;
  variance?: Maybe<MessageFilesVarianceFields>;
};


/** aggregate fields of "message_files" */
export type MessageFilesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MessageFilesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "message_files" */
export type MessageFilesAggregateOrderBy = {
  avg?: InputMaybe<MessageFilesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<MessageFilesMaxOrderBy>;
  min?: InputMaybe<MessageFilesMinOrderBy>;
  stddev?: InputMaybe<MessageFilesStddevOrderBy>;
  stddevPop?: InputMaybe<MessageFilesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<MessageFilesStddevSampOrderBy>;
  sum?: InputMaybe<MessageFilesSumOrderBy>;
  varPop?: InputMaybe<MessageFilesVarPopOrderBy>;
  varSamp?: InputMaybe<MessageFilesVarSampOrderBy>;
  variance?: InputMaybe<MessageFilesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "message_files" */
export type MessageFilesArrRelInsertInput = {
  data: Array<MessageFilesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<MessageFilesOnConflict>;
};

/** aggregate avg on columns */
export type MessageFilesAvgFields = {
  __typename?: 'MessageFilesAvgFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "message_files" */
export type MessageFilesAvgOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "message_files". All fields are combined with a logical 'AND'. */
export type MessageFilesBoolExp = {
  _and?: InputMaybe<Array<MessageFilesBoolExp>>;
  _not?: InputMaybe<MessageFilesBoolExp>;
  _or?: InputMaybe<Array<MessageFilesBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  assetUrl?: InputMaybe<StringComparisonExp>;
  assetUrlExpiresAt?: InputMaybe<TimestampComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  message?: InputMaybe<MessagesBoolExp>;
  messageId?: InputMaybe<UuidComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  thumbnailProcessingError?: InputMaybe<StringComparisonExp>;
  thumbnailProcessingStatus?: InputMaybe<IntComparisonExp>;
  thumbnailUrl?: InputMaybe<StringComparisonExp>;
  thumbnailUrlExpiresAt?: InputMaybe<TimestampComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
};

/** unique or primary key constraints on table "message_files" */
export enum MessageFilesConstraint {
  /** unique or primary key constraint on columns "id" */
  MessageFilesPkey = 'message_files_pkey'
}

/** input type for incrementing numeric columns in table "message_files" */
export type MessageFilesIncInput = {
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "message_files" */
export type MessageFilesInsertInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** URL pointing to the full resolution asset (image, video, etc.) */
  assetUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  message?: InputMaybe<MessagesObjRelInsertInput>;
  /** The message that the file belongs to */
  messageId?: InputMaybe<Scalars['uuid']['input']>;
  /** name of the file - used if file is downloaded */
  name?: InputMaybe<Scalars['String']['input']>;
  /** files are processed to give them optimised thumbnails. this column tracks if there was an error during processing (e.g. invalid upload) */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** URL for a smaller preview/thumbnail version of the asset */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate max on columns */
export type MessageFilesMaxFields = {
  __typename?: 'MessageFilesMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** URL pointing to the full resolution asset (image, video, etc.) */
  assetUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** The message that the file belongs to */
  messageId?: Maybe<Scalars['uuid']['output']>;
  /** name of the file - used if file is downloaded */
  name?: Maybe<Scalars['String']['output']>;
  /** files are processed to give them optimised thumbnails. this column tracks if there was an error during processing (e.g. invalid upload) */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** URL for a smaller preview/thumbnail version of the asset */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by max() on columns of table "message_files" */
export type MessageFilesMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** URL pointing to the full resolution asset (image, video, etc.) */
  assetUrl?: InputMaybe<OrderBy>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The message that the file belongs to */
  messageId?: InputMaybe<OrderBy>;
  /** name of the file - used if file is downloaded */
  name?: InputMaybe<OrderBy>;
  /** files are processed to give them optimised thumbnails. this column tracks if there was an error during processing (e.g. invalid upload) */
  thumbnailProcessingError?: InputMaybe<OrderBy>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** URL for a smaller preview/thumbnail version of the asset */
  thumbnailUrl?: InputMaybe<OrderBy>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type MessageFilesMinFields = {
  __typename?: 'MessageFilesMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** URL pointing to the full resolution asset (image, video, etc.) */
  assetUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** The message that the file belongs to */
  messageId?: Maybe<Scalars['uuid']['output']>;
  /** name of the file - used if file is downloaded */
  name?: Maybe<Scalars['String']['output']>;
  /** files are processed to give them optimised thumbnails. this column tracks if there was an error during processing (e.g. invalid upload) */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** URL for a smaller preview/thumbnail version of the asset */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by min() on columns of table "message_files" */
export type MessageFilesMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** URL pointing to the full resolution asset (image, video, etc.) */
  assetUrl?: InputMaybe<OrderBy>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The message that the file belongs to */
  messageId?: InputMaybe<OrderBy>;
  /** name of the file - used if file is downloaded */
  name?: InputMaybe<OrderBy>;
  /** files are processed to give them optimised thumbnails. this column tracks if there was an error during processing (e.g. invalid upload) */
  thumbnailProcessingError?: InputMaybe<OrderBy>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** URL for a smaller preview/thumbnail version of the asset */
  thumbnailUrl?: InputMaybe<OrderBy>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "message_files" */
export type MessageFilesMutationResponse = {
  __typename?: 'MessageFilesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MessageFiles>;
};

/** on_conflict condition type for table "message_files" */
export type MessageFilesOnConflict = {
  constraint: MessageFilesConstraint;
  updateColumns?: Array<MessageFilesUpdateColumn>;
  where?: InputMaybe<MessageFilesBoolExp>;
};

/** Ordering options when selecting data from "message_files". */
export type MessageFilesOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  assetUrl?: InputMaybe<OrderBy>;
  assetUrlExpiresAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  message?: InputMaybe<MessagesOrderBy>;
  messageId?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  thumbnailProcessingError?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  thumbnailUrl?: InputMaybe<OrderBy>;
  thumbnailUrlExpiresAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: message_files */
export type MessageFilesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "message_files" */
export enum MessageFilesSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  AssetUrl = 'assetUrl',
  /** column name */
  AssetUrlExpiresAt = 'assetUrlExpiresAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  Name = 'name',
  /** column name */
  ThumbnailProcessingError = 'thumbnailProcessingError',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  ThumbnailUrl = 'thumbnailUrl',
  /** column name */
  ThumbnailUrlExpiresAt = 'thumbnailUrlExpiresAt',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "message_files" */
export type MessageFilesSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** URL pointing to the full resolution asset (image, video, etc.) */
  assetUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The message that the file belongs to */
  messageId?: InputMaybe<Scalars['uuid']['input']>;
  /** name of the file - used if file is downloaded */
  name?: InputMaybe<Scalars['String']['input']>;
  /** files are processed to give them optimised thumbnails. this column tracks if there was an error during processing (e.g. invalid upload) */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** URL for a smaller preview/thumbnail version of the asset */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate stddev on columns */
export type MessageFilesStddevFields = {
  __typename?: 'MessageFilesStddevFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "message_files" */
export type MessageFilesStddevOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type MessageFilesStddevPopFields = {
  __typename?: 'MessageFilesStddevPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "message_files" */
export type MessageFilesStddevPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type MessageFilesStddevSampFields = {
  __typename?: 'MessageFilesStddevSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "message_files" */
export type MessageFilesStddevSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "message_files" */
export type MessageFilesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: MessageFilesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MessageFilesStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** URL pointing to the full resolution asset (image, video, etc.) */
  assetUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the asset URL expires */
  assetUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The message that the file belongs to */
  messageId?: InputMaybe<Scalars['uuid']['input']>;
  /** name of the file - used if file is downloaded */
  name?: InputMaybe<Scalars['String']['input']>;
  /** files are processed to give them optimised thumbnails. this column tracks if there was an error during processing (e.g. invalid upload) */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** URL for a smaller preview/thumbnail version of the asset */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate sum on columns */
export type MessageFilesSumFields = {
  __typename?: 'MessageFilesSumFields';
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "message_files" */
export type MessageFilesSumOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** update columns of table "message_files" */
export enum MessageFilesUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  AssetUrl = 'assetUrl',
  /** column name */
  AssetUrlExpiresAt = 'assetUrlExpiresAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  Name = 'name',
  /** column name */
  ThumbnailProcessingError = 'thumbnailProcessingError',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  ThumbnailUrl = 'thumbnailUrl',
  /** column name */
  ThumbnailUrlExpiresAt = 'thumbnailUrlExpiresAt',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type MessageFilesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MessageFilesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MessageFilesSetInput>;
  /** filter the rows which have to be updated */
  where: MessageFilesBoolExp;
};

/** aggregate varPop on columns */
export type MessageFilesVarPopFields = {
  __typename?: 'MessageFilesVarPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "message_files" */
export type MessageFilesVarPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type MessageFilesVarSampFields = {
  __typename?: 'MessageFilesVarSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "message_files" */
export type MessageFilesVarSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type MessageFilesVarianceFields = {
  __typename?: 'MessageFilesVarianceFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "message_files" */
export type MessageFilesVarianceOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [enum] files are processed to give them optimised thumbnails. this column tracks the status of that processing. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** Join table that tracks the relationship between a message and a given user This is needed if there are replies on the message to track if the replies are unread [fix needed] This should be only created when a message gets its first reply - however currently we actually created a message_user when you even open the replies */
export type MessageUsers = {
  __typename?: 'MessageUsers';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  id: Scalars['uuid']['output'];
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Stores when the user last saw the replies for this message, so that we can signal if there are new replies */
  lastReadDiscussionAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  message: Messages;
  messageId: Scalars['uuid']['output'];
  /** remove */
  oldId?: Maybe<Scalars['bigint']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid']['output'];
};

/** aggregated selection of "message_users" */
export type MessageUsersAggregate = {
  __typename?: 'MessageUsersAggregate';
  aggregate?: Maybe<MessageUsersAggregateFields>;
  nodes: Array<MessageUsers>;
};

export type MessageUsersAggregateBoolExp = {
  count?: InputMaybe<MessageUsersAggregateBoolExpCount>;
};

/** aggregate fields of "message_users" */
export type MessageUsersAggregateFields = {
  __typename?: 'MessageUsersAggregateFields';
  avg?: Maybe<MessageUsersAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<MessageUsersMaxFields>;
  min?: Maybe<MessageUsersMinFields>;
  stddev?: Maybe<MessageUsersStddevFields>;
  stddevPop?: Maybe<MessageUsersStddevPopFields>;
  stddevSamp?: Maybe<MessageUsersStddevSampFields>;
  sum?: Maybe<MessageUsersSumFields>;
  varPop?: Maybe<MessageUsersVarPopFields>;
  varSamp?: Maybe<MessageUsersVarSampFields>;
  variance?: Maybe<MessageUsersVarianceFields>;
};


/** aggregate fields of "message_users" */
export type MessageUsersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MessageUsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "message_users" */
export type MessageUsersAggregateOrderBy = {
  avg?: InputMaybe<MessageUsersAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<MessageUsersMaxOrderBy>;
  min?: InputMaybe<MessageUsersMinOrderBy>;
  stddev?: InputMaybe<MessageUsersStddevOrderBy>;
  stddevPop?: InputMaybe<MessageUsersStddevPopOrderBy>;
  stddevSamp?: InputMaybe<MessageUsersStddevSampOrderBy>;
  sum?: InputMaybe<MessageUsersSumOrderBy>;
  varPop?: InputMaybe<MessageUsersVarPopOrderBy>;
  varSamp?: InputMaybe<MessageUsersVarSampOrderBy>;
  variance?: InputMaybe<MessageUsersVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "message_users" */
export type MessageUsersArrRelInsertInput = {
  data: Array<MessageUsersInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<MessageUsersOnConflict>;
};

/** aggregate avg on columns */
export type MessageUsersAvgFields = {
  __typename?: 'MessageUsersAvgFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** remove */
  oldId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "message_users" */
export type MessageUsersAvgOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** remove */
  oldId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "message_users". All fields are combined with a logical 'AND'. */
export type MessageUsersBoolExp = {
  _and?: InputMaybe<Array<MessageUsersBoolExp>>;
  _not?: InputMaybe<MessageUsersBoolExp>;
  _or?: InputMaybe<Array<MessageUsersBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  lastReadDiscussionAt?: InputMaybe<TimestamptzComparisonExp>;
  message?: InputMaybe<MessagesBoolExp>;
  messageId?: InputMaybe<UuidComparisonExp>;
  oldId?: InputMaybe<BigintComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "message_users" */
export enum MessageUsersConstraint {
  /** unique or primary key constraint on columns "user_id", "message_id" */
  IndexMessageUsersOnUserIdAndMessageId = 'index_message_users_on_user_id_and_message_id',
  /** unique or primary key constraint on columns "id" */
  MessageUsersPkey = 'message_users_pkey',
  /** unique or primary key constraint on columns "user_id", "message_id" */
  MessageUsersUserIdMessageIdKey = 'message_users_user_id_message_id_key'
}

/** input type for incrementing numeric columns in table "message_users" */
export type MessageUsersIncInput = {
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** remove */
  oldId?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "message_users" */
export type MessageUsersInsertInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Stores when the user last saw the replies for this message, so that we can signal if there are new replies */
  lastReadDiscussionAt?: InputMaybe<Scalars['timestamptz']['input']>;
  message?: InputMaybe<MessagesObjRelInsertInput>;
  messageId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove */
  oldId?: InputMaybe<Scalars['bigint']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type MessageUsersMaxFields = {
  __typename?: 'MessageUsersMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Stores when the user last saw the replies for this message, so that we can signal if there are new replies */
  lastReadDiscussionAt?: Maybe<Scalars['timestamptz']['output']>;
  messageId?: Maybe<Scalars['uuid']['output']>;
  /** remove */
  oldId?: Maybe<Scalars['bigint']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "message_users" */
export type MessageUsersMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Stores when the user last saw the replies for this message, so that we can signal if there are new replies */
  lastReadDiscussionAt?: InputMaybe<OrderBy>;
  messageId?: InputMaybe<OrderBy>;
  /** remove */
  oldId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type MessageUsersMinFields = {
  __typename?: 'MessageUsersMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Stores when the user last saw the replies for this message, so that we can signal if there are new replies */
  lastReadDiscussionAt?: Maybe<Scalars['timestamptz']['output']>;
  messageId?: Maybe<Scalars['uuid']['output']>;
  /** remove */
  oldId?: Maybe<Scalars['bigint']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "message_users" */
export type MessageUsersMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Stores when the user last saw the replies for this message, so that we can signal if there are new replies */
  lastReadDiscussionAt?: InputMaybe<OrderBy>;
  messageId?: InputMaybe<OrderBy>;
  /** remove */
  oldId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "message_users" */
export type MessageUsersMutationResponse = {
  __typename?: 'MessageUsersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MessageUsers>;
};

/** on_conflict condition type for table "message_users" */
export type MessageUsersOnConflict = {
  constraint: MessageUsersConstraint;
  updateColumns?: Array<MessageUsersUpdateColumn>;
  where?: InputMaybe<MessageUsersBoolExp>;
};

/** Ordering options when selecting data from "message_users". */
export type MessageUsersOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  lastReadDiscussionAt?: InputMaybe<OrderBy>;
  message?: InputMaybe<MessagesOrderBy>;
  messageId?: InputMaybe<OrderBy>;
  oldId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: message_users */
export type MessageUsersPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "message_users" */
export enum MessageUsersSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LastReadDiscussionAt = 'lastReadDiscussionAt',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  OldId = 'oldId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "message_users" */
export type MessageUsersSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Stores when the user last saw the replies for this message, so that we can signal if there are new replies */
  lastReadDiscussionAt?: InputMaybe<Scalars['timestamptz']['input']>;
  messageId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove */
  oldId?: InputMaybe<Scalars['bigint']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type MessageUsersStddevFields = {
  __typename?: 'MessageUsersStddevFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** remove */
  oldId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "message_users" */
export type MessageUsersStddevOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** remove */
  oldId?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type MessageUsersStddevPopFields = {
  __typename?: 'MessageUsersStddevPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** remove */
  oldId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "message_users" */
export type MessageUsersStddevPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** remove */
  oldId?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type MessageUsersStddevSampFields = {
  __typename?: 'MessageUsersStddevSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** remove */
  oldId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "message_users" */
export type MessageUsersStddevSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** remove */
  oldId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "message_users" */
export type MessageUsersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: MessageUsersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MessageUsersStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Stores when the user last saw the replies for this message, so that we can signal if there are new replies */
  lastReadDiscussionAt?: InputMaybe<Scalars['timestamptz']['input']>;
  messageId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove */
  oldId?: InputMaybe<Scalars['bigint']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type MessageUsersSumFields = {
  __typename?: 'MessageUsersSumFields';
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** remove */
  oldId?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "message_users" */
export type MessageUsersSumOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** remove */
  oldId?: InputMaybe<OrderBy>;
};

/** update columns of table "message_users" */
export enum MessageUsersUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LastReadDiscussionAt = 'lastReadDiscussionAt',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  OldId = 'oldId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type MessageUsersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MessageUsersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MessageUsersSetInput>;
  /** filter the rows which have to be updated */
  where: MessageUsersBoolExp;
};

/** aggregate varPop on columns */
export type MessageUsersVarPopFields = {
  __typename?: 'MessageUsersVarPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** remove */
  oldId?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "message_users" */
export type MessageUsersVarPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** remove */
  oldId?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type MessageUsersVarSampFields = {
  __typename?: 'MessageUsersVarSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** remove */
  oldId?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "message_users" */
export type MessageUsersVarSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** remove */
  oldId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type MessageUsersVarianceFields = {
  __typename?: 'MessageUsersVarianceFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** remove */
  oldId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "message_users" */
export type MessageUsersVarianceOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** remove */
  oldId?: InputMaybe<OrderBy>;
};

/** This is used for any type of message that will appear in the left hand Comments panel of a task. This includes user-generated chat messages, system messages (task status changed) as well as on-asset comments */
export type Messages = {
  __typename?: 'Messages';
  /** [AI checks] the ai check run that created this message */
  aiCheckRunId?: Maybe<Scalars['uuid']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: Maybe<Scalars['Int']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  author: Users;
  /** [on-asset comment][sites] the browser that the commenter was on when leaving the message. */
  browserName?: Maybe<Scalars['String']['output']>;
  /** type of message */
  category: Scalars['Int']['output'];
  createdAt: Scalars['timestamptz']['output'];
  /** [on-asset comment][sites] the CSS selector that the comment is tagged to */
  cssSelector?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  document?: Maybe<Documents>;
  /** The id of this comment in Figma, in Figma's system. This allows us to update and add replies to the comment in Figma. */
  figmaId?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  /** [AI checks] if message was AI generated - this changes the UI (cannot reply, etc) */
  isAiGenerated: Scalars['Boolean']['output'];
  /** [analytics] - remove messages from the analytics if they are on a demo account */
  isDemo?: Maybe<Scalars['Boolean']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** the id of the object, if any, that the message is about. e.g. Version, Recording */
  messagableId?: Maybe<Scalars['uuid']['output']>;
  /** the type of the object, if any, that the message is about. e.g. Version, Recording */
  messagableType?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  messageFiles: Array<MessageFiles>;
  /** An aggregate relationship */
  messageFilesAggregate: MessageFilesAggregate;
  /** An array relationship */
  messageUsers: Array<MessageUsers>;
  /** An aggregate relationship */
  messageUsersAggregate: MessageUsersAggregate;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  parentDocument?: Maybe<Documents>;
  /** The document that this message is attached to */
  parentDocumentId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  parentMessage?: Maybe<Messages>;
  /** The message that this message is a reply to */
  parentMessageId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  parentVersion?: Maybe<Versions>;
  /** The version that this message is attached to */
  parentVersionId?: Maybe<Scalars['uuid']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: Maybe<Scalars['float8']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: Maybe<Scalars['float8']['output']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: Maybe<Scalars['Int']['output']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  reactions: Array<Reactions>;
  /** An aggregate relationship */
  reactionsAggregate: ReactionsAggregate;
  /** An array relationship */
  recordings: Array<Recordings>;
  /** An aggregate relationship */
  recordingsAggregate: RecordingsAggregate;
  /** An array relationship */
  replies: Array<Messages>;
  /** An aggregate relationship */
  repliesAggregate: MessagesAggregate;
  resolved?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  resolver?: Maybe<Users>;
  /** ID of user who resoled the comment */
  resolverId?: Maybe<Scalars['uuid']['output']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: Maybe<Scalars['Int']['output']>;
  /** URL of the livesite screenshot */
  screenshotUrl?: Maybe<Scalars['String']['output']>;
  /** Expiration date time of the livesite screenshot */
  screenshotUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  /** Used to create a shorter URL that links to specific messages, such as workflow.design/c/a4dD4s */
  shortLinkSlug?: Maybe<Scalars['String']['output']>;
  /** remove - old format for storing messages */
  textJson?: Maybe<Scalars['jsonb']['output']>;
  /** Content of the message */
  textJsonTiptap?: Maybe<Scalars['jsonb']['output']>;
  /** the ID of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableId?: Maybe<Scalars['uuid']['output']>;
  /** the type of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableType?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
  /** [on-asset comment][sites] check if needs consolidating with url - the path that the comment is stored at so that the comment is only shown on the correct page */
  urlPathname?: Maybe<Scalars['String']['output']>;
  userId: Scalars['uuid']['output'];
  /** An object relationship */
  version?: Maybe<Versions>;
  /** [on-asset comment]video] the time stamp of the comment in format MM:SS */
  videoTimeStamp?: Maybe<Scalars['String']['output']>;
};


/** This is used for any type of message that will appear in the left hand Comments panel of a task. This includes user-generated chat messages, system messages (task status changed) as well as on-asset comments */
export type MessagesMessageFilesArgs = {
  distinctOn?: InputMaybe<Array<MessageFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageFilesOrderBy>>;
  where?: InputMaybe<MessageFilesBoolExp>;
};


/** This is used for any type of message that will appear in the left hand Comments panel of a task. This includes user-generated chat messages, system messages (task status changed) as well as on-asset comments */
export type MessagesMessageFilesAggregateArgs = {
  distinctOn?: InputMaybe<Array<MessageFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageFilesOrderBy>>;
  where?: InputMaybe<MessageFilesBoolExp>;
};


/** This is used for any type of message that will appear in the left hand Comments panel of a task. This includes user-generated chat messages, system messages (task status changed) as well as on-asset comments */
export type MessagesMessageUsersArgs = {
  distinctOn?: InputMaybe<Array<MessageUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageUsersOrderBy>>;
  where?: InputMaybe<MessageUsersBoolExp>;
};


/** This is used for any type of message that will appear in the left hand Comments panel of a task. This includes user-generated chat messages, system messages (task status changed) as well as on-asset comments */
export type MessagesMessageUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<MessageUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageUsersOrderBy>>;
  where?: InputMaybe<MessageUsersBoolExp>;
};


/** This is used for any type of message that will appear in the left hand Comments panel of a task. This includes user-generated chat messages, system messages (task status changed) as well as on-asset comments */
export type MessagesReactionsArgs = {
  distinctOn?: InputMaybe<Array<ReactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReactionsOrderBy>>;
  where?: InputMaybe<ReactionsBoolExp>;
};


/** This is used for any type of message that will appear in the left hand Comments panel of a task. This includes user-generated chat messages, system messages (task status changed) as well as on-asset comments */
export type MessagesReactionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ReactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReactionsOrderBy>>;
  where?: InputMaybe<ReactionsBoolExp>;
};


/** This is used for any type of message that will appear in the left hand Comments panel of a task. This includes user-generated chat messages, system messages (task status changed) as well as on-asset comments */
export type MessagesRecordingsArgs = {
  distinctOn?: InputMaybe<Array<RecordingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RecordingsOrderBy>>;
  where?: InputMaybe<RecordingsBoolExp>;
};


/** This is used for any type of message that will appear in the left hand Comments panel of a task. This includes user-generated chat messages, system messages (task status changed) as well as on-asset comments */
export type MessagesRecordingsAggregateArgs = {
  distinctOn?: InputMaybe<Array<RecordingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RecordingsOrderBy>>;
  where?: InputMaybe<RecordingsBoolExp>;
};


/** This is used for any type of message that will appear in the left hand Comments panel of a task. This includes user-generated chat messages, system messages (task status changed) as well as on-asset comments */
export type MessagesRepliesArgs = {
  distinctOn?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


/** This is used for any type of message that will appear in the left hand Comments panel of a task. This includes user-generated chat messages, system messages (task status changed) as well as on-asset comments */
export type MessagesRepliesAggregateArgs = {
  distinctOn?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


/** This is used for any type of message that will appear in the left hand Comments panel of a task. This includes user-generated chat messages, system messages (task status changed) as well as on-asset comments */
export type MessagesTextJsonArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** This is used for any type of message that will appear in the left hand Comments panel of a task. This includes user-generated chat messages, system messages (task status changed) as well as on-asset comments */
export type MessagesTextJsonTiptapArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "messages" */
export type MessagesAggregate = {
  __typename?: 'MessagesAggregate';
  aggregate?: Maybe<MessagesAggregateFields>;
  nodes: Array<Messages>;
};

export type MessagesAggregateBoolExp = {
  avg?: InputMaybe<MessagesAggregateBoolExpAvg>;
  bool_and?: InputMaybe<MessagesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<MessagesAggregateBoolExpBool_Or>;
  corr?: InputMaybe<MessagesAggregateBoolExpCorr>;
  count?: InputMaybe<MessagesAggregateBoolExpCount>;
  covar_samp?: InputMaybe<MessagesAggregateBoolExpCovar_Samp>;
  max?: InputMaybe<MessagesAggregateBoolExpMax>;
  min?: InputMaybe<MessagesAggregateBoolExpMin>;
  stddev_samp?: InputMaybe<MessagesAggregateBoolExpStddev_Samp>;
  sum?: InputMaybe<MessagesAggregateBoolExpSum>;
  var_samp?: InputMaybe<MessagesAggregateBoolExpVar_Samp>;
};

/** aggregate fields of "messages" */
export type MessagesAggregateFields = {
  __typename?: 'MessagesAggregateFields';
  avg?: Maybe<MessagesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<MessagesMaxFields>;
  min?: Maybe<MessagesMinFields>;
  stddev?: Maybe<MessagesStddevFields>;
  stddevPop?: Maybe<MessagesStddevPopFields>;
  stddevSamp?: Maybe<MessagesStddevSampFields>;
  sum?: Maybe<MessagesSumFields>;
  varPop?: Maybe<MessagesVarPopFields>;
  varSamp?: Maybe<MessagesVarSampFields>;
  variance?: Maybe<MessagesVarianceFields>;
};


/** aggregate fields of "messages" */
export type MessagesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MessagesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "messages" */
export type MessagesAggregateOrderBy = {
  avg?: InputMaybe<MessagesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<MessagesMaxOrderBy>;
  min?: InputMaybe<MessagesMinOrderBy>;
  stddev?: InputMaybe<MessagesStddevOrderBy>;
  stddevPop?: InputMaybe<MessagesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<MessagesStddevSampOrderBy>;
  sum?: InputMaybe<MessagesSumOrderBy>;
  varPop?: InputMaybe<MessagesVarPopOrderBy>;
  varSamp?: InputMaybe<MessagesVarSampOrderBy>;
  variance?: InputMaybe<MessagesVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type MessagesAppendInput = {
  /** remove - old format for storing messages */
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
  /** Content of the message */
  textJsonTiptap?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "messages" */
export type MessagesArrRelInsertInput = {
  data: Array<MessagesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<MessagesOnConflict>;
};

/** aggregate avg on columns */
export type MessagesAvgFields = {
  __typename?: 'MessagesAvgFields';
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: Maybe<Scalars['Float']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: Maybe<Scalars['Float']['output']>;
  /** type of message */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "messages" */
export type MessagesAvgOrderBy = {
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<OrderBy>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<OrderBy>;
  /** type of message */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "messages". All fields are combined with a logical 'AND'. */
export type MessagesBoolExp = {
  _and?: InputMaybe<Array<MessagesBoolExp>>;
  _not?: InputMaybe<MessagesBoolExp>;
  _or?: InputMaybe<Array<MessagesBoolExp>>;
  aiCheckRunId?: InputMaybe<UuidComparisonExp>;
  approvalChangeVersionNumber?: InputMaybe<IntComparisonExp>;
  approvalStatusChange?: InputMaybe<IntComparisonExp>;
  author?: InputMaybe<UsersBoolExp>;
  browserName?: InputMaybe<StringComparisonExp>;
  category?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  cssSelector?: InputMaybe<StringComparisonExp>;
  document?: InputMaybe<DocumentsBoolExp>;
  figmaId?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isAiGenerated?: InputMaybe<BooleanComparisonExp>;
  isDemo?: InputMaybe<BooleanComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  messagableId?: InputMaybe<UuidComparisonExp>;
  messagableType?: InputMaybe<StringComparisonExp>;
  messageFiles?: InputMaybe<MessageFilesBoolExp>;
  messageFilesAggregate?: InputMaybe<MessageFilesAggregateBoolExp>;
  messageUsers?: InputMaybe<MessageUsersBoolExp>;
  messageUsersAggregate?: InputMaybe<MessageUsersAggregateBoolExp>;
  page?: InputMaybe<IntComparisonExp>;
  parentDocument?: InputMaybe<DocumentsBoolExp>;
  parentDocumentId?: InputMaybe<UuidComparisonExp>;
  parentMessage?: InputMaybe<MessagesBoolExp>;
  parentMessageId?: InputMaybe<UuidComparisonExp>;
  parentVersion?: InputMaybe<VersionsBoolExp>;
  parentVersionId?: InputMaybe<UuidComparisonExp>;
  positionPercentageX?: InputMaybe<Float8ComparisonExp>;
  positionPercentageY?: InputMaybe<Float8ComparisonExp>;
  positionX?: InputMaybe<IntComparisonExp>;
  positionY?: InputMaybe<IntComparisonExp>;
  reactions?: InputMaybe<ReactionsBoolExp>;
  reactionsAggregate?: InputMaybe<ReactionsAggregateBoolExp>;
  recordings?: InputMaybe<RecordingsBoolExp>;
  recordingsAggregate?: InputMaybe<RecordingsAggregateBoolExp>;
  replies?: InputMaybe<MessagesBoolExp>;
  repliesAggregate?: InputMaybe<MessagesAggregateBoolExp>;
  resolved?: InputMaybe<BooleanComparisonExp>;
  resolver?: InputMaybe<UsersBoolExp>;
  resolverId?: InputMaybe<UuidComparisonExp>;
  screenWidth?: InputMaybe<IntComparisonExp>;
  screenshotUrl?: InputMaybe<StringComparisonExp>;
  screenshotUrlExpiresAt?: InputMaybe<TimestampComparisonExp>;
  shortLinkSlug?: InputMaybe<StringComparisonExp>;
  textJson?: InputMaybe<JsonbComparisonExp>;
  textJsonTiptap?: InputMaybe<JsonbComparisonExp>;
  threadableId?: InputMaybe<UuidComparisonExp>;
  threadableType?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  urlPathname?: InputMaybe<StringComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  version?: InputMaybe<VersionsBoolExp>;
  videoTimeStamp?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "messages" */
export enum MessagesConstraint {
  /** unique or primary key constraint on columns "id" */
  MessagesPkey = 'messages_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type MessagesDeleteAtPathInput = {
  /** remove - old format for storing messages */
  textJson?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Content of the message */
  textJsonTiptap?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type MessagesDeleteElemInput = {
  /** remove - old format for storing messages */
  textJson?: InputMaybe<Scalars['Int']['input']>;
  /** Content of the message */
  textJsonTiptap?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type MessagesDeleteKeyInput = {
  /** remove - old format for storing messages */
  textJson?: InputMaybe<Scalars['String']['input']>;
  /** Content of the message */
  textJsonTiptap?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "messages" */
export type MessagesIncInput = {
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<Scalars['Int']['input']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<Scalars['Int']['input']>;
  /** type of message */
  category?: InputMaybe<Scalars['Int']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<Scalars['Int']['input']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<Scalars['float8']['input']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<Scalars['float8']['input']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<Scalars['Int']['input']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<Scalars['Int']['input']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "messages" */
export type MessagesInsertInput = {
  /** [AI checks] the ai check run that created this message */
  aiCheckRunId?: InputMaybe<Scalars['uuid']['input']>;
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<Scalars['Int']['input']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<Scalars['Int']['input']>;
  author?: InputMaybe<UsersObjRelInsertInput>;
  /** [on-asset comment][sites] the browser that the commenter was on when leaving the message. */
  browserName?: InputMaybe<Scalars['String']['input']>;
  /** type of message */
  category?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [on-asset comment][sites] the CSS selector that the comment is tagged to */
  cssSelector?: InputMaybe<Scalars['String']['input']>;
  document?: InputMaybe<DocumentsObjRelInsertInput>;
  /** The id of this comment in Figma, in Figma's system. This allows us to update and add replies to the comment in Figma. */
  figmaId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [AI checks] if message was AI generated - this changes the UI (cannot reply, etc) */
  isAiGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  /** [analytics] - remove messages from the analytics if they are on a demo account */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** the id of the object, if any, that the message is about. e.g. Version, Recording */
  messagableId?: InputMaybe<Scalars['uuid']['input']>;
  /** the type of the object, if any, that the message is about. e.g. Version, Recording */
  messagableType?: InputMaybe<Scalars['String']['input']>;
  messageFiles?: InputMaybe<MessageFilesArrRelInsertInput>;
  messageUsers?: InputMaybe<MessageUsersArrRelInsertInput>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<Scalars['Int']['input']>;
  parentDocument?: InputMaybe<DocumentsObjRelInsertInput>;
  /** The document that this message is attached to */
  parentDocumentId?: InputMaybe<Scalars['uuid']['input']>;
  parentMessage?: InputMaybe<MessagesObjRelInsertInput>;
  /** The message that this message is a reply to */
  parentMessageId?: InputMaybe<Scalars['uuid']['input']>;
  parentVersion?: InputMaybe<VersionsObjRelInsertInput>;
  /** The version that this message is attached to */
  parentVersionId?: InputMaybe<Scalars['uuid']['input']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<Scalars['float8']['input']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<Scalars['float8']['input']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<Scalars['Int']['input']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<Scalars['Int']['input']>;
  reactions?: InputMaybe<ReactionsArrRelInsertInput>;
  recordings?: InputMaybe<RecordingsArrRelInsertInput>;
  replies?: InputMaybe<MessagesArrRelInsertInput>;
  resolved?: InputMaybe<Scalars['Boolean']['input']>;
  resolver?: InputMaybe<UsersObjRelInsertInput>;
  /** ID of user who resoled the comment */
  resolverId?: InputMaybe<Scalars['uuid']['input']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<Scalars['Int']['input']>;
  /** URL of the livesite screenshot */
  screenshotUrl?: InputMaybe<Scalars['String']['input']>;
  /** Expiration date time of the livesite screenshot */
  screenshotUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Used to create a shorter URL that links to specific messages, such as workflow.design/c/a4dD4s */
  shortLinkSlug?: InputMaybe<Scalars['String']['input']>;
  /** remove - old format for storing messages */
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
  /** Content of the message */
  textJsonTiptap?: InputMaybe<Scalars['jsonb']['input']>;
  /** the ID of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableId?: InputMaybe<Scalars['uuid']['input']>;
  /** the type of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableType?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [on-asset comment][sites] check if needs consolidating with url - the path that the comment is stored at so that the comment is only shown on the correct page */
  urlPathname?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  version?: InputMaybe<VersionsObjRelInsertInput>;
  /** [on-asset comment]video] the time stamp of the comment in format MM:SS */
  videoTimeStamp?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type MessagesMaxFields = {
  __typename?: 'MessagesMaxFields';
  /** [AI checks] the ai check run that created this message */
  aiCheckRunId?: Maybe<Scalars['uuid']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: Maybe<Scalars['Int']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: Maybe<Scalars['Int']['output']>;
  /** [on-asset comment][sites] the browser that the commenter was on when leaving the message. */
  browserName?: Maybe<Scalars['String']['output']>;
  /** type of message */
  category?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** [on-asset comment][sites] the CSS selector that the comment is tagged to */
  cssSelector?: Maybe<Scalars['String']['output']>;
  /** The id of this comment in Figma, in Figma's system. This allows us to update and add replies to the comment in Figma. */
  figmaId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** the id of the object, if any, that the message is about. e.g. Version, Recording */
  messagableId?: Maybe<Scalars['uuid']['output']>;
  /** the type of the object, if any, that the message is about. e.g. Version, Recording */
  messagableType?: Maybe<Scalars['String']['output']>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: Maybe<Scalars['Int']['output']>;
  /** The document that this message is attached to */
  parentDocumentId?: Maybe<Scalars['uuid']['output']>;
  /** The message that this message is a reply to */
  parentMessageId?: Maybe<Scalars['uuid']['output']>;
  /** The version that this message is attached to */
  parentVersionId?: Maybe<Scalars['uuid']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: Maybe<Scalars['float8']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: Maybe<Scalars['float8']['output']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: Maybe<Scalars['Int']['output']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: Maybe<Scalars['Int']['output']>;
  /** ID of user who resoled the comment */
  resolverId?: Maybe<Scalars['uuid']['output']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: Maybe<Scalars['Int']['output']>;
  /** URL of the livesite screenshot */
  screenshotUrl?: Maybe<Scalars['String']['output']>;
  /** Expiration date time of the livesite screenshot */
  screenshotUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  /** Used to create a shorter URL that links to specific messages, such as workflow.design/c/a4dD4s */
  shortLinkSlug?: Maybe<Scalars['String']['output']>;
  /** the ID of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableId?: Maybe<Scalars['uuid']['output']>;
  /** the type of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableType?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** [on-asset comment][sites] check if needs consolidating with url - the path that the comment is stored at so that the comment is only shown on the correct page */
  urlPathname?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
  /** [on-asset comment]video] the time stamp of the comment in format MM:SS */
  videoTimeStamp?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "messages" */
export type MessagesMaxOrderBy = {
  /** [AI checks] the ai check run that created this message */
  aiCheckRunId?: InputMaybe<OrderBy>;
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<OrderBy>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the browser that the commenter was on when leaving the message. */
  browserName?: InputMaybe<OrderBy>;
  /** type of message */
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the CSS selector that the comment is tagged to */
  cssSelector?: InputMaybe<OrderBy>;
  /** The id of this comment in Figma, in Figma's system. This allows us to update and add replies to the comment in Figma. */
  figmaId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** the id of the object, if any, that the message is about. e.g. Version, Recording */
  messagableId?: InputMaybe<OrderBy>;
  /** the type of the object, if any, that the message is about. e.g. Version, Recording */
  messagableType?: InputMaybe<OrderBy>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<OrderBy>;
  /** The document that this message is attached to */
  parentDocumentId?: InputMaybe<OrderBy>;
  /** The message that this message is a reply to */
  parentMessageId?: InputMaybe<OrderBy>;
  /** The version that this message is attached to */
  parentVersionId?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<OrderBy>;
  /** ID of user who resoled the comment */
  resolverId?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<OrderBy>;
  /** URL of the livesite screenshot */
  screenshotUrl?: InputMaybe<OrderBy>;
  /** Expiration date time of the livesite screenshot */
  screenshotUrlExpiresAt?: InputMaybe<OrderBy>;
  /** Used to create a shorter URL that links to specific messages, such as workflow.design/c/a4dD4s */
  shortLinkSlug?: InputMaybe<OrderBy>;
  /** the ID of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableId?: InputMaybe<OrderBy>;
  /** the type of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableType?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] check if needs consolidating with url - the path that the comment is stored at so that the comment is only shown on the correct page */
  urlPathname?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  /** [on-asset comment]video] the time stamp of the comment in format MM:SS */
  videoTimeStamp?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type MessagesMinFields = {
  __typename?: 'MessagesMinFields';
  /** [AI checks] the ai check run that created this message */
  aiCheckRunId?: Maybe<Scalars['uuid']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: Maybe<Scalars['Int']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: Maybe<Scalars['Int']['output']>;
  /** [on-asset comment][sites] the browser that the commenter was on when leaving the message. */
  browserName?: Maybe<Scalars['String']['output']>;
  /** type of message */
  category?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** [on-asset comment][sites] the CSS selector that the comment is tagged to */
  cssSelector?: Maybe<Scalars['String']['output']>;
  /** The id of this comment in Figma, in Figma's system. This allows us to update and add replies to the comment in Figma. */
  figmaId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** the id of the object, if any, that the message is about. e.g. Version, Recording */
  messagableId?: Maybe<Scalars['uuid']['output']>;
  /** the type of the object, if any, that the message is about. e.g. Version, Recording */
  messagableType?: Maybe<Scalars['String']['output']>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: Maybe<Scalars['Int']['output']>;
  /** The document that this message is attached to */
  parentDocumentId?: Maybe<Scalars['uuid']['output']>;
  /** The message that this message is a reply to */
  parentMessageId?: Maybe<Scalars['uuid']['output']>;
  /** The version that this message is attached to */
  parentVersionId?: Maybe<Scalars['uuid']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: Maybe<Scalars['float8']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: Maybe<Scalars['float8']['output']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: Maybe<Scalars['Int']['output']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: Maybe<Scalars['Int']['output']>;
  /** ID of user who resoled the comment */
  resolverId?: Maybe<Scalars['uuid']['output']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: Maybe<Scalars['Int']['output']>;
  /** URL of the livesite screenshot */
  screenshotUrl?: Maybe<Scalars['String']['output']>;
  /** Expiration date time of the livesite screenshot */
  screenshotUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  /** Used to create a shorter URL that links to specific messages, such as workflow.design/c/a4dD4s */
  shortLinkSlug?: Maybe<Scalars['String']['output']>;
  /** the ID of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableId?: Maybe<Scalars['uuid']['output']>;
  /** the type of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableType?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** [on-asset comment][sites] check if needs consolidating with url - the path that the comment is stored at so that the comment is only shown on the correct page */
  urlPathname?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
  /** [on-asset comment]video] the time stamp of the comment in format MM:SS */
  videoTimeStamp?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "messages" */
export type MessagesMinOrderBy = {
  /** [AI checks] the ai check run that created this message */
  aiCheckRunId?: InputMaybe<OrderBy>;
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<OrderBy>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the browser that the commenter was on when leaving the message. */
  browserName?: InputMaybe<OrderBy>;
  /** type of message */
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the CSS selector that the comment is tagged to */
  cssSelector?: InputMaybe<OrderBy>;
  /** The id of this comment in Figma, in Figma's system. This allows us to update and add replies to the comment in Figma. */
  figmaId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** the id of the object, if any, that the message is about. e.g. Version, Recording */
  messagableId?: InputMaybe<OrderBy>;
  /** the type of the object, if any, that the message is about. e.g. Version, Recording */
  messagableType?: InputMaybe<OrderBy>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<OrderBy>;
  /** The document that this message is attached to */
  parentDocumentId?: InputMaybe<OrderBy>;
  /** The message that this message is a reply to */
  parentMessageId?: InputMaybe<OrderBy>;
  /** The version that this message is attached to */
  parentVersionId?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<OrderBy>;
  /** ID of user who resoled the comment */
  resolverId?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<OrderBy>;
  /** URL of the livesite screenshot */
  screenshotUrl?: InputMaybe<OrderBy>;
  /** Expiration date time of the livesite screenshot */
  screenshotUrlExpiresAt?: InputMaybe<OrderBy>;
  /** Used to create a shorter URL that links to specific messages, such as workflow.design/c/a4dD4s */
  shortLinkSlug?: InputMaybe<OrderBy>;
  /** the ID of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableId?: InputMaybe<OrderBy>;
  /** the type of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableType?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] check if needs consolidating with url - the path that the comment is stored at so that the comment is only shown on the correct page */
  urlPathname?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  /** [on-asset comment]video] the time stamp of the comment in format MM:SS */
  videoTimeStamp?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "messages" */
export type MessagesMutationResponse = {
  __typename?: 'MessagesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Messages>;
};

/** input type for inserting object relation for remote table "messages" */
export type MessagesObjRelInsertInput = {
  data: MessagesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<MessagesOnConflict>;
};

/** on_conflict condition type for table "messages" */
export type MessagesOnConflict = {
  constraint: MessagesConstraint;
  updateColumns?: Array<MessagesUpdateColumn>;
  where?: InputMaybe<MessagesBoolExp>;
};

/** Ordering options when selecting data from "messages". */
export type MessagesOrderBy = {
  aiCheckRunId?: InputMaybe<OrderBy>;
  approvalChangeVersionNumber?: InputMaybe<OrderBy>;
  approvalStatusChange?: InputMaybe<OrderBy>;
  author?: InputMaybe<UsersOrderBy>;
  browserName?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  cssSelector?: InputMaybe<OrderBy>;
  document?: InputMaybe<DocumentsOrderBy>;
  figmaId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isAiGenerated?: InputMaybe<OrderBy>;
  isDemo?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  messagableId?: InputMaybe<OrderBy>;
  messagableType?: InputMaybe<OrderBy>;
  messageFilesAggregate?: InputMaybe<MessageFilesAggregateOrderBy>;
  messageUsersAggregate?: InputMaybe<MessageUsersAggregateOrderBy>;
  page?: InputMaybe<OrderBy>;
  parentDocument?: InputMaybe<DocumentsOrderBy>;
  parentDocumentId?: InputMaybe<OrderBy>;
  parentMessage?: InputMaybe<MessagesOrderBy>;
  parentMessageId?: InputMaybe<OrderBy>;
  parentVersion?: InputMaybe<VersionsOrderBy>;
  parentVersionId?: InputMaybe<OrderBy>;
  positionPercentageX?: InputMaybe<OrderBy>;
  positionPercentageY?: InputMaybe<OrderBy>;
  positionX?: InputMaybe<OrderBy>;
  positionY?: InputMaybe<OrderBy>;
  reactionsAggregate?: InputMaybe<ReactionsAggregateOrderBy>;
  recordingsAggregate?: InputMaybe<RecordingsAggregateOrderBy>;
  repliesAggregate?: InputMaybe<MessagesAggregateOrderBy>;
  resolved?: InputMaybe<OrderBy>;
  resolver?: InputMaybe<UsersOrderBy>;
  resolverId?: InputMaybe<OrderBy>;
  screenWidth?: InputMaybe<OrderBy>;
  screenshotUrl?: InputMaybe<OrderBy>;
  screenshotUrlExpiresAt?: InputMaybe<OrderBy>;
  shortLinkSlug?: InputMaybe<OrderBy>;
  textJson?: InputMaybe<OrderBy>;
  textJsonTiptap?: InputMaybe<OrderBy>;
  threadableId?: InputMaybe<OrderBy>;
  threadableType?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  urlPathname?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  version?: InputMaybe<VersionsOrderBy>;
  videoTimeStamp?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: messages */
export type MessagesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type MessagesPrependInput = {
  /** remove - old format for storing messages */
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
  /** Content of the message */
  textJsonTiptap?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "messages" */
export enum MessagesSelectColumn {
  /** column name */
  AiCheckRunId = 'aiCheckRunId',
  /** column name */
  ApprovalChangeVersionNumber = 'approvalChangeVersionNumber',
  /** column name */
  ApprovalStatusChange = 'approvalStatusChange',
  /** column name */
  BrowserName = 'browserName',
  /** column name */
  Category = 'category',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CssSelector = 'cssSelector',
  /** column name */
  FigmaId = 'figmaId',
  /** column name */
  Id = 'id',
  /** column name */
  IsAiGenerated = 'isAiGenerated',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  MessagableId = 'messagableId',
  /** column name */
  MessagableType = 'messagableType',
  /** column name */
  Page = 'page',
  /** column name */
  ParentDocumentId = 'parentDocumentId',
  /** column name */
  ParentMessageId = 'parentMessageId',
  /** column name */
  ParentVersionId = 'parentVersionId',
  /** column name */
  PositionPercentageX = 'positionPercentageX',
  /** column name */
  PositionPercentageY = 'positionPercentageY',
  /** column name */
  PositionX = 'positionX',
  /** column name */
  PositionY = 'positionY',
  /** column name */
  Resolved = 'resolved',
  /** column name */
  ResolverId = 'resolverId',
  /** column name */
  ScreenWidth = 'screenWidth',
  /** column name */
  ScreenshotUrl = 'screenshotUrl',
  /** column name */
  ScreenshotUrlExpiresAt = 'screenshotUrlExpiresAt',
  /** column name */
  ShortLinkSlug = 'shortLinkSlug',
  /** column name */
  TextJson = 'textJson',
  /** column name */
  TextJsonTiptap = 'textJsonTiptap',
  /** column name */
  ThreadableId = 'threadableId',
  /** column name */
  ThreadableType = 'threadableType',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UrlPathname = 'urlPathname',
  /** column name */
  UserId = 'userId',
  /** column name */
  VideoTimeStamp = 'videoTimeStamp'
}

/** select "messagesAggregateBoolExpAvgArgumentsColumns" columns of table "messages" */
export enum MessagesSelectColumnMessagesAggregateBoolExpAvgArgumentsColumns {
  /** column name */
  PositionPercentageX = 'positionPercentageX',
  /** column name */
  PositionPercentageY = 'positionPercentageY'
}

/** select "messagesAggregateBoolExpBool_andArgumentsColumns" columns of table "messages" */
export enum MessagesSelectColumnMessagesAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsAiGenerated = 'isAiGenerated',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  Resolved = 'resolved'
}

/** select "messagesAggregateBoolExpBool_orArgumentsColumns" columns of table "messages" */
export enum MessagesSelectColumnMessagesAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsAiGenerated = 'isAiGenerated',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  Resolved = 'resolved'
}

/** select "messagesAggregateBoolExpCorrArgumentsColumns" columns of table "messages" */
export enum MessagesSelectColumnMessagesAggregateBoolExpCorrArgumentsColumns {
  /** column name */
  PositionPercentageX = 'positionPercentageX',
  /** column name */
  PositionPercentageY = 'positionPercentageY'
}

/** select "messagesAggregateBoolExpCovar_sampArgumentsColumns" columns of table "messages" */
export enum MessagesSelectColumnMessagesAggregateBoolExpCovar_SampArgumentsColumns {
  /** column name */
  PositionPercentageX = 'positionPercentageX',
  /** column name */
  PositionPercentageY = 'positionPercentageY'
}

/** select "messagesAggregateBoolExpMaxArgumentsColumns" columns of table "messages" */
export enum MessagesSelectColumnMessagesAggregateBoolExpMaxArgumentsColumns {
  /** column name */
  PositionPercentageX = 'positionPercentageX',
  /** column name */
  PositionPercentageY = 'positionPercentageY'
}

/** select "messagesAggregateBoolExpMinArgumentsColumns" columns of table "messages" */
export enum MessagesSelectColumnMessagesAggregateBoolExpMinArgumentsColumns {
  /** column name */
  PositionPercentageX = 'positionPercentageX',
  /** column name */
  PositionPercentageY = 'positionPercentageY'
}

/** select "messagesAggregateBoolExpStddev_sampArgumentsColumns" columns of table "messages" */
export enum MessagesSelectColumnMessagesAggregateBoolExpStddev_SampArgumentsColumns {
  /** column name */
  PositionPercentageX = 'positionPercentageX',
  /** column name */
  PositionPercentageY = 'positionPercentageY'
}

/** select "messagesAggregateBoolExpSumArgumentsColumns" columns of table "messages" */
export enum MessagesSelectColumnMessagesAggregateBoolExpSumArgumentsColumns {
  /** column name */
  PositionPercentageX = 'positionPercentageX',
  /** column name */
  PositionPercentageY = 'positionPercentageY'
}

/** select "messagesAggregateBoolExpVar_sampArgumentsColumns" columns of table "messages" */
export enum MessagesSelectColumnMessagesAggregateBoolExpVar_SampArgumentsColumns {
  /** column name */
  PositionPercentageX = 'positionPercentageX',
  /** column name */
  PositionPercentageY = 'positionPercentageY'
}

/** input type for updating data in table "messages" */
export type MessagesSetInput = {
  /** [AI checks] the ai check run that created this message */
  aiCheckRunId?: InputMaybe<Scalars['uuid']['input']>;
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<Scalars['Int']['input']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<Scalars['Int']['input']>;
  /** [on-asset comment][sites] the browser that the commenter was on when leaving the message. */
  browserName?: InputMaybe<Scalars['String']['input']>;
  /** type of message */
  category?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [on-asset comment][sites] the CSS selector that the comment is tagged to */
  cssSelector?: InputMaybe<Scalars['String']['input']>;
  /** The id of this comment in Figma, in Figma's system. This allows us to update and add replies to the comment in Figma. */
  figmaId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [AI checks] if message was AI generated - this changes the UI (cannot reply, etc) */
  isAiGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  /** [analytics] - remove messages from the analytics if they are on a demo account */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** the id of the object, if any, that the message is about. e.g. Version, Recording */
  messagableId?: InputMaybe<Scalars['uuid']['input']>;
  /** the type of the object, if any, that the message is about. e.g. Version, Recording */
  messagableType?: InputMaybe<Scalars['String']['input']>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<Scalars['Int']['input']>;
  /** The document that this message is attached to */
  parentDocumentId?: InputMaybe<Scalars['uuid']['input']>;
  /** The message that this message is a reply to */
  parentMessageId?: InputMaybe<Scalars['uuid']['input']>;
  /** The version that this message is attached to */
  parentVersionId?: InputMaybe<Scalars['uuid']['input']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<Scalars['float8']['input']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<Scalars['float8']['input']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<Scalars['Int']['input']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<Scalars['Int']['input']>;
  resolved?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID of user who resoled the comment */
  resolverId?: InputMaybe<Scalars['uuid']['input']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<Scalars['Int']['input']>;
  /** URL of the livesite screenshot */
  screenshotUrl?: InputMaybe<Scalars['String']['input']>;
  /** Expiration date time of the livesite screenshot */
  screenshotUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Used to create a shorter URL that links to specific messages, such as workflow.design/c/a4dD4s */
  shortLinkSlug?: InputMaybe<Scalars['String']['input']>;
  /** remove - old format for storing messages */
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
  /** Content of the message */
  textJsonTiptap?: InputMaybe<Scalars['jsonb']['input']>;
  /** the ID of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableId?: InputMaybe<Scalars['uuid']['input']>;
  /** the type of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableType?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [on-asset comment][sites] check if needs consolidating with url - the path that the comment is stored at so that the comment is only shown on the correct page */
  urlPathname?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** [on-asset comment]video] the time stamp of the comment in format MM:SS */
  videoTimeStamp?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type MessagesStddevFields = {
  __typename?: 'MessagesStddevFields';
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: Maybe<Scalars['Float']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: Maybe<Scalars['Float']['output']>;
  /** type of message */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "messages" */
export type MessagesStddevOrderBy = {
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<OrderBy>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<OrderBy>;
  /** type of message */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type MessagesStddevPopFields = {
  __typename?: 'MessagesStddevPopFields';
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: Maybe<Scalars['Float']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: Maybe<Scalars['Float']['output']>;
  /** type of message */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "messages" */
export type MessagesStddevPopOrderBy = {
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<OrderBy>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<OrderBy>;
  /** type of message */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type MessagesStddevSampFields = {
  __typename?: 'MessagesStddevSampFields';
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: Maybe<Scalars['Float']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: Maybe<Scalars['Float']['output']>;
  /** type of message */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "messages" */
export type MessagesStddevSampOrderBy = {
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<OrderBy>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<OrderBy>;
  /** type of message */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "messages" */
export type MessagesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: MessagesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MessagesStreamCursorValueInput = {
  /** [AI checks] the ai check run that created this message */
  aiCheckRunId?: InputMaybe<Scalars['uuid']['input']>;
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<Scalars['Int']['input']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<Scalars['Int']['input']>;
  /** [on-asset comment][sites] the browser that the commenter was on when leaving the message. */
  browserName?: InputMaybe<Scalars['String']['input']>;
  /** type of message */
  category?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [on-asset comment][sites] the CSS selector that the comment is tagged to */
  cssSelector?: InputMaybe<Scalars['String']['input']>;
  /** The id of this comment in Figma, in Figma's system. This allows us to update and add replies to the comment in Figma. */
  figmaId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [AI checks] if message was AI generated - this changes the UI (cannot reply, etc) */
  isAiGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  /** [analytics] - remove messages from the analytics if they are on a demo account */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** the id of the object, if any, that the message is about. e.g. Version, Recording */
  messagableId?: InputMaybe<Scalars['uuid']['input']>;
  /** the type of the object, if any, that the message is about. e.g. Version, Recording */
  messagableType?: InputMaybe<Scalars['String']['input']>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<Scalars['Int']['input']>;
  /** The document that this message is attached to */
  parentDocumentId?: InputMaybe<Scalars['uuid']['input']>;
  /** The message that this message is a reply to */
  parentMessageId?: InputMaybe<Scalars['uuid']['input']>;
  /** The version that this message is attached to */
  parentVersionId?: InputMaybe<Scalars['uuid']['input']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<Scalars['float8']['input']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<Scalars['float8']['input']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<Scalars['Int']['input']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<Scalars['Int']['input']>;
  resolved?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID of user who resoled the comment */
  resolverId?: InputMaybe<Scalars['uuid']['input']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<Scalars['Int']['input']>;
  /** URL of the livesite screenshot */
  screenshotUrl?: InputMaybe<Scalars['String']['input']>;
  /** Expiration date time of the livesite screenshot */
  screenshotUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Used to create a shorter URL that links to specific messages, such as workflow.design/c/a4dD4s */
  shortLinkSlug?: InputMaybe<Scalars['String']['input']>;
  /** remove - old format for storing messages */
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
  /** Content of the message */
  textJsonTiptap?: InputMaybe<Scalars['jsonb']['input']>;
  /** the ID of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableId?: InputMaybe<Scalars['uuid']['input']>;
  /** the type of the root item that the item is on, typically a Document or for an on-asset comment, a Version */
  threadableType?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** [on-asset comment][sites] check if needs consolidating with url - the path that the comment is stored at so that the comment is only shown on the correct page */
  urlPathname?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** [on-asset comment]video] the time stamp of the comment in format MM:SS */
  videoTimeStamp?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type MessagesSumFields = {
  __typename?: 'MessagesSumFields';
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: Maybe<Scalars['Int']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: Maybe<Scalars['Int']['output']>;
  /** type of message */
  category?: Maybe<Scalars['Int']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: Maybe<Scalars['Int']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: Maybe<Scalars['float8']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: Maybe<Scalars['float8']['output']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: Maybe<Scalars['Int']['output']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: Maybe<Scalars['Int']['output']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "messages" */
export type MessagesSumOrderBy = {
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<OrderBy>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<OrderBy>;
  /** type of message */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<OrderBy>;
};

/** update columns of table "messages" */
export enum MessagesUpdateColumn {
  /** column name */
  AiCheckRunId = 'aiCheckRunId',
  /** column name */
  ApprovalChangeVersionNumber = 'approvalChangeVersionNumber',
  /** column name */
  ApprovalStatusChange = 'approvalStatusChange',
  /** column name */
  BrowserName = 'browserName',
  /** column name */
  Category = 'category',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CssSelector = 'cssSelector',
  /** column name */
  FigmaId = 'figmaId',
  /** column name */
  Id = 'id',
  /** column name */
  IsAiGenerated = 'isAiGenerated',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  MessagableId = 'messagableId',
  /** column name */
  MessagableType = 'messagableType',
  /** column name */
  Page = 'page',
  /** column name */
  ParentDocumentId = 'parentDocumentId',
  /** column name */
  ParentMessageId = 'parentMessageId',
  /** column name */
  ParentVersionId = 'parentVersionId',
  /** column name */
  PositionPercentageX = 'positionPercentageX',
  /** column name */
  PositionPercentageY = 'positionPercentageY',
  /** column name */
  PositionX = 'positionX',
  /** column name */
  PositionY = 'positionY',
  /** column name */
  Resolved = 'resolved',
  /** column name */
  ResolverId = 'resolverId',
  /** column name */
  ScreenWidth = 'screenWidth',
  /** column name */
  ScreenshotUrl = 'screenshotUrl',
  /** column name */
  ScreenshotUrlExpiresAt = 'screenshotUrlExpiresAt',
  /** column name */
  ShortLinkSlug = 'shortLinkSlug',
  /** column name */
  TextJson = 'textJson',
  /** column name */
  TextJsonTiptap = 'textJsonTiptap',
  /** column name */
  ThreadableId = 'threadableId',
  /** column name */
  ThreadableType = 'threadableType',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UrlPathname = 'urlPathname',
  /** column name */
  UserId = 'userId',
  /** column name */
  VideoTimeStamp = 'videoTimeStamp'
}

export type MessagesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<MessagesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<MessagesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<MessagesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<MessagesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MessagesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<MessagesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MessagesSetInput>;
  /** filter the rows which have to be updated */
  where: MessagesBoolExp;
};

/** aggregate varPop on columns */
export type MessagesVarPopFields = {
  __typename?: 'MessagesVarPopFields';
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: Maybe<Scalars['Float']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: Maybe<Scalars['Float']['output']>;
  /** type of message */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "messages" */
export type MessagesVarPopOrderBy = {
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<OrderBy>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<OrderBy>;
  /** type of message */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type MessagesVarSampFields = {
  __typename?: 'MessagesVarSampFields';
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: Maybe<Scalars['Float']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: Maybe<Scalars['Float']['output']>;
  /** type of message */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "messages" */
export type MessagesVarSampOrderBy = {
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<OrderBy>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<OrderBy>;
  /** type of message */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type MessagesVarianceFields = {
  __typename?: 'MessagesVarianceFields';
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: Maybe<Scalars['Float']['output']>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: Maybe<Scalars['Float']['output']>;
  /** type of message */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: Maybe<Scalars['Float']['output']>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "messages" */
export type MessagesVarianceOrderBy = {
  /** [approval][notifications] used for approval change system messages */
  approvalChangeVersionNumber?: InputMaybe<OrderBy>;
  /** [approval][notifications] used for approval change system messages */
  approvalStatusChange?: InputMaybe<OrderBy>;
  /** type of message */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [on-asset comment] Some versions show the items on separate canvases, with  */
  page?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageX?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] for websites, we store the percentage position within the div that the message is attached to. This allows the comment to be repositioned within the div if the div changes size due to responsive websites */
  positionPercentageY?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective x-coordinate position of the comment */
  positionX?: InputMaybe<OrderBy>;
  /** [on-asset comment] objective y-coordinate position of the comment */
  positionY?: InputMaybe<OrderBy>;
  /** [on-asset comment][sites] the width of the screen when this comment was added */
  screenWidth?: InputMaybe<OrderBy>;
};

export type MultipartUploadPartInput = {
  ETag: Scalars['String']['input'];
  partNumber: Scalars['Int']['input'];
};

/** columns and relationships of "my_document_users" */
export type MyDocumentUsers = {
  __typename?: 'MyDocumentUsers';
  documentId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  isViewOnly?: Maybe<Scalars['Boolean']['output']>;
  lastReadDiscussionAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "my_document_users" */
export type MyDocumentUsersAggregate = {
  __typename?: 'MyDocumentUsersAggregate';
  aggregate?: Maybe<MyDocumentUsersAggregateFields>;
  nodes: Array<MyDocumentUsers>;
};

/** aggregate fields of "my_document_users" */
export type MyDocumentUsersAggregateFields = {
  __typename?: 'MyDocumentUsersAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<MyDocumentUsersMaxFields>;
  min?: Maybe<MyDocumentUsersMinFields>;
};


/** aggregate fields of "my_document_users" */
export type MyDocumentUsersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MyDocumentUsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "my_document_users". All fields are combined with a logical 'AND'. */
export type MyDocumentUsersBoolExp = {
  _and?: InputMaybe<Array<MyDocumentUsersBoolExp>>;
  _not?: InputMaybe<MyDocumentUsersBoolExp>;
  _or?: InputMaybe<Array<MyDocumentUsersBoolExp>>;
  documentId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isViewOnly?: InputMaybe<BooleanComparisonExp>;
  lastReadDiscussionAt?: InputMaybe<TimestamptzComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** input type for inserting data into table "my_document_users" */
export type MyDocumentUsersInsertInput = {
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isViewOnly?: InputMaybe<Scalars['Boolean']['input']>;
  lastReadDiscussionAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type MyDocumentUsersMaxFields = {
  __typename?: 'MyDocumentUsersMaxFields';
  documentId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastReadDiscussionAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type MyDocumentUsersMinFields = {
  __typename?: 'MyDocumentUsersMinFields';
  documentId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastReadDiscussionAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "my_document_users" */
export type MyDocumentUsersMutationResponse = {
  __typename?: 'MyDocumentUsersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MyDocumentUsers>;
};

/** input type for inserting object relation for remote table "my_document_users" */
export type MyDocumentUsersObjRelInsertInput = {
  data: MyDocumentUsersInsertInput;
};

/** Ordering options when selecting data from "my_document_users". */
export type MyDocumentUsersOrderBy = {
  documentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isViewOnly?: InputMaybe<OrderBy>;
  lastReadDiscussionAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** select columns of table "my_document_users" */
export enum MyDocumentUsersSelectColumn {
  /** column name */
  DocumentId = 'documentId',
  /** column name */
  Id = 'id',
  /** column name */
  IsViewOnly = 'isViewOnly',
  /** column name */
  LastReadDiscussionAt = 'lastReadDiscussionAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "my_document_users" */
export type MyDocumentUsersSetInput = {
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isViewOnly?: InputMaybe<Scalars['Boolean']['input']>;
  lastReadDiscussionAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "my_document_users" */
export type MyDocumentUsersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: MyDocumentUsersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MyDocumentUsersStreamCursorValueInput = {
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isViewOnly?: InputMaybe<Scalars['Boolean']['input']>;
  lastReadDiscussionAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

export type MyDocumentUsersUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MyDocumentUsersSetInput>;
  /** filter the rows which have to be updated */
  where: MyDocumentUsersBoolExp;
};

/** columns and relationships of "my_user_info" */
export type MyUserInfo = {
  __typename?: 'MyUserInfo';
  color?: Maybe<Scalars['String']['output']>;
  currentAccountId?: Maybe<Scalars['uuid']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  guidedTour?: Maybe<GuidedTours>;
  hasRunEnableApprovals?: Maybe<Scalars['Boolean']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  profilePictureThumbnailUrl?: Maybe<Scalars['String']['output']>;
  profilePictureUrl?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "my_user_info" */
export type MyUserInfoAggregate = {
  __typename?: 'MyUserInfoAggregate';
  aggregate?: Maybe<MyUserInfoAggregateFields>;
  nodes: Array<MyUserInfo>;
};

/** aggregate fields of "my_user_info" */
export type MyUserInfoAggregateFields = {
  __typename?: 'MyUserInfoAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<MyUserInfoMaxFields>;
  min?: Maybe<MyUserInfoMinFields>;
};


/** aggregate fields of "my_user_info" */
export type MyUserInfoAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MyUserInfoSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "my_user_info". All fields are combined with a logical 'AND'. */
export type MyUserInfoBoolExp = {
  _and?: InputMaybe<Array<MyUserInfoBoolExp>>;
  _not?: InputMaybe<MyUserInfoBoolExp>;
  _or?: InputMaybe<Array<MyUserInfoBoolExp>>;
  color?: InputMaybe<StringComparisonExp>;
  currentAccountId?: InputMaybe<UuidComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  firstName?: InputMaybe<StringComparisonExp>;
  guidedTour?: InputMaybe<GuidedToursBoolExp>;
  hasRunEnableApprovals?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastName?: InputMaybe<StringComparisonExp>;
  profilePictureThumbnailUrl?: InputMaybe<StringComparisonExp>;
  profilePictureUrl?: InputMaybe<StringComparisonExp>;
};

/** input type for inserting data into table "my_user_info" */
export type MyUserInfoInsertInput = {
  color?: InputMaybe<Scalars['String']['input']>;
  currentAccountId?: InputMaybe<Scalars['uuid']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  guidedTour?: InputMaybe<GuidedToursObjRelInsertInput>;
  hasRunEnableApprovals?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  profilePictureThumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  profilePictureUrl?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type MyUserInfoMaxFields = {
  __typename?: 'MyUserInfoMaxFields';
  color?: Maybe<Scalars['String']['output']>;
  currentAccountId?: Maybe<Scalars['uuid']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  profilePictureThumbnailUrl?: Maybe<Scalars['String']['output']>;
  profilePictureUrl?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type MyUserInfoMinFields = {
  __typename?: 'MyUserInfoMinFields';
  color?: Maybe<Scalars['String']['output']>;
  currentAccountId?: Maybe<Scalars['uuid']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  profilePictureThumbnailUrl?: Maybe<Scalars['String']['output']>;
  profilePictureUrl?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "my_user_info" */
export type MyUserInfoMutationResponse = {
  __typename?: 'MyUserInfoMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MyUserInfo>;
};

/** Ordering options when selecting data from "my_user_info". */
export type MyUserInfoOrderBy = {
  color?: InputMaybe<OrderBy>;
  currentAccountId?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  firstName?: InputMaybe<OrderBy>;
  guidedTour?: InputMaybe<GuidedToursOrderBy>;
  hasRunEnableApprovals?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastName?: InputMaybe<OrderBy>;
  profilePictureThumbnailUrl?: InputMaybe<OrderBy>;
  profilePictureUrl?: InputMaybe<OrderBy>;
};

/** select columns of table "my_user_info" */
export enum MyUserInfoSelectColumn {
  /** column name */
  Color = 'color',
  /** column name */
  CurrentAccountId = 'currentAccountId',
  /** column name */
  Email = 'email',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  HasRunEnableApprovals = 'hasRunEnableApprovals',
  /** column name */
  Id = 'id',
  /** column name */
  LastName = 'lastName',
  /** column name */
  ProfilePictureThumbnailUrl = 'profilePictureThumbnailUrl',
  /** column name */
  ProfilePictureUrl = 'profilePictureUrl'
}

/** input type for updating data in table "my_user_info" */
export type MyUserInfoSetInput = {
  color?: InputMaybe<Scalars['String']['input']>;
  currentAccountId?: InputMaybe<Scalars['uuid']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  hasRunEnableApprovals?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  profilePictureThumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  profilePictureUrl?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "my_user_info" */
export type MyUserInfoStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: MyUserInfoStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MyUserInfoStreamCursorValueInput = {
  color?: InputMaybe<Scalars['String']['input']>;
  currentAccountId?: InputMaybe<Scalars['uuid']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  hasRunEnableApprovals?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  profilePictureThumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  profilePictureUrl?: InputMaybe<Scalars['String']['input']>;
};

export type MyUserInfoUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MyUserInfoSetInput>;
  /** filter the rows which have to be updated */
  where: MyUserInfoBoolExp;
};

/** Stores a single in-app notification. This appears in the in-app inbox and will be sent over Slack and as an email */
export type Notifications = {
  __typename?: 'Notifications';
  /** An object relationship */
  account: Accounts;
  accountId: Scalars['uuid']['output'];
  /** [navigation] Additional parameters to add to the url to send the user to */
  additionalUrlParams?: Maybe<Scalars['jsonb']['output']>;
  /** type of notification, e.g. assigned, mentioned */
  category: Scalars['Int']['output'];
  createdAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  document: Documents;
  /** The document that the action that the notification refers to is on */
  documentId: Scalars['uuid']['output'];
  /** Has the user marked the notification in the inbox as Done - this allows them to keep tasks in the inbox that they want to return to later, versus ones that they are happy to keep */
  done: Scalars['Boolean']['output'];
  /** Whether or not the email relating to this notification been sent */
  emailed: Scalars['Boolean']['output'];
  id: Scalars['uuid']['output'];
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  notifiableDocument?: Maybe<Documents>;
  /** The document that the notification is about */
  notifiableDocumentId?: Maybe<Scalars['uuid']['output']>;
  /** id of the item that the notification is about, e.g. a message */
  notifiableId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  notifiableMention?: Maybe<Mentions>;
  /** The mention that the notification is about */
  notifiableMentionId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  notifiableMessage?: Maybe<Messages>;
  /** The message that the notification is about */
  notifiableMessageId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  notifiableRecording?: Maybe<Recordings>;
  /** The recording that the notification is about */
  notifiableRecordingId?: Maybe<Scalars['uuid']['output']>;
  /** type of the item that the notification is about, e.g. a message */
  notifiableType?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  notifiableVersion?: Maybe<Versions>;
  /** The version that the notification is about */
  notifiableVersionId?: Maybe<Scalars['uuid']['output']>;
  /** User whose action triggered the notification, if any */
  originatorId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  originatorUser?: Maybe<Users>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: Maybe<Scalars['Int']['output']>;
  /** Whether the notification has been processed for email. Not the same as emailed. */
  processedForEmail: Scalars['Boolean']['output'];
  /** has the user viewed the notification once */
  read: Scalars['Boolean']['output'];
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: Maybe<Scalars['Int']['output']>;
  /** Whether the notification has been sent to slack */
  slacked: Scalars['Boolean']['output'];
  updatedAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Users;
  /** User who is recipient of the notification */
  userId: Scalars['uuid']['output'];
};


/** Stores a single in-app notification. This appears in the in-app inbox and will be sent over Slack and as an email */
export type NotificationsAdditionalUrlParamsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "notifications" */
export type NotificationsAggregate = {
  __typename?: 'NotificationsAggregate';
  aggregate?: Maybe<NotificationsAggregateFields>;
  nodes: Array<Notifications>;
};

export type NotificationsAggregateBoolExp = {
  bool_and?: InputMaybe<NotificationsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<NotificationsAggregateBoolExpBool_Or>;
  count?: InputMaybe<NotificationsAggregateBoolExpCount>;
};

/** aggregate fields of "notifications" */
export type NotificationsAggregateFields = {
  __typename?: 'NotificationsAggregateFields';
  avg?: Maybe<NotificationsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<NotificationsMaxFields>;
  min?: Maybe<NotificationsMinFields>;
  stddev?: Maybe<NotificationsStddevFields>;
  stddevPop?: Maybe<NotificationsStddevPopFields>;
  stddevSamp?: Maybe<NotificationsStddevSampFields>;
  sum?: Maybe<NotificationsSumFields>;
  varPop?: Maybe<NotificationsVarPopFields>;
  varSamp?: Maybe<NotificationsVarSampFields>;
  variance?: Maybe<NotificationsVarianceFields>;
};


/** aggregate fields of "notifications" */
export type NotificationsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<NotificationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "notifications" */
export type NotificationsAggregateOrderBy = {
  avg?: InputMaybe<NotificationsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<NotificationsMaxOrderBy>;
  min?: InputMaybe<NotificationsMinOrderBy>;
  stddev?: InputMaybe<NotificationsStddevOrderBy>;
  stddevPop?: InputMaybe<NotificationsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<NotificationsStddevSampOrderBy>;
  sum?: InputMaybe<NotificationsSumOrderBy>;
  varPop?: InputMaybe<NotificationsVarPopOrderBy>;
  varSamp?: InputMaybe<NotificationsVarSampOrderBy>;
  variance?: InputMaybe<NotificationsVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type NotificationsAppendInput = {
  /** [navigation] Additional parameters to add to the url to send the user to */
  additionalUrlParams?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "notifications" */
export type NotificationsArrRelInsertInput = {
  data: Array<NotificationsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<NotificationsOnConflict>;
};

/** aggregate avg on columns */
export type NotificationsAvgFields = {
  __typename?: 'NotificationsAvgFields';
  /** type of notification, e.g. assigned, mentioned */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: Maybe<Scalars['Float']['output']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "notifications" */
export type NotificationsAvgOrderBy = {
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<OrderBy>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "notifications". All fields are combined with a logical 'AND'. */
export type NotificationsBoolExp = {
  _and?: InputMaybe<Array<NotificationsBoolExp>>;
  _not?: InputMaybe<NotificationsBoolExp>;
  _or?: InputMaybe<Array<NotificationsBoolExp>>;
  account?: InputMaybe<AccountsBoolExp>;
  accountId?: InputMaybe<UuidComparisonExp>;
  additionalUrlParams?: InputMaybe<JsonbComparisonExp>;
  category?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  document?: InputMaybe<DocumentsBoolExp>;
  documentId?: InputMaybe<UuidComparisonExp>;
  done?: InputMaybe<BooleanComparisonExp>;
  emailed?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  notifiableDocument?: InputMaybe<DocumentsBoolExp>;
  notifiableDocumentId?: InputMaybe<UuidComparisonExp>;
  notifiableId?: InputMaybe<UuidComparisonExp>;
  notifiableMention?: InputMaybe<MentionsBoolExp>;
  notifiableMentionId?: InputMaybe<UuidComparisonExp>;
  notifiableMessage?: InputMaybe<MessagesBoolExp>;
  notifiableMessageId?: InputMaybe<UuidComparisonExp>;
  notifiableRecording?: InputMaybe<RecordingsBoolExp>;
  notifiableRecordingId?: InputMaybe<UuidComparisonExp>;
  notifiableType?: InputMaybe<StringComparisonExp>;
  notifiableVersion?: InputMaybe<VersionsBoolExp>;
  notifiableVersionId?: InputMaybe<UuidComparisonExp>;
  originatorId?: InputMaybe<UuidComparisonExp>;
  originatorUser?: InputMaybe<UsersBoolExp>;
  page?: InputMaybe<IntComparisonExp>;
  processedForEmail?: InputMaybe<BooleanComparisonExp>;
  read?: InputMaybe<BooleanComparisonExp>;
  screenWidth?: InputMaybe<IntComparisonExp>;
  slacked?: InputMaybe<BooleanComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "notifications" */
export enum NotificationsConstraint {
  /** unique or primary key constraint on columns "id" */
  NotificationsPkey = 'notifications_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type NotificationsDeleteAtPathInput = {
  /** [navigation] Additional parameters to add to the url to send the user to */
  additionalUrlParams?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type NotificationsDeleteElemInput = {
  /** [navigation] Additional parameters to add to the url to send the user to */
  additionalUrlParams?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type NotificationsDeleteKeyInput = {
  /** [navigation] Additional parameters to add to the url to send the user to */
  additionalUrlParams?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "notifications" */
export type NotificationsIncInput = {
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<Scalars['Int']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<Scalars['Int']['input']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "notifications" */
export type NotificationsInsertInput = {
  account?: InputMaybe<AccountsObjRelInsertInput>;
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [navigation] Additional parameters to add to the url to send the user to */
  additionalUrlParams?: InputMaybe<Scalars['jsonb']['input']>;
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  document?: InputMaybe<DocumentsObjRelInsertInput>;
  /** The document that the action that the notification refers to is on */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** Has the user marked the notification in the inbox as Done - this allows them to keep tasks in the inbox that they want to return to later, versus ones that they are happy to keep */
  done?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not the email relating to this notification been sent */
  emailed?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  notifiableDocument?: InputMaybe<DocumentsObjRelInsertInput>;
  /** The document that the notification is about */
  notifiableDocumentId?: InputMaybe<Scalars['uuid']['input']>;
  /** id of the item that the notification is about, e.g. a message */
  notifiableId?: InputMaybe<Scalars['uuid']['input']>;
  notifiableMention?: InputMaybe<MentionsObjRelInsertInput>;
  /** The mention that the notification is about */
  notifiableMentionId?: InputMaybe<Scalars['uuid']['input']>;
  notifiableMessage?: InputMaybe<MessagesObjRelInsertInput>;
  /** The message that the notification is about */
  notifiableMessageId?: InputMaybe<Scalars['uuid']['input']>;
  notifiableRecording?: InputMaybe<RecordingsObjRelInsertInput>;
  /** The recording that the notification is about */
  notifiableRecordingId?: InputMaybe<Scalars['uuid']['input']>;
  /** type of the item that the notification is about, e.g. a message */
  notifiableType?: InputMaybe<Scalars['String']['input']>;
  notifiableVersion?: InputMaybe<VersionsObjRelInsertInput>;
  /** The version that the notification is about */
  notifiableVersionId?: InputMaybe<Scalars['uuid']['input']>;
  /** User whose action triggered the notification, if any */
  originatorId?: InputMaybe<Scalars['uuid']['input']>;
  originatorUser?: InputMaybe<UsersObjRelInsertInput>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<Scalars['Int']['input']>;
  /** Whether the notification has been processed for email. Not the same as emailed. */
  processedForEmail?: InputMaybe<Scalars['Boolean']['input']>;
  /** has the user viewed the notification once */
  read?: InputMaybe<Scalars['Boolean']['input']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<Scalars['Int']['input']>;
  /** Whether the notification has been sent to slack */
  slacked?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  /** User who is recipient of the notification */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type NotificationsMaxFields = {
  __typename?: 'NotificationsMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** type of notification, e.g. assigned, mentioned */
  category?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** The document that the action that the notification refers to is on */
  documentId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** The document that the notification is about */
  notifiableDocumentId?: Maybe<Scalars['uuid']['output']>;
  /** id of the item that the notification is about, e.g. a message */
  notifiableId?: Maybe<Scalars['uuid']['output']>;
  /** The mention that the notification is about */
  notifiableMentionId?: Maybe<Scalars['uuid']['output']>;
  /** The message that the notification is about */
  notifiableMessageId?: Maybe<Scalars['uuid']['output']>;
  /** The recording that the notification is about */
  notifiableRecordingId?: Maybe<Scalars['uuid']['output']>;
  /** type of the item that the notification is about, e.g. a message */
  notifiableType?: Maybe<Scalars['String']['output']>;
  /** The version that the notification is about */
  notifiableVersionId?: Maybe<Scalars['uuid']['output']>;
  /** User whose action triggered the notification, if any */
  originatorId?: Maybe<Scalars['uuid']['output']>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: Maybe<Scalars['Int']['output']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User who is recipient of the notification */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "notifications" */
export type NotificationsMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** The document that the action that the notification refers to is on */
  documentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The document that the notification is about */
  notifiableDocumentId?: InputMaybe<OrderBy>;
  /** id of the item that the notification is about, e.g. a message */
  notifiableId?: InputMaybe<OrderBy>;
  /** The mention that the notification is about */
  notifiableMentionId?: InputMaybe<OrderBy>;
  /** The message that the notification is about */
  notifiableMessageId?: InputMaybe<OrderBy>;
  /** The recording that the notification is about */
  notifiableRecordingId?: InputMaybe<OrderBy>;
  /** type of the item that the notification is about, e.g. a message */
  notifiableType?: InputMaybe<OrderBy>;
  /** The version that the notification is about */
  notifiableVersionId?: InputMaybe<OrderBy>;
  /** User whose action triggered the notification, if any */
  originatorId?: InputMaybe<OrderBy>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<OrderBy>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** User who is recipient of the notification */
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type NotificationsMinFields = {
  __typename?: 'NotificationsMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** type of notification, e.g. assigned, mentioned */
  category?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** The document that the action that the notification refers to is on */
  documentId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** The document that the notification is about */
  notifiableDocumentId?: Maybe<Scalars['uuid']['output']>;
  /** id of the item that the notification is about, e.g. a message */
  notifiableId?: Maybe<Scalars['uuid']['output']>;
  /** The mention that the notification is about */
  notifiableMentionId?: Maybe<Scalars['uuid']['output']>;
  /** The message that the notification is about */
  notifiableMessageId?: Maybe<Scalars['uuid']['output']>;
  /** The recording that the notification is about */
  notifiableRecordingId?: Maybe<Scalars['uuid']['output']>;
  /** type of the item that the notification is about, e.g. a message */
  notifiableType?: Maybe<Scalars['String']['output']>;
  /** The version that the notification is about */
  notifiableVersionId?: Maybe<Scalars['uuid']['output']>;
  /** User whose action triggered the notification, if any */
  originatorId?: Maybe<Scalars['uuid']['output']>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: Maybe<Scalars['Int']['output']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User who is recipient of the notification */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "notifications" */
export type NotificationsMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** The document that the action that the notification refers to is on */
  documentId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The document that the notification is about */
  notifiableDocumentId?: InputMaybe<OrderBy>;
  /** id of the item that the notification is about, e.g. a message */
  notifiableId?: InputMaybe<OrderBy>;
  /** The mention that the notification is about */
  notifiableMentionId?: InputMaybe<OrderBy>;
  /** The message that the notification is about */
  notifiableMessageId?: InputMaybe<OrderBy>;
  /** The recording that the notification is about */
  notifiableRecordingId?: InputMaybe<OrderBy>;
  /** type of the item that the notification is about, e.g. a message */
  notifiableType?: InputMaybe<OrderBy>;
  /** The version that the notification is about */
  notifiableVersionId?: InputMaybe<OrderBy>;
  /** User whose action triggered the notification, if any */
  originatorId?: InputMaybe<OrderBy>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<OrderBy>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** User who is recipient of the notification */
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "notifications" */
export type NotificationsMutationResponse = {
  __typename?: 'NotificationsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Notifications>;
};

/** on_conflict condition type for table "notifications" */
export type NotificationsOnConflict = {
  constraint: NotificationsConstraint;
  updateColumns?: Array<NotificationsUpdateColumn>;
  where?: InputMaybe<NotificationsBoolExp>;
};

/** Ordering options when selecting data from "notifications". */
export type NotificationsOrderBy = {
  account?: InputMaybe<AccountsOrderBy>;
  accountId?: InputMaybe<OrderBy>;
  additionalUrlParams?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  document?: InputMaybe<DocumentsOrderBy>;
  documentId?: InputMaybe<OrderBy>;
  done?: InputMaybe<OrderBy>;
  emailed?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  notifiableDocument?: InputMaybe<DocumentsOrderBy>;
  notifiableDocumentId?: InputMaybe<OrderBy>;
  notifiableId?: InputMaybe<OrderBy>;
  notifiableMention?: InputMaybe<MentionsOrderBy>;
  notifiableMentionId?: InputMaybe<OrderBy>;
  notifiableMessage?: InputMaybe<MessagesOrderBy>;
  notifiableMessageId?: InputMaybe<OrderBy>;
  notifiableRecording?: InputMaybe<RecordingsOrderBy>;
  notifiableRecordingId?: InputMaybe<OrderBy>;
  notifiableType?: InputMaybe<OrderBy>;
  notifiableVersion?: InputMaybe<VersionsOrderBy>;
  notifiableVersionId?: InputMaybe<OrderBy>;
  originatorId?: InputMaybe<OrderBy>;
  originatorUser?: InputMaybe<UsersOrderBy>;
  page?: InputMaybe<OrderBy>;
  processedForEmail?: InputMaybe<OrderBy>;
  read?: InputMaybe<OrderBy>;
  screenWidth?: InputMaybe<OrderBy>;
  slacked?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: notifications */
export type NotificationsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type NotificationsPrependInput = {
  /** [navigation] Additional parameters to add to the url to send the user to */
  additionalUrlParams?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "notifications" */
export enum NotificationsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  AdditionalUrlParams = 'additionalUrlParams',
  /** column name */
  Category = 'category',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DocumentId = 'documentId',
  /** column name */
  Done = 'done',
  /** column name */
  Emailed = 'emailed',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  NotifiableDocumentId = 'notifiableDocumentId',
  /** column name */
  NotifiableId = 'notifiableId',
  /** column name */
  NotifiableMentionId = 'notifiableMentionId',
  /** column name */
  NotifiableMessageId = 'notifiableMessageId',
  /** column name */
  NotifiableRecordingId = 'notifiableRecordingId',
  /** column name */
  NotifiableType = 'notifiableType',
  /** column name */
  NotifiableVersionId = 'notifiableVersionId',
  /** column name */
  OriginatorId = 'originatorId',
  /** column name */
  Page = 'page',
  /** column name */
  ProcessedForEmail = 'processedForEmail',
  /** column name */
  Read = 'read',
  /** column name */
  ScreenWidth = 'screenWidth',
  /** column name */
  Slacked = 'slacked',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** select "notificationsAggregateBoolExpBool_andArgumentsColumns" columns of table "notifications" */
export enum NotificationsSelectColumnNotificationsAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  Done = 'done',
  /** column name */
  Emailed = 'emailed',
  /** column name */
  ProcessedForEmail = 'processedForEmail',
  /** column name */
  Read = 'read',
  /** column name */
  Slacked = 'slacked'
}

/** select "notificationsAggregateBoolExpBool_orArgumentsColumns" columns of table "notifications" */
export enum NotificationsSelectColumnNotificationsAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  Done = 'done',
  /** column name */
  Emailed = 'emailed',
  /** column name */
  ProcessedForEmail = 'processedForEmail',
  /** column name */
  Read = 'read',
  /** column name */
  Slacked = 'slacked'
}

/** input type for updating data in table "notifications" */
export type NotificationsSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [navigation] Additional parameters to add to the url to send the user to */
  additionalUrlParams?: InputMaybe<Scalars['jsonb']['input']>;
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The document that the action that the notification refers to is on */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** Has the user marked the notification in the inbox as Done - this allows them to keep tasks in the inbox that they want to return to later, versus ones that they are happy to keep */
  done?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not the email relating to this notification been sent */
  emailed?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The document that the notification is about */
  notifiableDocumentId?: InputMaybe<Scalars['uuid']['input']>;
  /** id of the item that the notification is about, e.g. a message */
  notifiableId?: InputMaybe<Scalars['uuid']['input']>;
  /** The mention that the notification is about */
  notifiableMentionId?: InputMaybe<Scalars['uuid']['input']>;
  /** The message that the notification is about */
  notifiableMessageId?: InputMaybe<Scalars['uuid']['input']>;
  /** The recording that the notification is about */
  notifiableRecordingId?: InputMaybe<Scalars['uuid']['input']>;
  /** type of the item that the notification is about, e.g. a message */
  notifiableType?: InputMaybe<Scalars['String']['input']>;
  /** The version that the notification is about */
  notifiableVersionId?: InputMaybe<Scalars['uuid']['input']>;
  /** User whose action triggered the notification, if any */
  originatorId?: InputMaybe<Scalars['uuid']['input']>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<Scalars['Int']['input']>;
  /** Whether the notification has been processed for email. Not the same as emailed. */
  processedForEmail?: InputMaybe<Scalars['Boolean']['input']>;
  /** has the user viewed the notification once */
  read?: InputMaybe<Scalars['Boolean']['input']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<Scalars['Int']['input']>;
  /** Whether the notification has been sent to slack */
  slacked?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User who is recipient of the notification */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type NotificationsStddevFields = {
  __typename?: 'NotificationsStddevFields';
  /** type of notification, e.g. assigned, mentioned */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: Maybe<Scalars['Float']['output']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "notifications" */
export type NotificationsStddevOrderBy = {
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<OrderBy>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type NotificationsStddevPopFields = {
  __typename?: 'NotificationsStddevPopFields';
  /** type of notification, e.g. assigned, mentioned */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: Maybe<Scalars['Float']['output']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "notifications" */
export type NotificationsStddevPopOrderBy = {
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<OrderBy>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type NotificationsStddevSampFields = {
  __typename?: 'NotificationsStddevSampFields';
  /** type of notification, e.g. assigned, mentioned */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: Maybe<Scalars['Float']['output']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "notifications" */
export type NotificationsStddevSampOrderBy = {
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<OrderBy>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "notifications" */
export type NotificationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: NotificationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type NotificationsStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [navigation] Additional parameters to add to the url to send the user to */
  additionalUrlParams?: InputMaybe<Scalars['jsonb']['input']>;
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The document that the action that the notification refers to is on */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** Has the user marked the notification in the inbox as Done - this allows them to keep tasks in the inbox that they want to return to later, versus ones that they are happy to keep */
  done?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not the email relating to this notification been sent */
  emailed?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The document that the notification is about */
  notifiableDocumentId?: InputMaybe<Scalars['uuid']['input']>;
  /** id of the item that the notification is about, e.g. a message */
  notifiableId?: InputMaybe<Scalars['uuid']['input']>;
  /** The mention that the notification is about */
  notifiableMentionId?: InputMaybe<Scalars['uuid']['input']>;
  /** The message that the notification is about */
  notifiableMessageId?: InputMaybe<Scalars['uuid']['input']>;
  /** The recording that the notification is about */
  notifiableRecordingId?: InputMaybe<Scalars['uuid']['input']>;
  /** type of the item that the notification is about, e.g. a message */
  notifiableType?: InputMaybe<Scalars['String']['input']>;
  /** The version that the notification is about */
  notifiableVersionId?: InputMaybe<Scalars['uuid']['input']>;
  /** User whose action triggered the notification, if any */
  originatorId?: InputMaybe<Scalars['uuid']['input']>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<Scalars['Int']['input']>;
  /** Whether the notification has been processed for email. Not the same as emailed. */
  processedForEmail?: InputMaybe<Scalars['Boolean']['input']>;
  /** has the user viewed the notification once */
  read?: InputMaybe<Scalars['Boolean']['input']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<Scalars['Int']['input']>;
  /** Whether the notification has been sent to slack */
  slacked?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User who is recipient of the notification */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type NotificationsSumFields = {
  __typename?: 'NotificationsSumFields';
  /** type of notification, e.g. assigned, mentioned */
  category?: Maybe<Scalars['Int']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: Maybe<Scalars['Int']['output']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "notifications" */
export type NotificationsSumOrderBy = {
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<OrderBy>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<OrderBy>;
};

/** update columns of table "notifications" */
export enum NotificationsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  AdditionalUrlParams = 'additionalUrlParams',
  /** column name */
  Category = 'category',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DocumentId = 'documentId',
  /** column name */
  Done = 'done',
  /** column name */
  Emailed = 'emailed',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  NotifiableDocumentId = 'notifiableDocumentId',
  /** column name */
  NotifiableId = 'notifiableId',
  /** column name */
  NotifiableMentionId = 'notifiableMentionId',
  /** column name */
  NotifiableMessageId = 'notifiableMessageId',
  /** column name */
  NotifiableRecordingId = 'notifiableRecordingId',
  /** column name */
  NotifiableType = 'notifiableType',
  /** column name */
  NotifiableVersionId = 'notifiableVersionId',
  /** column name */
  OriginatorId = 'originatorId',
  /** column name */
  Page = 'page',
  /** column name */
  ProcessedForEmail = 'processedForEmail',
  /** column name */
  Read = 'read',
  /** column name */
  ScreenWidth = 'screenWidth',
  /** column name */
  Slacked = 'slacked',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type NotificationsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<NotificationsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<NotificationsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<NotificationsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<NotificationsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<NotificationsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<NotificationsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<NotificationsSetInput>;
  /** filter the rows which have to be updated */
  where: NotificationsBoolExp;
};

/** aggregate varPop on columns */
export type NotificationsVarPopFields = {
  __typename?: 'NotificationsVarPopFields';
  /** type of notification, e.g. assigned, mentioned */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: Maybe<Scalars['Float']['output']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "notifications" */
export type NotificationsVarPopOrderBy = {
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<OrderBy>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type NotificationsVarSampFields = {
  __typename?: 'NotificationsVarSampFields';
  /** type of notification, e.g. assigned, mentioned */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: Maybe<Scalars['Float']['output']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "notifications" */
export type NotificationsVarSampOrderBy = {
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<OrderBy>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type NotificationsVarianceFields = {
  __typename?: 'NotificationsVarianceFields';
  /** type of notification, e.g. assigned, mentioned */
  category?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: Maybe<Scalars['Float']['output']>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "notifications" */
export type NotificationsVarianceOrderBy = {
  /** type of notification, e.g. assigned, mentioned */
  category?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** [navigation] for multi-page assets such as an asset with multiple videos, which page to send the user to */
  page?: InputMaybe<OrderBy>;
  /** [navigation][sites] if the notification is regarding an on-asset comment on a website, what is the screen width of the comment? */
  screenWidth?: InputMaybe<OrderBy>;
};

export type NumberOfSeats = {
  __typename?: 'NumberOfSeats';
  creative: Scalars['Int']['output'];
  teammate: Scalars['Int']['output'];
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type NumericComparisonExp = {
  _eq?: InputMaybe<Scalars['numeric']['input']>;
  _gt?: InputMaybe<Scalars['numeric']['input']>;
  _gte?: InputMaybe<Scalars['numeric']['input']>;
  _in?: InputMaybe<Array<Scalars['numeric']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['numeric']['input']>;
  _lte?: InputMaybe<Scalars['numeric']['input']>;
  _neq?: InputMaybe<Scalars['numeric']['input']>;
  _nin?: InputMaybe<Array<Scalars['numeric']['input']>>;
};

/** column ordering options */
export enum OrderBy {
  /** in ascending order, nulls last */
  Asc = 'ASC',
  /** in ascending order, nulls first */
  AscNullsFirst = 'ASC_NULLS_FIRST',
  /** in ascending order, nulls last */
  AscNullsLast = 'ASC_NULLS_LAST',
  /** in descending order, nulls first */
  Desc = 'DESC',
  /** in descending order, nulls first */
  DescNullsFirst = 'DESC_NULLS_FIRST',
  /** in descending order, nulls last */
  DescNullsLast = 'DESC_NULLS_LAST'
}

export type PageEvent = {
  srcElement: Scalars['String']['input'];
  type: Scalars['String']['input'];
  x: Scalars['Int']['input'];
  y: Scalars['Int']['input'];
};

export type PaidSubscription = {
  __typename?: 'PaidSubscription';
  seatSubscription: SeatSubscriptionDetails;
  storageSubscription: StorageSubscriptionDetails;
};

/** CanvasItem subtype that stores the metadata relating to pdf item. */
export type PdfItems = {
  __typename?: 'PdfItems';
  assetUrlsExpireAt?: Maybe<Scalars['timestamptz']['output']>;
  assets?: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  canvasItem: CanvasItems;
  canvasItemId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  id: Scalars['uuid']['output'];
  /** An object relationship */
  originalPDFStorageObject: StorageObjectsMetadata;
  originalPdfStorageObjectId: Scalars['uuid']['output'];
  /** An object relationship */
  processedPDFMultiStorageObject?: Maybe<StorageMultiObjectsMetadata>;
  processedPagesStorageMultiObjectId?: Maybe<Scalars['uuid']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
};


/** CanvasItem subtype that stores the metadata relating to pdf item. */
export type PdfItemsAssetsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "pdf_items" */
export type PdfItemsAggregate = {
  __typename?: 'PdfItemsAggregate';
  aggregate?: Maybe<PdfItemsAggregateFields>;
  nodes: Array<PdfItems>;
};

/** aggregate fields of "pdf_items" */
export type PdfItemsAggregateFields = {
  __typename?: 'PdfItemsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<PdfItemsMaxFields>;
  min?: Maybe<PdfItemsMinFields>;
};


/** aggregate fields of "pdf_items" */
export type PdfItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PdfItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type PdfItemsAppendInput = {
  assets?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "pdf_items". All fields are combined with a logical 'AND'. */
export type PdfItemsBoolExp = {
  _and?: InputMaybe<Array<PdfItemsBoolExp>>;
  _not?: InputMaybe<PdfItemsBoolExp>;
  _or?: InputMaybe<Array<PdfItemsBoolExp>>;
  assetUrlsExpireAt?: InputMaybe<TimestamptzComparisonExp>;
  assets?: InputMaybe<JsonbComparisonExp>;
  canvasItem?: InputMaybe<CanvasItemsBoolExp>;
  canvasItemId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  originalPDFStorageObject?: InputMaybe<StorageObjectsMetadataBoolExp>;
  originalPdfStorageObjectId?: InputMaybe<UuidComparisonExp>;
  processedPDFMultiStorageObject?: InputMaybe<StorageMultiObjectsMetadataBoolExp>;
  processedPagesStorageMultiObjectId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "pdf_items" */
export enum PdfItemsConstraint {
  /** unique or primary key constraint on columns "canvas_item_id" */
  PdfItemsCanvasItemIdKey = 'pdf_items_canvas_item_id_key',
  /** unique or primary key constraint on columns "id" */
  PdfItemsPkey = 'pdf_items_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type PdfItemsDeleteAtPathInput = {
  assets?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type PdfItemsDeleteElemInput = {
  assets?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type PdfItemsDeleteKeyInput = {
  assets?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "pdf_items" */
export type PdfItemsInsertInput = {
  assetUrlsExpireAt?: InputMaybe<Scalars['timestamptz']['input']>;
  assets?: InputMaybe<Scalars['jsonb']['input']>;
  canvasItem?: InputMaybe<CanvasItemsObjRelInsertInput>;
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  originalPDFStorageObject?: InputMaybe<StorageObjectsMetadataObjRelInsertInput>;
  originalPdfStorageObjectId?: InputMaybe<Scalars['uuid']['input']>;
  processedPDFMultiStorageObject?: InputMaybe<StorageMultiObjectsMetadataObjRelInsertInput>;
  processedPagesStorageMultiObjectId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type PdfItemsMaxFields = {
  __typename?: 'PdfItemsMaxFields';
  assetUrlsExpireAt?: Maybe<Scalars['timestamptz']['output']>;
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  originalPdfStorageObjectId?: Maybe<Scalars['uuid']['output']>;
  processedPagesStorageMultiObjectId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type PdfItemsMinFields = {
  __typename?: 'PdfItemsMinFields';
  assetUrlsExpireAt?: Maybe<Scalars['timestamptz']['output']>;
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  originalPdfStorageObjectId?: Maybe<Scalars['uuid']['output']>;
  processedPagesStorageMultiObjectId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "pdf_items" */
export type PdfItemsMutationResponse = {
  __typename?: 'PdfItemsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PdfItems>;
};

/** input type for inserting object relation for remote table "pdf_items" */
export type PdfItemsObjRelInsertInput = {
  data: PdfItemsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<PdfItemsOnConflict>;
};

/** on_conflict condition type for table "pdf_items" */
export type PdfItemsOnConflict = {
  constraint: PdfItemsConstraint;
  updateColumns?: Array<PdfItemsUpdateColumn>;
  where?: InputMaybe<PdfItemsBoolExp>;
};

/** Ordering options when selecting data from "pdf_items". */
export type PdfItemsOrderBy = {
  assetUrlsExpireAt?: InputMaybe<OrderBy>;
  assets?: InputMaybe<OrderBy>;
  canvasItem?: InputMaybe<CanvasItemsOrderBy>;
  canvasItemId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalPDFStorageObject?: InputMaybe<StorageObjectsMetadataOrderBy>;
  originalPdfStorageObjectId?: InputMaybe<OrderBy>;
  processedPDFMultiStorageObject?: InputMaybe<StorageMultiObjectsMetadataOrderBy>;
  processedPagesStorageMultiObjectId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: pdf_items */
export type PdfItemsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type PdfItemsPrependInput = {
  assets?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "pdf_items" */
export enum PdfItemsSelectColumn {
  /** column name */
  AssetUrlsExpireAt = 'assetUrlsExpireAt',
  /** column name */
  Assets = 'assets',
  /** column name */
  CanvasItemId = 'canvasItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  OriginalPdfStorageObjectId = 'originalPdfStorageObjectId',
  /** column name */
  ProcessedPagesStorageMultiObjectId = 'processedPagesStorageMultiObjectId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "pdf_items" */
export type PdfItemsSetInput = {
  assetUrlsExpireAt?: InputMaybe<Scalars['timestamptz']['input']>;
  assets?: InputMaybe<Scalars['jsonb']['input']>;
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  originalPdfStorageObjectId?: InputMaybe<Scalars['uuid']['input']>;
  processedPagesStorageMultiObjectId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "pdf_items" */
export type PdfItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PdfItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PdfItemsStreamCursorValueInput = {
  assetUrlsExpireAt?: InputMaybe<Scalars['timestamptz']['input']>;
  assets?: InputMaybe<Scalars['jsonb']['input']>;
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  originalPdfStorageObjectId?: InputMaybe<Scalars['uuid']['input']>;
  processedPagesStorageMultiObjectId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "pdf_items" */
export enum PdfItemsUpdateColumn {
  /** column name */
  AssetUrlsExpireAt = 'assetUrlsExpireAt',
  /** column name */
  Assets = 'assets',
  /** column name */
  CanvasItemId = 'canvasItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  OriginalPdfStorageObjectId = 'originalPdfStorageObjectId',
  /** column name */
  ProcessedPagesStorageMultiObjectId = 'processedPagesStorageMultiObjectId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type PdfItemsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<PdfItemsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<PdfItemsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<PdfItemsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<PdfItemsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<PdfItemsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PdfItemsSetInput>;
  /** filter the rows which have to be updated */
  where: PdfItemsBoolExp;
};

export type PortalSession = {
  __typename?: 'PortalSession';
  url: Scalars['String']['output'];
};

export type Price = {
  __typename?: 'Price';
  annual: Scalars['String']['output'];
  monthly: Scalars['String']['output'];
};

export type Prices = {
  __typename?: 'Prices';
  creative: Price;
  teammate: Price;
  unlimited: Price;
};

/** [sidebar][feature needs redesign and re-architecting] - used to manage the individualized folder structure in the projects section of the of the left sidebar of the dashboard. For some reason, currently each user has their own folder structure that they can create, rather than a global one like Notion. Suffice to say, if continuing to offer this feature, we are going to change it. With the current implementation, each folder or project on the sidebar has a project_and_folder_organizer, and project_and_folder_organizers can exist within a parent project_and_folder_organizers. */
export type ProjectAndFolderOrganizers = {
  __typename?: 'ProjectAndFolderOrganizers';
  /** An object relationship */
  account: Accounts;
  accountId: Scalars['uuid']['output'];
  /** foreign key to folder */
  childFolderId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  childProject?: Maybe<Projects>;
  /** An object relationship */
  childProjectFolder?: Maybe<ProjectFolders>;
  /** foreign key to project */
  childProjectId?: Maybe<Scalars['uuid']['output']>;
  createdAt: Scalars['timestamp']['output'];
  id: Scalars['uuid']['output'];
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  organizableId: Scalars['uuid']['output'];
  organizableType: Scalars['String']['output'];
  parentFolderId?: Maybe<Scalars['uuid']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  projectFolder?: Maybe<ProjectFolders>;
  updatedAt: Scalars['timestamp']['output'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid']['output'];
};

/** aggregated selection of "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersAggregate = {
  __typename?: 'ProjectAndFolderOrganizersAggregate';
  aggregate?: Maybe<ProjectAndFolderOrganizersAggregateFields>;
  nodes: Array<ProjectAndFolderOrganizers>;
};

export type ProjectAndFolderOrganizersAggregateBoolExp = {
  count?: InputMaybe<ProjectAndFolderOrganizersAggregateBoolExpCount>;
};

/** aggregate fields of "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersAggregateFields = {
  __typename?: 'ProjectAndFolderOrganizersAggregateFields';
  avg?: Maybe<ProjectAndFolderOrganizersAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ProjectAndFolderOrganizersMaxFields>;
  min?: Maybe<ProjectAndFolderOrganizersMinFields>;
  stddev?: Maybe<ProjectAndFolderOrganizersStddevFields>;
  stddevPop?: Maybe<ProjectAndFolderOrganizersStddevPopFields>;
  stddevSamp?: Maybe<ProjectAndFolderOrganizersStddevSampFields>;
  sum?: Maybe<ProjectAndFolderOrganizersSumFields>;
  varPop?: Maybe<ProjectAndFolderOrganizersVarPopFields>;
  varSamp?: Maybe<ProjectAndFolderOrganizersVarSampFields>;
  variance?: Maybe<ProjectAndFolderOrganizersVarianceFields>;
};


/** aggregate fields of "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ProjectAndFolderOrganizersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersAggregateOrderBy = {
  avg?: InputMaybe<ProjectAndFolderOrganizersAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ProjectAndFolderOrganizersMaxOrderBy>;
  min?: InputMaybe<ProjectAndFolderOrganizersMinOrderBy>;
  stddev?: InputMaybe<ProjectAndFolderOrganizersStddevOrderBy>;
  stddevPop?: InputMaybe<ProjectAndFolderOrganizersStddevPopOrderBy>;
  stddevSamp?: InputMaybe<ProjectAndFolderOrganizersStddevSampOrderBy>;
  sum?: InputMaybe<ProjectAndFolderOrganizersSumOrderBy>;
  varPop?: InputMaybe<ProjectAndFolderOrganizersVarPopOrderBy>;
  varSamp?: InputMaybe<ProjectAndFolderOrganizersVarSampOrderBy>;
  variance?: InputMaybe<ProjectAndFolderOrganizersVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersArrRelInsertInput = {
  data: Array<ProjectAndFolderOrganizersInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<ProjectAndFolderOrganizersOnConflict>;
};

/** aggregate avg on columns */
export type ProjectAndFolderOrganizersAvgFields = {
  __typename?: 'ProjectAndFolderOrganizersAvgFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersAvgOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "project_and_folder_organizers". All fields are combined with a logical 'AND'. */
export type ProjectAndFolderOrganizersBoolExp = {
  _and?: InputMaybe<Array<ProjectAndFolderOrganizersBoolExp>>;
  _not?: InputMaybe<ProjectAndFolderOrganizersBoolExp>;
  _or?: InputMaybe<Array<ProjectAndFolderOrganizersBoolExp>>;
  account?: InputMaybe<AccountsBoolExp>;
  accountId?: InputMaybe<UuidComparisonExp>;
  childFolderId?: InputMaybe<UuidComparisonExp>;
  childProject?: InputMaybe<ProjectsBoolExp>;
  childProjectFolder?: InputMaybe<ProjectFoldersBoolExp>;
  childProjectId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  organizableId?: InputMaybe<UuidComparisonExp>;
  organizableType?: InputMaybe<StringComparisonExp>;
  parentFolderId?: InputMaybe<UuidComparisonExp>;
  position?: InputMaybe<IntComparisonExp>;
  projectFolder?: InputMaybe<ProjectFoldersBoolExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "project_and_folder_organizers" */
export enum ProjectAndFolderOrganizersConstraint {
  /** unique or primary key constraint on columns "id" */
  ProjectAndFolderOrganizersPkey = 'project_and_folder_organizers_pkey'
}

/** input type for incrementing numeric columns in table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersIncInput = {
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersInsertInput = {
  account?: InputMaybe<AccountsObjRelInsertInput>;
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** foreign key to folder */
  childFolderId?: InputMaybe<Scalars['uuid']['input']>;
  childProject?: InputMaybe<ProjectsObjRelInsertInput>;
  childProjectFolder?: InputMaybe<ProjectFoldersObjRelInsertInput>;
  /** foreign key to project */
  childProjectId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  organizableId?: InputMaybe<Scalars['uuid']['input']>;
  organizableType?: InputMaybe<Scalars['String']['input']>;
  parentFolderId?: InputMaybe<Scalars['uuid']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  projectFolder?: InputMaybe<ProjectFoldersObjRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ProjectAndFolderOrganizersMaxFields = {
  __typename?: 'ProjectAndFolderOrganizersMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** foreign key to folder */
  childFolderId?: Maybe<Scalars['uuid']['output']>;
  /** foreign key to project */
  childProjectId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  organizableId?: Maybe<Scalars['uuid']['output']>;
  organizableType?: Maybe<Scalars['String']['output']>;
  parentFolderId?: Maybe<Scalars['uuid']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** foreign key to folder */
  childFolderId?: InputMaybe<OrderBy>;
  /** foreign key to project */
  childProjectId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  organizableId?: InputMaybe<OrderBy>;
  organizableType?: InputMaybe<OrderBy>;
  parentFolderId?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ProjectAndFolderOrganizersMinFields = {
  __typename?: 'ProjectAndFolderOrganizersMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** foreign key to folder */
  childFolderId?: Maybe<Scalars['uuid']['output']>;
  /** foreign key to project */
  childProjectId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  organizableId?: Maybe<Scalars['uuid']['output']>;
  organizableType?: Maybe<Scalars['String']['output']>;
  parentFolderId?: Maybe<Scalars['uuid']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  /** foreign key to folder */
  childFolderId?: InputMaybe<OrderBy>;
  /** foreign key to project */
  childProjectId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  organizableId?: InputMaybe<OrderBy>;
  organizableType?: InputMaybe<OrderBy>;
  parentFolderId?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersMutationResponse = {
  __typename?: 'ProjectAndFolderOrganizersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ProjectAndFolderOrganizers>;
};

/** on_conflict condition type for table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersOnConflict = {
  constraint: ProjectAndFolderOrganizersConstraint;
  updateColumns?: Array<ProjectAndFolderOrganizersUpdateColumn>;
  where?: InputMaybe<ProjectAndFolderOrganizersBoolExp>;
};

/** Ordering options when selecting data from "project_and_folder_organizers". */
export type ProjectAndFolderOrganizersOrderBy = {
  account?: InputMaybe<AccountsOrderBy>;
  accountId?: InputMaybe<OrderBy>;
  childFolderId?: InputMaybe<OrderBy>;
  childProject?: InputMaybe<ProjectsOrderBy>;
  childProjectFolder?: InputMaybe<ProjectFoldersOrderBy>;
  childProjectId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  organizableId?: InputMaybe<OrderBy>;
  organizableType?: InputMaybe<OrderBy>;
  parentFolderId?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  projectFolder?: InputMaybe<ProjectFoldersOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: project_and_folder_organizers */
export type ProjectAndFolderOrganizersPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "project_and_folder_organizers" */
export enum ProjectAndFolderOrganizersSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  ChildFolderId = 'childFolderId',
  /** column name */
  ChildProjectId = 'childProjectId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  OrganizableId = 'organizableId',
  /** column name */
  OrganizableType = 'organizableType',
  /** column name */
  ParentFolderId = 'parentFolderId',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** foreign key to folder */
  childFolderId?: InputMaybe<Scalars['uuid']['input']>;
  /** foreign key to project */
  childProjectId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  organizableId?: InputMaybe<Scalars['uuid']['input']>;
  organizableType?: InputMaybe<Scalars['String']['input']>;
  parentFolderId?: InputMaybe<Scalars['uuid']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type ProjectAndFolderOrganizersStddevFields = {
  __typename?: 'ProjectAndFolderOrganizersStddevFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersStddevOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type ProjectAndFolderOrganizersStddevPopFields = {
  __typename?: 'ProjectAndFolderOrganizersStddevPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersStddevPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type ProjectAndFolderOrganizersStddevSampFields = {
  __typename?: 'ProjectAndFolderOrganizersStddevSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersStddevSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ProjectAndFolderOrganizersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ProjectAndFolderOrganizersStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** foreign key to folder */
  childFolderId?: InputMaybe<Scalars['uuid']['input']>;
  /** foreign key to project */
  childProjectId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  organizableId?: InputMaybe<Scalars['uuid']['input']>;
  organizableType?: InputMaybe<Scalars['String']['input']>;
  parentFolderId?: InputMaybe<Scalars['uuid']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type ProjectAndFolderOrganizersSumFields = {
  __typename?: 'ProjectAndFolderOrganizersSumFields';
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersSumOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
};

/** update columns of table "project_and_folder_organizers" */
export enum ProjectAndFolderOrganizersUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  ChildFolderId = 'childFolderId',
  /** column name */
  ChildProjectId = 'childProjectId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  OrganizableId = 'organizableId',
  /** column name */
  OrganizableType = 'organizableType',
  /** column name */
  ParentFolderId = 'parentFolderId',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type ProjectAndFolderOrganizersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ProjectAndFolderOrganizersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ProjectAndFolderOrganizersSetInput>;
  /** filter the rows which have to be updated */
  where: ProjectAndFolderOrganizersBoolExp;
};

/** aggregate varPop on columns */
export type ProjectAndFolderOrganizersVarPopFields = {
  __typename?: 'ProjectAndFolderOrganizersVarPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersVarPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type ProjectAndFolderOrganizersVarSampFields = {
  __typename?: 'ProjectAndFolderOrganizersVarSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersVarSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ProjectAndFolderOrganizersVarianceFields = {
  __typename?: 'ProjectAndFolderOrganizersVarianceFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "project_and_folder_organizers" */
export type ProjectAndFolderOrganizersVarianceOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
};

/** [sidebar][feature needs redesign and re-architecting] - users can create folders in the projects section of the left sidebar of the dashboard. For some reason, currently each user has their own folder structure, so other people do not see the folder structure you have created, allowing you to create your own grouping. This probably needs a rethink. A folder can contain projects or other folders. */
export type ProjectFolders = {
  __typename?: 'ProjectFolders';
  /** An object relationship */
  account: Accounts;
  accountId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamp']['output'];
  id: Scalars['uuid']['output'];
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  name: Scalars['String']['output'];
  /** An array relationship */
  projectAndFolderOrganizers: Array<ProjectAndFolderOrganizers>;
  /** An aggregate relationship */
  projectAndFolderOrganizersAggregate: ProjectAndFolderOrganizersAggregate;
  updatedAt: Scalars['timestamp']['output'];
  userId: Scalars['uuid']['output'];
};


/** [sidebar][feature needs redesign and re-architecting] - users can create folders in the projects section of the left sidebar of the dashboard. For some reason, currently each user has their own folder structure, so other people do not see the folder structure you have created, allowing you to create your own grouping. This probably needs a rethink. A folder can contain projects or other folders. */
export type ProjectFoldersProjectAndFolderOrganizersArgs = {
  distinctOn?: InputMaybe<Array<ProjectAndFolderOrganizersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectAndFolderOrganizersOrderBy>>;
  where?: InputMaybe<ProjectAndFolderOrganizersBoolExp>;
};


/** [sidebar][feature needs redesign and re-architecting] - users can create folders in the projects section of the left sidebar of the dashboard. For some reason, currently each user has their own folder structure, so other people do not see the folder structure you have created, allowing you to create your own grouping. This probably needs a rethink. A folder can contain projects or other folders. */
export type ProjectFoldersProjectAndFolderOrganizersAggregateArgs = {
  distinctOn?: InputMaybe<Array<ProjectAndFolderOrganizersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectAndFolderOrganizersOrderBy>>;
  where?: InputMaybe<ProjectAndFolderOrganizersBoolExp>;
};

/** aggregated selection of "project_folders" */
export type ProjectFoldersAggregate = {
  __typename?: 'ProjectFoldersAggregate';
  aggregate?: Maybe<ProjectFoldersAggregateFields>;
  nodes: Array<ProjectFolders>;
};

/** aggregate fields of "project_folders" */
export type ProjectFoldersAggregateFields = {
  __typename?: 'ProjectFoldersAggregateFields';
  avg?: Maybe<ProjectFoldersAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ProjectFoldersMaxFields>;
  min?: Maybe<ProjectFoldersMinFields>;
  stddev?: Maybe<ProjectFoldersStddevFields>;
  stddevPop?: Maybe<ProjectFoldersStddevPopFields>;
  stddevSamp?: Maybe<ProjectFoldersStddevSampFields>;
  sum?: Maybe<ProjectFoldersSumFields>;
  varPop?: Maybe<ProjectFoldersVarPopFields>;
  varSamp?: Maybe<ProjectFoldersVarSampFields>;
  variance?: Maybe<ProjectFoldersVarianceFields>;
};


/** aggregate fields of "project_folders" */
export type ProjectFoldersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ProjectFoldersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ProjectFoldersAvgFields = {
  __typename?: 'ProjectFoldersAvgFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "project_folders". All fields are combined with a logical 'AND'. */
export type ProjectFoldersBoolExp = {
  _and?: InputMaybe<Array<ProjectFoldersBoolExp>>;
  _not?: InputMaybe<ProjectFoldersBoolExp>;
  _or?: InputMaybe<Array<ProjectFoldersBoolExp>>;
  account?: InputMaybe<AccountsBoolExp>;
  accountId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  projectAndFolderOrganizers?: InputMaybe<ProjectAndFolderOrganizersBoolExp>;
  projectAndFolderOrganizersAggregate?: InputMaybe<ProjectAndFolderOrganizersAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "project_folders" */
export enum ProjectFoldersConstraint {
  /** unique or primary key constraint on columns "id" */
  ProjectFoldersPkey = 'project_folders_pkey'
}

/** input type for incrementing numeric columns in table "project_folders" */
export type ProjectFoldersIncInput = {
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "project_folders" */
export type ProjectFoldersInsertInput = {
  account?: InputMaybe<AccountsObjRelInsertInput>;
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  projectAndFolderOrganizers?: InputMaybe<ProjectAndFolderOrganizersArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ProjectFoldersMaxFields = {
  __typename?: 'ProjectFoldersMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type ProjectFoldersMinFields = {
  __typename?: 'ProjectFoldersMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "project_folders" */
export type ProjectFoldersMutationResponse = {
  __typename?: 'ProjectFoldersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ProjectFolders>;
};

/** input type for inserting object relation for remote table "project_folders" */
export type ProjectFoldersObjRelInsertInput = {
  data: ProjectFoldersInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<ProjectFoldersOnConflict>;
};

/** on_conflict condition type for table "project_folders" */
export type ProjectFoldersOnConflict = {
  constraint: ProjectFoldersConstraint;
  updateColumns?: Array<ProjectFoldersUpdateColumn>;
  where?: InputMaybe<ProjectFoldersBoolExp>;
};

/** Ordering options when selecting data from "project_folders". */
export type ProjectFoldersOrderBy = {
  account?: InputMaybe<AccountsOrderBy>;
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  projectAndFolderOrganizersAggregate?: InputMaybe<ProjectAndFolderOrganizersAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: project_folders */
export type ProjectFoldersPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "project_folders" */
export enum ProjectFoldersSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "project_folders" */
export type ProjectFoldersSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type ProjectFoldersStddevFields = {
  __typename?: 'ProjectFoldersStddevFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type ProjectFoldersStddevPopFields = {
  __typename?: 'ProjectFoldersStddevPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type ProjectFoldersStddevSampFields = {
  __typename?: 'ProjectFoldersStddevSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "project_folders" */
export type ProjectFoldersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ProjectFoldersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ProjectFoldersStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type ProjectFoldersSumFields = {
  __typename?: 'ProjectFoldersSumFields';
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "project_folders" */
export enum ProjectFoldersUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type ProjectFoldersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ProjectFoldersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ProjectFoldersSetInput>;
  /** filter the rows which have to be updated */
  where: ProjectFoldersBoolExp;
};

/** aggregate varPop on columns */
export type ProjectFoldersVarPopFields = {
  __typename?: 'ProjectFoldersVarPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type ProjectFoldersVarSampFields = {
  __typename?: 'ProjectFoldersVarSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ProjectFoldersVarianceFields = {
  __typename?: 'ProjectFoldersVarianceFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** Join table that describes the relationship between a given user and a given project */
export type ProjectUsers = {
  __typename?: 'ProjectUsers';
  /** An object relationship */
  account: Accounts;
  accountId: Scalars['uuid']['output'];
  /** user setting that allows users to receive all notifications within a specific project */
  allNotificationsEnabled: Scalars['Boolean']['output'];
  createdAt: Scalars['timestamp']['output'];
  /** [permissions] - guest status, which may have different permissions */
  guest: Scalars['Boolean']['output'];
  id: Scalars['uuid']['output'];
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** remove */
  lastViewedApp?: Maybe<Scalars['String']['output']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount: Scalars['Int']['output'];
  /** An object relationship */
  project: Projects;
  projectId: Scalars['uuid']['output'];
  /** remove */
  specificWorkspacesOnly: Scalars['Boolean']['output'];
  /** remove */
  swimlaneOpen: Scalars['Boolean']['output'];
  updatedAt: Scalars['timestamp']['output'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid']['output'];
};

/** aggregated selection of "project_users" */
export type ProjectUsersAggregate = {
  __typename?: 'ProjectUsersAggregate';
  aggregate?: Maybe<ProjectUsersAggregateFields>;
  nodes: Array<ProjectUsers>;
};

export type ProjectUsersAggregateBoolExp = {
  bool_and?: InputMaybe<ProjectUsersAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<ProjectUsersAggregateBoolExpBool_Or>;
  count?: InputMaybe<ProjectUsersAggregateBoolExpCount>;
};

/** aggregate fields of "project_users" */
export type ProjectUsersAggregateFields = {
  __typename?: 'ProjectUsersAggregateFields';
  avg?: Maybe<ProjectUsersAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ProjectUsersMaxFields>;
  min?: Maybe<ProjectUsersMinFields>;
  stddev?: Maybe<ProjectUsersStddevFields>;
  stddevPop?: Maybe<ProjectUsersStddevPopFields>;
  stddevSamp?: Maybe<ProjectUsersStddevSampFields>;
  sum?: Maybe<ProjectUsersSumFields>;
  varPop?: Maybe<ProjectUsersVarPopFields>;
  varSamp?: Maybe<ProjectUsersVarSampFields>;
  variance?: Maybe<ProjectUsersVarianceFields>;
};


/** aggregate fields of "project_users" */
export type ProjectUsersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ProjectUsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "project_users" */
export type ProjectUsersAggregateOrderBy = {
  avg?: InputMaybe<ProjectUsersAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ProjectUsersMaxOrderBy>;
  min?: InputMaybe<ProjectUsersMinOrderBy>;
  stddev?: InputMaybe<ProjectUsersStddevOrderBy>;
  stddevPop?: InputMaybe<ProjectUsersStddevPopOrderBy>;
  stddevSamp?: InputMaybe<ProjectUsersStddevSampOrderBy>;
  sum?: InputMaybe<ProjectUsersSumOrderBy>;
  varPop?: InputMaybe<ProjectUsersVarPopOrderBy>;
  varSamp?: InputMaybe<ProjectUsersVarSampOrderBy>;
  variance?: InputMaybe<ProjectUsersVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "project_users" */
export type ProjectUsersArrRelInsertInput = {
  data: Array<ProjectUsersInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<ProjectUsersOnConflict>;
};

/** aggregate avg on columns */
export type ProjectUsersAvgFields = {
  __typename?: 'ProjectUsersAvgFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "project_users" */
export type ProjectUsersAvgOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "project_users". All fields are combined with a logical 'AND'. */
export type ProjectUsersBoolExp = {
  _and?: InputMaybe<Array<ProjectUsersBoolExp>>;
  _not?: InputMaybe<ProjectUsersBoolExp>;
  _or?: InputMaybe<Array<ProjectUsersBoolExp>>;
  account?: InputMaybe<AccountsBoolExp>;
  accountId?: InputMaybe<UuidComparisonExp>;
  allNotificationsEnabled?: InputMaybe<BooleanComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  guest?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  lastViewedApp?: InputMaybe<StringComparisonExp>;
  notificationCount?: InputMaybe<IntComparisonExp>;
  project?: InputMaybe<ProjectsBoolExp>;
  projectId?: InputMaybe<UuidComparisonExp>;
  specificWorkspacesOnly?: InputMaybe<BooleanComparisonExp>;
  swimlaneOpen?: InputMaybe<BooleanComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "project_users" */
export enum ProjectUsersConstraint {
  /** unique or primary key constraint on columns "user_id", "project_id" */
  IndexProjectUsersOnProjectIdAndUserId = 'index_project_users_on_project_id_and_user_id',
  /** unique or primary key constraint on columns "id" */
  ProjectUsersPkey = 'project_users_pkey'
}

/** input type for incrementing numeric columns in table "project_users" */
export type ProjectUsersIncInput = {
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "project_users" */
export type ProjectUsersInsertInput = {
  account?: InputMaybe<AccountsObjRelInsertInput>;
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** user setting that allows users to receive all notifications within a specific project */
  allNotificationsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [permissions] - guest status, which may have different permissions */
  guest?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** remove */
  lastViewedApp?: InputMaybe<Scalars['String']['input']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<Scalars['Int']['input']>;
  project?: InputMaybe<ProjectsObjRelInsertInput>;
  projectId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove */
  specificWorkspacesOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove */
  swimlaneOpen?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ProjectUsersMaxFields = {
  __typename?: 'ProjectUsersMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** remove */
  lastViewedApp?: Maybe<Scalars['String']['output']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: Maybe<Scalars['Int']['output']>;
  projectId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "project_users" */
export type ProjectUsersMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** remove */
  lastViewedApp?: InputMaybe<OrderBy>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<OrderBy>;
  projectId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ProjectUsersMinFields = {
  __typename?: 'ProjectUsersMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** remove */
  lastViewedApp?: Maybe<Scalars['String']['output']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: Maybe<Scalars['Int']['output']>;
  projectId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "project_users" */
export type ProjectUsersMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** remove */
  lastViewedApp?: InputMaybe<OrderBy>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<OrderBy>;
  projectId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "project_users" */
export type ProjectUsersMutationResponse = {
  __typename?: 'ProjectUsersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ProjectUsers>;
};

/** on_conflict condition type for table "project_users" */
export type ProjectUsersOnConflict = {
  constraint: ProjectUsersConstraint;
  updateColumns?: Array<ProjectUsersUpdateColumn>;
  where?: InputMaybe<ProjectUsersBoolExp>;
};

/** Ordering options when selecting data from "project_users". */
export type ProjectUsersOrderBy = {
  account?: InputMaybe<AccountsOrderBy>;
  accountId?: InputMaybe<OrderBy>;
  allNotificationsEnabled?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  guest?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  lastViewedApp?: InputMaybe<OrderBy>;
  notificationCount?: InputMaybe<OrderBy>;
  project?: InputMaybe<ProjectsOrderBy>;
  projectId?: InputMaybe<OrderBy>;
  specificWorkspacesOnly?: InputMaybe<OrderBy>;
  swimlaneOpen?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: project_users */
export type ProjectUsersPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "project_users" */
export enum ProjectUsersSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  AllNotificationsEnabled = 'allNotificationsEnabled',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Guest = 'guest',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LastViewedApp = 'lastViewedApp',
  /** column name */
  NotificationCount = 'notificationCount',
  /** column name */
  ProjectId = 'projectId',
  /** column name */
  SpecificWorkspacesOnly = 'specificWorkspacesOnly',
  /** column name */
  SwimlaneOpen = 'swimlaneOpen',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** select "projectUsersAggregateBoolExpBool_andArgumentsColumns" columns of table "project_users" */
export enum ProjectUsersSelectColumnProjectUsersAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  AllNotificationsEnabled = 'allNotificationsEnabled',
  /** column name */
  Guest = 'guest',
  /** column name */
  SpecificWorkspacesOnly = 'specificWorkspacesOnly',
  /** column name */
  SwimlaneOpen = 'swimlaneOpen'
}

/** select "projectUsersAggregateBoolExpBool_orArgumentsColumns" columns of table "project_users" */
export enum ProjectUsersSelectColumnProjectUsersAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  AllNotificationsEnabled = 'allNotificationsEnabled',
  /** column name */
  Guest = 'guest',
  /** column name */
  SpecificWorkspacesOnly = 'specificWorkspacesOnly',
  /** column name */
  SwimlaneOpen = 'swimlaneOpen'
}

/** input type for updating data in table "project_users" */
export type ProjectUsersSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** user setting that allows users to receive all notifications within a specific project */
  allNotificationsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [permissions] - guest status, which may have different permissions */
  guest?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** remove */
  lastViewedApp?: InputMaybe<Scalars['String']['input']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove */
  specificWorkspacesOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove */
  swimlaneOpen?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type ProjectUsersStddevFields = {
  __typename?: 'ProjectUsersStddevFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "project_users" */
export type ProjectUsersStddevOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type ProjectUsersStddevPopFields = {
  __typename?: 'ProjectUsersStddevPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "project_users" */
export type ProjectUsersStddevPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type ProjectUsersStddevSampFields = {
  __typename?: 'ProjectUsersStddevSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "project_users" */
export type ProjectUsersStddevSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "project_users" */
export type ProjectUsersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ProjectUsersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ProjectUsersStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** user setting that allows users to receive all notifications within a specific project */
  allNotificationsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [permissions] - guest status, which may have different permissions */
  guest?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** remove */
  lastViewedApp?: InputMaybe<Scalars['String']['input']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<Scalars['Int']['input']>;
  projectId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove */
  specificWorkspacesOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove */
  swimlaneOpen?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type ProjectUsersSumFields = {
  __typename?: 'ProjectUsersSumFields';
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "project_users" */
export type ProjectUsersSumOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<OrderBy>;
};

/** update columns of table "project_users" */
export enum ProjectUsersUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  AllNotificationsEnabled = 'allNotificationsEnabled',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Guest = 'guest',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LastViewedApp = 'lastViewedApp',
  /** column name */
  NotificationCount = 'notificationCount',
  /** column name */
  ProjectId = 'projectId',
  /** column name */
  SpecificWorkspacesOnly = 'specificWorkspacesOnly',
  /** column name */
  SwimlaneOpen = 'swimlaneOpen',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type ProjectUsersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ProjectUsersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ProjectUsersSetInput>;
  /** filter the rows which have to be updated */
  where: ProjectUsersBoolExp;
};

/** aggregate varPop on columns */
export type ProjectUsersVarPopFields = {
  __typename?: 'ProjectUsersVarPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "project_users" */
export type ProjectUsersVarPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type ProjectUsersVarSampFields = {
  __typename?: 'ProjectUsersVarSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "project_users" */
export type ProjectUsersVarSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ProjectUsersVarianceFields = {
  __typename?: 'ProjectUsersVarianceFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "project_users" */
export type ProjectUsersVarianceOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** check and possibly remove - cache of notifications in that project */
  notificationCount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "projects" */
export type Projects = {
  __typename?: 'Projects';
  /** An object relationship */
  account: Accounts;
  accountId: Scalars['uuid']['output'];
  /** [info page] the briefing for the project in tiptap DSL */
  briefingJson?: Maybe<Scalars['jsonb']['output']>;
  createdAt: Scalars['timestamp']['output'];
  /** An array relationship */
  documents: Array<Documents>;
  /** An aggregate relationship */
  documentsAggregate: DocumentsAggregate;
  /** [info page] Allows users to add an end date for the project */
  endDate?: Maybe<Scalars['date']['output']>;
  /** remove */
  globalAccess: Scalars['Boolean']['output'];
  /** remove */
  globalAccessToken?: Maybe<Scalars['String']['output']>;
  /** remove */
  globalAccessTokenExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  id: Scalars['uuid']['output'];
  /** Marking a project as private means that it does not show for users outside of the project in the projects list, and users cannot join without being invited */
  isPrivate: Scalars['Boolean']['output'];
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** The image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrl?: Maybe<Scalars['String']['output']>;
  /** Expiry date for image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** stores any error message that occurred during processing the user-uploaded logo for the project into an optimised image */
  photoProcessingError?: Maybe<Scalars['String']['output']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus: Scalars['Int']['output'];
  /** project status such as in progress, complete */
  projectStatus: Scalars['Int']['output'];
  /** An array relationship */
  projectUsers: Array<ProjectUsers>;
  /** An aggregate relationship */
  projectUsersAggregate: ProjectUsersAggregate;
  /** [info page] Allows users to add a start date for the project */
  startDate?: Maybe<Scalars['date']['output']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status: Scalars['Int']['output'];
  /** [timeline] - is this project hidden from the timeline */
  timelineHidden: Scalars['Boolean']['output'];
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition: Scalars['Int']['output'];
  updatedAt: Scalars['timestamp']['output'];
};


/** columns and relationships of "projects" */
export type ProjectsBriefingJsonArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "projects" */
export type ProjectsDocumentsArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


/** columns and relationships of "projects" */
export type ProjectsDocumentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


/** columns and relationships of "projects" */
export type ProjectsProjectUsersArgs = {
  distinctOn?: InputMaybe<Array<ProjectUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
  where?: InputMaybe<ProjectUsersBoolExp>;
};


/** columns and relationships of "projects" */
export type ProjectsProjectUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<ProjectUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
  where?: InputMaybe<ProjectUsersBoolExp>;
};

/** aggregated selection of "projects" */
export type ProjectsAggregate = {
  __typename?: 'ProjectsAggregate';
  aggregate?: Maybe<ProjectsAggregateFields>;
  nodes: Array<Projects>;
};

export type ProjectsAggregateBoolExp = {
  bool_and?: InputMaybe<ProjectsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<ProjectsAggregateBoolExpBool_Or>;
  count?: InputMaybe<ProjectsAggregateBoolExpCount>;
};

/** aggregate fields of "projects" */
export type ProjectsAggregateFields = {
  __typename?: 'ProjectsAggregateFields';
  avg?: Maybe<ProjectsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ProjectsMaxFields>;
  min?: Maybe<ProjectsMinFields>;
  stddev?: Maybe<ProjectsStddevFields>;
  stddevPop?: Maybe<ProjectsStddevPopFields>;
  stddevSamp?: Maybe<ProjectsStddevSampFields>;
  sum?: Maybe<ProjectsSumFields>;
  varPop?: Maybe<ProjectsVarPopFields>;
  varSamp?: Maybe<ProjectsVarSampFields>;
  variance?: Maybe<ProjectsVarianceFields>;
};


/** aggregate fields of "projects" */
export type ProjectsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ProjectsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "projects" */
export type ProjectsAggregateOrderBy = {
  avg?: InputMaybe<ProjectsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ProjectsMaxOrderBy>;
  min?: InputMaybe<ProjectsMinOrderBy>;
  stddev?: InputMaybe<ProjectsStddevOrderBy>;
  stddevPop?: InputMaybe<ProjectsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<ProjectsStddevSampOrderBy>;
  sum?: InputMaybe<ProjectsSumOrderBy>;
  varPop?: InputMaybe<ProjectsVarPopOrderBy>;
  varSamp?: InputMaybe<ProjectsVarSampOrderBy>;
  variance?: InputMaybe<ProjectsVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type ProjectsAppendInput = {
  /** [info page] the briefing for the project in tiptap DSL */
  briefingJson?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "projects" */
export type ProjectsArrRelInsertInput = {
  data: Array<ProjectsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<ProjectsOnConflict>;
};

/** aggregate avg on columns */
export type ProjectsAvgFields = {
  __typename?: 'ProjectsAvgFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** project status such as in progress, complete */
  projectStatus?: Maybe<Scalars['Float']['output']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "projects" */
export type ProjectsAvgOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<OrderBy>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<OrderBy>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<OrderBy>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "projects". All fields are combined with a logical 'AND'. */
export type ProjectsBoolExp = {
  _and?: InputMaybe<Array<ProjectsBoolExp>>;
  _not?: InputMaybe<ProjectsBoolExp>;
  _or?: InputMaybe<Array<ProjectsBoolExp>>;
  account?: InputMaybe<AccountsBoolExp>;
  accountId?: InputMaybe<UuidComparisonExp>;
  briefingJson?: InputMaybe<JsonbComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  documents?: InputMaybe<DocumentsBoolExp>;
  documentsAggregate?: InputMaybe<DocumentsAggregateBoolExp>;
  endDate?: InputMaybe<DateComparisonExp>;
  globalAccess?: InputMaybe<BooleanComparisonExp>;
  globalAccessToken?: InputMaybe<StringComparisonExp>;
  globalAccessTokenExpiresAt?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isPrivate?: InputMaybe<BooleanComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  logoUrl?: InputMaybe<StringComparisonExp>;
  logoUrlExpiresAt?: InputMaybe<TimestamptzComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  photoProcessingError?: InputMaybe<StringComparisonExp>;
  photoProcessingStatus?: InputMaybe<IntComparisonExp>;
  projectStatus?: InputMaybe<IntComparisonExp>;
  projectUsers?: InputMaybe<ProjectUsersBoolExp>;
  projectUsersAggregate?: InputMaybe<ProjectUsersAggregateBoolExp>;
  startDate?: InputMaybe<DateComparisonExp>;
  status?: InputMaybe<IntComparisonExp>;
  timelineHidden?: InputMaybe<BooleanComparisonExp>;
  timelinePosition?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
};

/** unique or primary key constraints on table "projects" */
export enum ProjectsConstraint {
  /** unique or primary key constraint on columns "id" */
  ProjectsPkey = 'projects_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type ProjectsDeleteAtPathInput = {
  /** [info page] the briefing for the project in tiptap DSL */
  briefingJson?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type ProjectsDeleteElemInput = {
  /** [info page] the briefing for the project in tiptap DSL */
  briefingJson?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type ProjectsDeleteKeyInput = {
  /** [info page] the briefing for the project in tiptap DSL */
  briefingJson?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "projects" */
export type ProjectsIncInput = {
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<Scalars['Int']['input']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "projects" */
export type ProjectsInsertInput = {
  account?: InputMaybe<AccountsObjRelInsertInput>;
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [info page] the briefing for the project in tiptap DSL */
  briefingJson?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  documents?: InputMaybe<DocumentsArrRelInsertInput>;
  /** [info page] Allows users to add an end date for the project */
  endDate?: InputMaybe<Scalars['date']['input']>;
  /** remove */
  globalAccess?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove */
  globalAccessToken?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  globalAccessTokenExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Marking a project as private means that it does not show for users outside of the project in the projects list, and users cannot join without being invited */
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Expiry date for image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** stores any error message that occurred during processing the user-uploaded logo for the project into an optimised image */
  photoProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<Scalars['Int']['input']>;
  projectUsers?: InputMaybe<ProjectUsersArrRelInsertInput>;
  /** [info page] Allows users to add a start date for the project */
  startDate?: InputMaybe<Scalars['date']['input']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** [timeline] - is this project hidden from the timeline */
  timelineHidden?: InputMaybe<Scalars['Boolean']['input']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate max on columns */
export type ProjectsMaxFields = {
  __typename?: 'ProjectsMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** [info page] Allows users to add an end date for the project */
  endDate?: Maybe<Scalars['date']['output']>;
  /** remove */
  globalAccessToken?: Maybe<Scalars['String']['output']>;
  /** remove */
  globalAccessTokenExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** The image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrl?: Maybe<Scalars['String']['output']>;
  /** Expiry date for image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** stores any error message that occurred during processing the user-uploaded logo for the project into an optimised image */
  photoProcessingError?: Maybe<Scalars['String']['output']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** project status such as in progress, complete */
  projectStatus?: Maybe<Scalars['Int']['output']>;
  /** [info page] Allows users to add a start date for the project */
  startDate?: Maybe<Scalars['date']['output']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: Maybe<Scalars['Int']['output']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by max() on columns of table "projects" */
export type ProjectsMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** [info page] Allows users to add an end date for the project */
  endDate?: InputMaybe<OrderBy>;
  /** remove */
  globalAccessToken?: InputMaybe<OrderBy>;
  /** remove */
  globalAccessTokenExpiresAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrl?: InputMaybe<OrderBy>;
  /** Expiry date for image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrlExpiresAt?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  /** stores any error message that occurred during processing the user-uploaded logo for the project into an optimised image */
  photoProcessingError?: InputMaybe<OrderBy>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<OrderBy>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<OrderBy>;
  /** [info page] Allows users to add a start date for the project */
  startDate?: InputMaybe<OrderBy>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<OrderBy>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ProjectsMinFields = {
  __typename?: 'ProjectsMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** [info page] Allows users to add an end date for the project */
  endDate?: Maybe<Scalars['date']['output']>;
  /** remove */
  globalAccessToken?: Maybe<Scalars['String']['output']>;
  /** remove */
  globalAccessTokenExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** The image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrl?: Maybe<Scalars['String']['output']>;
  /** Expiry date for image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** stores any error message that occurred during processing the user-uploaded logo for the project into an optimised image */
  photoProcessingError?: Maybe<Scalars['String']['output']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** project status such as in progress, complete */
  projectStatus?: Maybe<Scalars['Int']['output']>;
  /** [info page] Allows users to add a start date for the project */
  startDate?: Maybe<Scalars['date']['output']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: Maybe<Scalars['Int']['output']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by min() on columns of table "projects" */
export type ProjectsMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** [info page] Allows users to add an end date for the project */
  endDate?: InputMaybe<OrderBy>;
  /** remove */
  globalAccessToken?: InputMaybe<OrderBy>;
  /** remove */
  globalAccessTokenExpiresAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** The image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrl?: InputMaybe<OrderBy>;
  /** Expiry date for image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrlExpiresAt?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  /** stores any error message that occurred during processing the user-uploaded logo for the project into an optimised image */
  photoProcessingError?: InputMaybe<OrderBy>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<OrderBy>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<OrderBy>;
  /** [info page] Allows users to add a start date for the project */
  startDate?: InputMaybe<OrderBy>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<OrderBy>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "projects" */
export type ProjectsMutationResponse = {
  __typename?: 'ProjectsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Projects>;
};

/** input type for inserting object relation for remote table "projects" */
export type ProjectsObjRelInsertInput = {
  data: ProjectsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<ProjectsOnConflict>;
};

/** on_conflict condition type for table "projects" */
export type ProjectsOnConflict = {
  constraint: ProjectsConstraint;
  updateColumns?: Array<ProjectsUpdateColumn>;
  where?: InputMaybe<ProjectsBoolExp>;
};

/** Ordering options when selecting data from "projects". */
export type ProjectsOrderBy = {
  account?: InputMaybe<AccountsOrderBy>;
  accountId?: InputMaybe<OrderBy>;
  briefingJson?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  documentsAggregate?: InputMaybe<DocumentsAggregateOrderBy>;
  endDate?: InputMaybe<OrderBy>;
  globalAccess?: InputMaybe<OrderBy>;
  globalAccessToken?: InputMaybe<OrderBy>;
  globalAccessTokenExpiresAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isPrivate?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  logoUrl?: InputMaybe<OrderBy>;
  logoUrlExpiresAt?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  photoProcessingError?: InputMaybe<OrderBy>;
  photoProcessingStatus?: InputMaybe<OrderBy>;
  projectStatus?: InputMaybe<OrderBy>;
  projectUsersAggregate?: InputMaybe<ProjectUsersAggregateOrderBy>;
  startDate?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  timelineHidden?: InputMaybe<OrderBy>;
  timelinePosition?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: projects */
export type ProjectsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type ProjectsPrependInput = {
  /** [info page] the briefing for the project in tiptap DSL */
  briefingJson?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "projects" */
export enum ProjectsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  BriefingJson = 'briefingJson',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EndDate = 'endDate',
  /** column name */
  GlobalAccess = 'globalAccess',
  /** column name */
  GlobalAccessToken = 'globalAccessToken',
  /** column name */
  GlobalAccessTokenExpiresAt = 'globalAccessTokenExpiresAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsPrivate = 'isPrivate',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LogoUrl = 'logoUrl',
  /** column name */
  LogoUrlExpiresAt = 'logoUrlExpiresAt',
  /** column name */
  Name = 'name',
  /** column name */
  PhotoProcessingError = 'photoProcessingError',
  /** column name */
  PhotoProcessingStatus = 'photoProcessingStatus',
  /** column name */
  ProjectStatus = 'projectStatus',
  /** column name */
  StartDate = 'startDate',
  /** column name */
  Status = 'status',
  /** column name */
  TimelineHidden = 'timelineHidden',
  /** column name */
  TimelinePosition = 'timelinePosition',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "projectsAggregateBoolExpBool_andArgumentsColumns" columns of table "projects" */
export enum ProjectsSelectColumnProjectsAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  GlobalAccess = 'globalAccess',
  /** column name */
  IsPrivate = 'isPrivate',
  /** column name */
  TimelineHidden = 'timelineHidden'
}

/** select "projectsAggregateBoolExpBool_orArgumentsColumns" columns of table "projects" */
export enum ProjectsSelectColumnProjectsAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  GlobalAccess = 'globalAccess',
  /** column name */
  IsPrivate = 'isPrivate',
  /** column name */
  TimelineHidden = 'timelineHidden'
}

/** input type for updating data in table "projects" */
export type ProjectsSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [info page] the briefing for the project in tiptap DSL */
  briefingJson?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [info page] Allows users to add an end date for the project */
  endDate?: InputMaybe<Scalars['date']['input']>;
  /** remove */
  globalAccess?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove */
  globalAccessToken?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  globalAccessTokenExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Marking a project as private means that it does not show for users outside of the project in the projects list, and users cannot join without being invited */
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Expiry date for image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** stores any error message that occurred during processing the user-uploaded logo for the project into an optimised image */
  photoProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [info page] Allows users to add a start date for the project */
  startDate?: InputMaybe<Scalars['date']['input']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** [timeline] - is this project hidden from the timeline */
  timelineHidden?: InputMaybe<Scalars['Boolean']['input']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate stddev on columns */
export type ProjectsStddevFields = {
  __typename?: 'ProjectsStddevFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** project status such as in progress, complete */
  projectStatus?: Maybe<Scalars['Float']['output']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "projects" */
export type ProjectsStddevOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<OrderBy>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<OrderBy>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<OrderBy>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type ProjectsStddevPopFields = {
  __typename?: 'ProjectsStddevPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** project status such as in progress, complete */
  projectStatus?: Maybe<Scalars['Float']['output']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "projects" */
export type ProjectsStddevPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<OrderBy>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<OrderBy>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<OrderBy>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type ProjectsStddevSampFields = {
  __typename?: 'ProjectsStddevSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** project status such as in progress, complete */
  projectStatus?: Maybe<Scalars['Float']['output']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "projects" */
export type ProjectsStddevSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<OrderBy>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<OrderBy>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<OrderBy>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "projects" */
export type ProjectsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ProjectsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ProjectsStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [info page] the briefing for the project in tiptap DSL */
  briefingJson?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [info page] Allows users to add an end date for the project */
  endDate?: InputMaybe<Scalars['date']['input']>;
  /** remove */
  globalAccess?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove */
  globalAccessToken?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  globalAccessTokenExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Marking a project as private means that it does not show for users outside of the project in the projects list, and users cannot join without being invited */
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Expiry date for image/icon that highlights the project in the sidebar and in the list of projects */
  logoUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** stores any error message that occurred during processing the user-uploaded logo for the project into an optimised image */
  photoProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [info page] Allows users to add a start date for the project */
  startDate?: InputMaybe<Scalars['date']['input']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** [timeline] - is this project hidden from the timeline */
  timelineHidden?: InputMaybe<Scalars['Boolean']['input']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate sum on columns */
export type ProjectsSumFields = {
  __typename?: 'ProjectsSumFields';
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** project status such as in progress, complete */
  projectStatus?: Maybe<Scalars['Int']['output']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: Maybe<Scalars['Int']['output']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "projects" */
export type ProjectsSumOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<OrderBy>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<OrderBy>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<OrderBy>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<OrderBy>;
};

/** update columns of table "projects" */
export enum ProjectsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  BriefingJson = 'briefingJson',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EndDate = 'endDate',
  /** column name */
  GlobalAccess = 'globalAccess',
  /** column name */
  GlobalAccessToken = 'globalAccessToken',
  /** column name */
  GlobalAccessTokenExpiresAt = 'globalAccessTokenExpiresAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsPrivate = 'isPrivate',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LogoUrl = 'logoUrl',
  /** column name */
  LogoUrlExpiresAt = 'logoUrlExpiresAt',
  /** column name */
  Name = 'name',
  /** column name */
  PhotoProcessingError = 'photoProcessingError',
  /** column name */
  PhotoProcessingStatus = 'photoProcessingStatus',
  /** column name */
  ProjectStatus = 'projectStatus',
  /** column name */
  StartDate = 'startDate',
  /** column name */
  Status = 'status',
  /** column name */
  TimelineHidden = 'timelineHidden',
  /** column name */
  TimelinePosition = 'timelinePosition',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type ProjectsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<ProjectsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<ProjectsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<ProjectsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<ProjectsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ProjectsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<ProjectsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ProjectsSetInput>;
  /** filter the rows which have to be updated */
  where: ProjectsBoolExp;
};

/** aggregate varPop on columns */
export type ProjectsVarPopFields = {
  __typename?: 'ProjectsVarPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** project status such as in progress, complete */
  projectStatus?: Maybe<Scalars['Float']['output']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "projects" */
export type ProjectsVarPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<OrderBy>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<OrderBy>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<OrderBy>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type ProjectsVarSampFields = {
  __typename?: 'ProjectsVarSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** project status such as in progress, complete */
  projectStatus?: Maybe<Scalars['Float']['output']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "projects" */
export type ProjectsVarSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<OrderBy>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<OrderBy>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<OrderBy>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ProjectsVarianceFields = {
  __typename?: 'ProjectsVarianceFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** project status such as in progress, complete */
  projectStatus?: Maybe<Scalars['Float']['output']>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: Maybe<Scalars['Float']['output']>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "projects" */
export type ProjectsVarianceOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** tracks status of processing the user-uploaded logo for the project into an optimised image */
  photoProcessingStatus?: InputMaybe<OrderBy>;
  /** project status such as in progress, complete */
  projectStatus?: InputMaybe<OrderBy>;
  /** rename needed - creation status of either draft or created. Draft creation status is needed as the project modal is open, a draft project is created. This allows us to attach the logo to the project */
  status?: InputMaybe<OrderBy>;
  /** [timeline] - ordering of this project on the timeline */
  timelinePosition?: InputMaybe<OrderBy>;
};

/** emoji reactions to a given message */
export type Reactions = {
  __typename?: 'Reactions';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt: Scalars['timestamp']['output'];
  id: Scalars['uuid']['output'];
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  message: Messages;
  /** Message that reaction is on */
  messageId: Scalars['uuid']['output'];
  /** Emoji selected */
  text?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['timestamp']['output'];
  /** An object relationship */
  user: Users;
  /** User that is reacted to */
  userId: Scalars['uuid']['output'];
};

/** aggregated selection of "reactions" */
export type ReactionsAggregate = {
  __typename?: 'ReactionsAggregate';
  aggregate?: Maybe<ReactionsAggregateFields>;
  nodes: Array<Reactions>;
};

export type ReactionsAggregateBoolExp = {
  count?: InputMaybe<ReactionsAggregateBoolExpCount>;
};

/** aggregate fields of "reactions" */
export type ReactionsAggregateFields = {
  __typename?: 'ReactionsAggregateFields';
  avg?: Maybe<ReactionsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ReactionsMaxFields>;
  min?: Maybe<ReactionsMinFields>;
  stddev?: Maybe<ReactionsStddevFields>;
  stddevPop?: Maybe<ReactionsStddevPopFields>;
  stddevSamp?: Maybe<ReactionsStddevSampFields>;
  sum?: Maybe<ReactionsSumFields>;
  varPop?: Maybe<ReactionsVarPopFields>;
  varSamp?: Maybe<ReactionsVarSampFields>;
  variance?: Maybe<ReactionsVarianceFields>;
};


/** aggregate fields of "reactions" */
export type ReactionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ReactionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "reactions" */
export type ReactionsAggregateOrderBy = {
  avg?: InputMaybe<ReactionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ReactionsMaxOrderBy>;
  min?: InputMaybe<ReactionsMinOrderBy>;
  stddev?: InputMaybe<ReactionsStddevOrderBy>;
  stddevPop?: InputMaybe<ReactionsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<ReactionsStddevSampOrderBy>;
  sum?: InputMaybe<ReactionsSumOrderBy>;
  varPop?: InputMaybe<ReactionsVarPopOrderBy>;
  varSamp?: InputMaybe<ReactionsVarSampOrderBy>;
  variance?: InputMaybe<ReactionsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "reactions" */
export type ReactionsArrRelInsertInput = {
  data: Array<ReactionsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<ReactionsOnConflict>;
};

/** aggregate avg on columns */
export type ReactionsAvgFields = {
  __typename?: 'ReactionsAvgFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "reactions" */
export type ReactionsAvgOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "reactions". All fields are combined with a logical 'AND'. */
export type ReactionsBoolExp = {
  _and?: InputMaybe<Array<ReactionsBoolExp>>;
  _not?: InputMaybe<ReactionsBoolExp>;
  _or?: InputMaybe<Array<ReactionsBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  message?: InputMaybe<MessagesBoolExp>;
  messageId?: InputMaybe<UuidComparisonExp>;
  text?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "reactions" */
export enum ReactionsConstraint {
  /** unique or primary key constraint on columns "id" */
  ReactionsPkey = 'reactions_pkey'
}

/** input type for incrementing numeric columns in table "reactions" */
export type ReactionsIncInput = {
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "reactions" */
export type ReactionsInsertInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  message?: InputMaybe<MessagesObjRelInsertInput>;
  /** Message that reaction is on */
  messageId?: InputMaybe<Scalars['uuid']['input']>;
  /** Emoji selected */
  text?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  /** User that is reacted to */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ReactionsMaxFields = {
  __typename?: 'ReactionsMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Message that reaction is on */
  messageId?: Maybe<Scalars['uuid']['output']>;
  /** Emoji selected */
  text?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** User that is reacted to */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "reactions" */
export type ReactionsMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Message that reaction is on */
  messageId?: InputMaybe<OrderBy>;
  /** Emoji selected */
  text?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** User that is reacted to */
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ReactionsMinFields = {
  __typename?: 'ReactionsMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Message that reaction is on */
  messageId?: Maybe<Scalars['uuid']['output']>;
  /** Emoji selected */
  text?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** User that is reacted to */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "reactions" */
export type ReactionsMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Message that reaction is on */
  messageId?: InputMaybe<OrderBy>;
  /** Emoji selected */
  text?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** User that is reacted to */
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "reactions" */
export type ReactionsMutationResponse = {
  __typename?: 'ReactionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Reactions>;
};

/** on_conflict condition type for table "reactions" */
export type ReactionsOnConflict = {
  constraint: ReactionsConstraint;
  updateColumns?: Array<ReactionsUpdateColumn>;
  where?: InputMaybe<ReactionsBoolExp>;
};

/** Ordering options when selecting data from "reactions". */
export type ReactionsOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  message?: InputMaybe<MessagesOrderBy>;
  messageId?: InputMaybe<OrderBy>;
  text?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: reactions */
export type ReactionsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "reactions" */
export enum ReactionsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "reactions" */
export type ReactionsSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Message that reaction is on */
  messageId?: InputMaybe<Scalars['uuid']['input']>;
  /** Emoji selected */
  text?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** User that is reacted to */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type ReactionsStddevFields = {
  __typename?: 'ReactionsStddevFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "reactions" */
export type ReactionsStddevOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type ReactionsStddevPopFields = {
  __typename?: 'ReactionsStddevPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "reactions" */
export type ReactionsStddevPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type ReactionsStddevSampFields = {
  __typename?: 'ReactionsStddevSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "reactions" */
export type ReactionsStddevSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "reactions" */
export type ReactionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ReactionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ReactionsStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Message that reaction is on */
  messageId?: InputMaybe<Scalars['uuid']['input']>;
  /** Emoji selected */
  text?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** User that is reacted to */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type ReactionsSumFields = {
  __typename?: 'ReactionsSumFields';
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "reactions" */
export type ReactionsSumOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** update columns of table "reactions" */
export enum ReactionsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type ReactionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ReactionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ReactionsSetInput>;
  /** filter the rows which have to be updated */
  where: ReactionsBoolExp;
};

/** aggregate varPop on columns */
export type ReactionsVarPopFields = {
  __typename?: 'ReactionsVarPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "reactions" */
export type ReactionsVarPopOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type ReactionsVarSampFields = {
  __typename?: 'ReactionsVarSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "reactions" */
export type ReactionsVarSampOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ReactionsVarianceFields = {
  __typename?: 'ReactionsVarianceFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "reactions" */
export type ReactionsVarianceOrderBy = {
  lastModifiedVersion?: InputMaybe<OrderBy>;
};

/** Video recordings created by users using the Loom-style screen recorder */
export type Recordings = {
  __typename?: 'Recordings';
  accountId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamp']['output'];
  /** An object relationship */
  document?: Maybe<Documents>;
  /** Document that the recording is attached to */
  documentId?: Maybe<Scalars['uuid']['output']>;
  /** URL pointing to the full resolution recording file */
  fileUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the file URL expires */
  fileUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  id: Scalars['uuid']['output'];
  /** [analytics] - allows us to remove demo recordings from analytics */
  isDemo?: Maybe<Scalars['Boolean']['output']>;
  /** remove */
  isIntro: Scalars['Boolean']['output'];
  /** Message that the recording is attached to */
  messageId?: Maybe<Scalars['uuid']['output']>;
  /** check and possible remove - the page that the recording was on */
  page: Scalars['Int']['output'];
  /** remove */
  recordableType?: Maybe<Scalars['String']['output']>;
  /** remove */
  requestId?: Maybe<Scalars['uuid']['output']>;
  /** remove */
  reviewer?: Maybe<Scalars['String']['output']>;
  /** check and remove - previously used to generate urls for recordings */
  slug?: Maybe<Scalars['String']['output']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus: Scalars['Int']['output'];
  /** URL for a smaller preview/thumbnail version of the recording */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  /** An array relationship */
  transcriptions: Array<Transcriptions>;
  /** An aggregate relationship */
  transcriptionsAggregate: TranscriptionsAggregate;
  updatedAt: Scalars['timestamp']['output'];
  /** An object relationship */
  user: Users;
  /** User who created the recording */
  userId: Scalars['uuid']['output'];
  /** check and possibly remove - ids of users who have viewed the recording */
  viewedBy?: Maybe<Scalars['jsonb']['output']>;
};


/** Video recordings created by users using the Loom-style screen recorder */
export type RecordingsTranscriptionsArgs = {
  distinctOn?: InputMaybe<Array<TranscriptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TranscriptionsOrderBy>>;
  where?: InputMaybe<TranscriptionsBoolExp>;
};


/** Video recordings created by users using the Loom-style screen recorder */
export type RecordingsTranscriptionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<TranscriptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TranscriptionsOrderBy>>;
  where?: InputMaybe<TranscriptionsBoolExp>;
};


/** Video recordings created by users using the Loom-style screen recorder */
export type RecordingsViewedByArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "recordings" */
export type RecordingsAggregate = {
  __typename?: 'RecordingsAggregate';
  aggregate?: Maybe<RecordingsAggregateFields>;
  nodes: Array<Recordings>;
};

export type RecordingsAggregateBoolExp = {
  bool_and?: InputMaybe<RecordingsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<RecordingsAggregateBoolExpBool_Or>;
  count?: InputMaybe<RecordingsAggregateBoolExpCount>;
};

/** aggregate fields of "recordings" */
export type RecordingsAggregateFields = {
  __typename?: 'RecordingsAggregateFields';
  avg?: Maybe<RecordingsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<RecordingsMaxFields>;
  min?: Maybe<RecordingsMinFields>;
  stddev?: Maybe<RecordingsStddevFields>;
  stddevPop?: Maybe<RecordingsStddevPopFields>;
  stddevSamp?: Maybe<RecordingsStddevSampFields>;
  sum?: Maybe<RecordingsSumFields>;
  varPop?: Maybe<RecordingsVarPopFields>;
  varSamp?: Maybe<RecordingsVarSampFields>;
  variance?: Maybe<RecordingsVarianceFields>;
};


/** aggregate fields of "recordings" */
export type RecordingsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<RecordingsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "recordings" */
export type RecordingsAggregateOrderBy = {
  avg?: InputMaybe<RecordingsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<RecordingsMaxOrderBy>;
  min?: InputMaybe<RecordingsMinOrderBy>;
  stddev?: InputMaybe<RecordingsStddevOrderBy>;
  stddevPop?: InputMaybe<RecordingsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<RecordingsStddevSampOrderBy>;
  sum?: InputMaybe<RecordingsSumOrderBy>;
  varPop?: InputMaybe<RecordingsVarPopOrderBy>;
  varSamp?: InputMaybe<RecordingsVarSampOrderBy>;
  variance?: InputMaybe<RecordingsVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type RecordingsAppendInput = {
  /** check and possibly remove - ids of users who have viewed the recording */
  viewedBy?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "recordings" */
export type RecordingsArrRelInsertInput = {
  data: Array<RecordingsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<RecordingsOnConflict>;
};

/** aggregate avg on columns */
export type RecordingsAvgFields = {
  __typename?: 'RecordingsAvgFields';
  /** check and possible remove - the page that the recording was on */
  page?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "recordings" */
export type RecordingsAvgOrderBy = {
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<OrderBy>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "recordings". All fields are combined with a logical 'AND'. */
export type RecordingsBoolExp = {
  _and?: InputMaybe<Array<RecordingsBoolExp>>;
  _not?: InputMaybe<RecordingsBoolExp>;
  _or?: InputMaybe<Array<RecordingsBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  document?: InputMaybe<DocumentsBoolExp>;
  documentId?: InputMaybe<UuidComparisonExp>;
  fileUrl?: InputMaybe<StringComparisonExp>;
  fileUrlExpiresAt?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isDemo?: InputMaybe<BooleanComparisonExp>;
  isIntro?: InputMaybe<BooleanComparisonExp>;
  messageId?: InputMaybe<UuidComparisonExp>;
  page?: InputMaybe<IntComparisonExp>;
  recordableType?: InputMaybe<StringComparisonExp>;
  requestId?: InputMaybe<UuidComparisonExp>;
  reviewer?: InputMaybe<StringComparisonExp>;
  slug?: InputMaybe<StringComparisonExp>;
  thumbnailProcessingStatus?: InputMaybe<IntComparisonExp>;
  thumbnailUrl?: InputMaybe<StringComparisonExp>;
  thumbnailUrlExpiresAt?: InputMaybe<TimestampComparisonExp>;
  transcriptions?: InputMaybe<TranscriptionsBoolExp>;
  transcriptionsAggregate?: InputMaybe<TranscriptionsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  viewedBy?: InputMaybe<JsonbComparisonExp>;
};

/** unique or primary key constraints on table "recordings" */
export enum RecordingsConstraint {
  /** unique or primary key constraint on columns "slug" */
  IndexRecordingsOnSlug = 'index_recordings_on_slug',
  /** unique or primary key constraint on columns "id" */
  RecordingsPkey = 'recordings_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type RecordingsDeleteAtPathInput = {
  /** check and possibly remove - ids of users who have viewed the recording */
  viewedBy?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type RecordingsDeleteElemInput = {
  /** check and possibly remove - ids of users who have viewed the recording */
  viewedBy?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type RecordingsDeleteKeyInput = {
  /** check and possibly remove - ids of users who have viewed the recording */
  viewedBy?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "recordings" */
export type RecordingsIncInput = {
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<Scalars['Int']['input']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "recordings" */
export type RecordingsInsertInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  document?: InputMaybe<DocumentsObjRelInsertInput>;
  /** Document that the recording is attached to */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** URL pointing to the full resolution recording file */
  fileUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the file URL expires */
  fileUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [analytics] - allows us to remove demo recordings from analytics */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove */
  isIntro?: InputMaybe<Scalars['Boolean']['input']>;
  /** Message that the recording is attached to */
  messageId?: InputMaybe<Scalars['uuid']['input']>;
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<Scalars['Int']['input']>;
  /** remove */
  recordableType?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  requestId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove */
  reviewer?: InputMaybe<Scalars['String']['input']>;
  /** check and remove - previously used to generate urls for recordings */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** URL for a smaller preview/thumbnail version of the recording */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  transcriptions?: InputMaybe<TranscriptionsArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  /** User who created the recording */
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** check and possibly remove - ids of users who have viewed the recording */
  viewedBy?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate max on columns */
export type RecordingsMaxFields = {
  __typename?: 'RecordingsMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** Document that the recording is attached to */
  documentId?: Maybe<Scalars['uuid']['output']>;
  /** URL pointing to the full resolution recording file */
  fileUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the file URL expires */
  fileUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** Message that the recording is attached to */
  messageId?: Maybe<Scalars['uuid']['output']>;
  /** check and possible remove - the page that the recording was on */
  page?: Maybe<Scalars['Int']['output']>;
  /** remove */
  recordableType?: Maybe<Scalars['String']['output']>;
  /** remove */
  requestId?: Maybe<Scalars['uuid']['output']>;
  /** remove */
  reviewer?: Maybe<Scalars['String']['output']>;
  /** check and remove - previously used to generate urls for recordings */
  slug?: Maybe<Scalars['String']['output']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** URL for a smaller preview/thumbnail version of the recording */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** User who created the recording */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "recordings" */
export type RecordingsMaxOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** Document that the recording is attached to */
  documentId?: InputMaybe<OrderBy>;
  /** URL pointing to the full resolution recording file */
  fileUrl?: InputMaybe<OrderBy>;
  /** Timestamp when the file URL expires */
  fileUrlExpiresAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** Message that the recording is attached to */
  messageId?: InputMaybe<OrderBy>;
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<OrderBy>;
  /** remove */
  recordableType?: InputMaybe<OrderBy>;
  /** remove */
  requestId?: InputMaybe<OrderBy>;
  /** remove */
  reviewer?: InputMaybe<OrderBy>;
  /** check and remove - previously used to generate urls for recordings */
  slug?: InputMaybe<OrderBy>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** URL for a smaller preview/thumbnail version of the recording */
  thumbnailUrl?: InputMaybe<OrderBy>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** User who created the recording */
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type RecordingsMinFields = {
  __typename?: 'RecordingsMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** Document that the recording is attached to */
  documentId?: Maybe<Scalars['uuid']['output']>;
  /** URL pointing to the full resolution recording file */
  fileUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the file URL expires */
  fileUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** Message that the recording is attached to */
  messageId?: Maybe<Scalars['uuid']['output']>;
  /** check and possible remove - the page that the recording was on */
  page?: Maybe<Scalars['Int']['output']>;
  /** remove */
  recordableType?: Maybe<Scalars['String']['output']>;
  /** remove */
  requestId?: Maybe<Scalars['uuid']['output']>;
  /** remove */
  reviewer?: Maybe<Scalars['String']['output']>;
  /** check and remove - previously used to generate urls for recordings */
  slug?: Maybe<Scalars['String']['output']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** URL for a smaller preview/thumbnail version of the recording */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** User who created the recording */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "recordings" */
export type RecordingsMinOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** Document that the recording is attached to */
  documentId?: InputMaybe<OrderBy>;
  /** URL pointing to the full resolution recording file */
  fileUrl?: InputMaybe<OrderBy>;
  /** Timestamp when the file URL expires */
  fileUrlExpiresAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** Message that the recording is attached to */
  messageId?: InputMaybe<OrderBy>;
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<OrderBy>;
  /** remove */
  recordableType?: InputMaybe<OrderBy>;
  /** remove */
  requestId?: InputMaybe<OrderBy>;
  /** remove */
  reviewer?: InputMaybe<OrderBy>;
  /** check and remove - previously used to generate urls for recordings */
  slug?: InputMaybe<OrderBy>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** URL for a smaller preview/thumbnail version of the recording */
  thumbnailUrl?: InputMaybe<OrderBy>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** User who created the recording */
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "recordings" */
export type RecordingsMutationResponse = {
  __typename?: 'RecordingsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Recordings>;
};

/** input type for inserting object relation for remote table "recordings" */
export type RecordingsObjRelInsertInput = {
  data: RecordingsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<RecordingsOnConflict>;
};

/** on_conflict condition type for table "recordings" */
export type RecordingsOnConflict = {
  constraint: RecordingsConstraint;
  updateColumns?: Array<RecordingsUpdateColumn>;
  where?: InputMaybe<RecordingsBoolExp>;
};

/** Ordering options when selecting data from "recordings". */
export type RecordingsOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  document?: InputMaybe<DocumentsOrderBy>;
  documentId?: InputMaybe<OrderBy>;
  fileUrl?: InputMaybe<OrderBy>;
  fileUrlExpiresAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isDemo?: InputMaybe<OrderBy>;
  isIntro?: InputMaybe<OrderBy>;
  messageId?: InputMaybe<OrderBy>;
  page?: InputMaybe<OrderBy>;
  recordableType?: InputMaybe<OrderBy>;
  requestId?: InputMaybe<OrderBy>;
  reviewer?: InputMaybe<OrderBy>;
  slug?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  thumbnailUrl?: InputMaybe<OrderBy>;
  thumbnailUrlExpiresAt?: InputMaybe<OrderBy>;
  transcriptionsAggregate?: InputMaybe<TranscriptionsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  viewedBy?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: recordings */
export type RecordingsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type RecordingsPrependInput = {
  /** check and possibly remove - ids of users who have viewed the recording */
  viewedBy?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "recordings" */
export enum RecordingsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DocumentId = 'documentId',
  /** column name */
  FileUrl = 'fileUrl',
  /** column name */
  FileUrlExpiresAt = 'fileUrlExpiresAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  IsIntro = 'isIntro',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  Page = 'page',
  /** column name */
  RecordableType = 'recordableType',
  /** column name */
  RequestId = 'requestId',
  /** column name */
  Reviewer = 'reviewer',
  /** column name */
  Slug = 'slug',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  ThumbnailUrl = 'thumbnailUrl',
  /** column name */
  ThumbnailUrlExpiresAt = 'thumbnailUrlExpiresAt',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  ViewedBy = 'viewedBy'
}

/** select "recordingsAggregateBoolExpBool_andArgumentsColumns" columns of table "recordings" */
export enum RecordingsSelectColumnRecordingsAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  IsIntro = 'isIntro'
}

/** select "recordingsAggregateBoolExpBool_orArgumentsColumns" columns of table "recordings" */
export enum RecordingsSelectColumnRecordingsAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  IsIntro = 'isIntro'
}

/** input type for updating data in table "recordings" */
export type RecordingsSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Document that the recording is attached to */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** URL pointing to the full resolution recording file */
  fileUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the file URL expires */
  fileUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [analytics] - allows us to remove demo recordings from analytics */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove */
  isIntro?: InputMaybe<Scalars['Boolean']['input']>;
  /** Message that the recording is attached to */
  messageId?: InputMaybe<Scalars['uuid']['input']>;
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<Scalars['Int']['input']>;
  /** remove */
  recordableType?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  requestId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove */
  reviewer?: InputMaybe<Scalars['String']['input']>;
  /** check and remove - previously used to generate urls for recordings */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** URL for a smaller preview/thumbnail version of the recording */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** User who created the recording */
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** check and possibly remove - ids of users who have viewed the recording */
  viewedBy?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate stddev on columns */
export type RecordingsStddevFields = {
  __typename?: 'RecordingsStddevFields';
  /** check and possible remove - the page that the recording was on */
  page?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "recordings" */
export type RecordingsStddevOrderBy = {
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<OrderBy>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type RecordingsStddevPopFields = {
  __typename?: 'RecordingsStddevPopFields';
  /** check and possible remove - the page that the recording was on */
  page?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "recordings" */
export type RecordingsStddevPopOrderBy = {
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<OrderBy>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type RecordingsStddevSampFields = {
  __typename?: 'RecordingsStddevSampFields';
  /** check and possible remove - the page that the recording was on */
  page?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "recordings" */
export type RecordingsStddevSampOrderBy = {
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<OrderBy>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "recordings" */
export type RecordingsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: RecordingsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RecordingsStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Document that the recording is attached to */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** URL pointing to the full resolution recording file */
  fileUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the file URL expires */
  fileUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [analytics] - allows us to remove demo recordings from analytics */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove */
  isIntro?: InputMaybe<Scalars['Boolean']['input']>;
  /** Message that the recording is attached to */
  messageId?: InputMaybe<Scalars['uuid']['input']>;
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<Scalars['Int']['input']>;
  /** remove */
  recordableType?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  requestId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove */
  reviewer?: InputMaybe<Scalars['String']['input']>;
  /** check and remove - previously used to generate urls for recordings */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** URL for a smaller preview/thumbnail version of the recording */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** User who created the recording */
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** check and possibly remove - ids of users who have viewed the recording */
  viewedBy?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate sum on columns */
export type RecordingsSumFields = {
  __typename?: 'RecordingsSumFields';
  /** check and possible remove - the page that the recording was on */
  page?: Maybe<Scalars['Int']['output']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "recordings" */
export type RecordingsSumOrderBy = {
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<OrderBy>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** update columns of table "recordings" */
export enum RecordingsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DocumentId = 'documentId',
  /** column name */
  FileUrl = 'fileUrl',
  /** column name */
  FileUrlExpiresAt = 'fileUrlExpiresAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  IsIntro = 'isIntro',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  Page = 'page',
  /** column name */
  RecordableType = 'recordableType',
  /** column name */
  RequestId = 'requestId',
  /** column name */
  Reviewer = 'reviewer',
  /** column name */
  Slug = 'slug',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  ThumbnailUrl = 'thumbnailUrl',
  /** column name */
  ThumbnailUrlExpiresAt = 'thumbnailUrlExpiresAt',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  ViewedBy = 'viewedBy'
}

export type RecordingsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<RecordingsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<RecordingsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<RecordingsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<RecordingsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<RecordingsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<RecordingsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<RecordingsSetInput>;
  /** filter the rows which have to be updated */
  where: RecordingsBoolExp;
};

/** aggregate varPop on columns */
export type RecordingsVarPopFields = {
  __typename?: 'RecordingsVarPopFields';
  /** check and possible remove - the page that the recording was on */
  page?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "recordings" */
export type RecordingsVarPopOrderBy = {
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<OrderBy>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type RecordingsVarSampFields = {
  __typename?: 'RecordingsVarSampFields';
  /** check and possible remove - the page that the recording was on */
  page?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "recordings" */
export type RecordingsVarSampOrderBy = {
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<OrderBy>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type RecordingsVarianceFields = {
  __typename?: 'RecordingsVarianceFields';
  /** check and possible remove - the page that the recording was on */
  page?: Maybe<Scalars['Float']['output']>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "recordings" */
export type RecordingsVarianceOrderBy = {
  /** check and possible remove - the page that the recording was on */
  page?: InputMaybe<OrderBy>;
  /** tracks status of processing the thumbnail of the recording into an optimised image */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
};

export type ReferralStats = {
  __typename?: 'ReferralStats';
  amountSaved: Scalars['String']['output'];
  paidAccounts: Scalars['Int']['output'];
  trialAccounts: Scalars['Int']['output'];
};

export type Scroll = {
  x: Scalars['Int']['input'];
  y: Scalars['Int']['input'];
};

export type SeatSubscriptionDetails = {
  __typename?: 'SeatSubscriptionDetails';
  amount: Scalars['String']['output'];
  discountPercentage: Scalars['String']['output'];
  nextInvoiceDate: Scalars['String']['output'];
  type: Actions_SubscriptionTypesEnum;
};

/** CanvasItems subtype that stores the metadata relating to websites */
export type SiteItems = {
  __typename?: 'SiteItems';
  accountId: Scalars['uuid']['output'];
  /** An object relationship */
  canvasItem?: Maybe<CanvasItems>;
  /** The parent canvas item */
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  createdAt: Scalars['timestamp']['output'];
  id: Scalars['uuid']['output'];
  lastModifiedVersion: Scalars['Int']['output'];
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus: Scalars['Int']['output'];
  updatedAt: Scalars['timestamp']['output'];
  /** The URL of the site */
  url: Scalars['String']['output'];
};

/** aggregated selection of "site_items" */
export type SiteItemsAggregate = {
  __typename?: 'SiteItemsAggregate';
  aggregate?: Maybe<SiteItemsAggregateFields>;
  nodes: Array<SiteItems>;
};

/** aggregate fields of "site_items" */
export type SiteItemsAggregateFields = {
  __typename?: 'SiteItemsAggregateFields';
  avg?: Maybe<SiteItemsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<SiteItemsMaxFields>;
  min?: Maybe<SiteItemsMinFields>;
  stddev?: Maybe<SiteItemsStddevFields>;
  stddevPop?: Maybe<SiteItemsStddevPopFields>;
  stddevSamp?: Maybe<SiteItemsStddevSampFields>;
  sum?: Maybe<SiteItemsSumFields>;
  varPop?: Maybe<SiteItemsVarPopFields>;
  varSamp?: Maybe<SiteItemsVarSampFields>;
  variance?: Maybe<SiteItemsVarianceFields>;
};


/** aggregate fields of "site_items" */
export type SiteItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SiteItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type SiteItemsAvgFields = {
  __typename?: 'SiteItemsAvgFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "site_items". All fields are combined with a logical 'AND'. */
export type SiteItemsBoolExp = {
  _and?: InputMaybe<Array<SiteItemsBoolExp>>;
  _not?: InputMaybe<SiteItemsBoolExp>;
  _or?: InputMaybe<Array<SiteItemsBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  canvasItem?: InputMaybe<CanvasItemsBoolExp>;
  canvasItemId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  thumbnailProcessingError?: InputMaybe<StringComparisonExp>;
  thumbnailProcessingStatus?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  url?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "site_items" */
export enum SiteItemsConstraint {
  /** unique or primary key constraint on columns "canvas_item_id" */
  IndexSiteItemsOnCanvasItemId = 'index_site_items_on_canvas_item_id',
  /** unique or primary key constraint on columns "id" */
  SiteItemsPkey = 'site_items_pkey'
}

/** input type for incrementing numeric columns in table "site_items" */
export type SiteItemsIncInput = {
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "site_items" */
export type SiteItemsInsertInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  canvasItem?: InputMaybe<CanvasItemsObjRelInsertInput>;
  /** The parent canvas item */
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The URL of the site */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type SiteItemsMaxFields = {
  __typename?: 'SiteItemsMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** The parent canvas item */
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** The URL of the site */
  url?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type SiteItemsMinFields = {
  __typename?: 'SiteItemsMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** The parent canvas item */
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** The URL of the site */
  url?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "site_items" */
export type SiteItemsMutationResponse = {
  __typename?: 'SiteItemsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SiteItems>;
};

/** input type for inserting object relation for remote table "site_items" */
export type SiteItemsObjRelInsertInput = {
  data: SiteItemsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<SiteItemsOnConflict>;
};

/** on_conflict condition type for table "site_items" */
export type SiteItemsOnConflict = {
  constraint: SiteItemsConstraint;
  updateColumns?: Array<SiteItemsUpdateColumn>;
  where?: InputMaybe<SiteItemsBoolExp>;
};

/** Ordering options when selecting data from "site_items". */
export type SiteItemsOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  canvasItem?: InputMaybe<CanvasItemsOrderBy>;
  canvasItemId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  thumbnailProcessingError?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: site_items */
export type SiteItemsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "site_items" */
export enum SiteItemsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CanvasItemId = 'canvasItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  ThumbnailProcessingError = 'thumbnailProcessingError',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Url = 'url'
}

/** input type for updating data in table "site_items" */
export type SiteItemsSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** The parent canvas item */
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The URL of the site */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type SiteItemsStddevFields = {
  __typename?: 'SiteItemsStddevFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type SiteItemsStddevPopFields = {
  __typename?: 'SiteItemsStddevPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type SiteItemsStddevSampFields = {
  __typename?: 'SiteItemsStddevSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "site_items" */
export type SiteItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SiteItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SiteItemsStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** The parent canvas item */
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The URL of the site */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type SiteItemsSumFields = {
  __typename?: 'SiteItemsSumFields';
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "site_items" */
export enum SiteItemsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CanvasItemId = 'canvasItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  ThumbnailProcessingError = 'thumbnailProcessingError',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Url = 'url'
}

export type SiteItemsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<SiteItemsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SiteItemsSetInput>;
  /** filter the rows which have to be updated */
  where: SiteItemsBoolExp;
};

/** aggregate varPop on columns */
export type SiteItemsVarPopFields = {
  __typename?: 'SiteItemsVarPopFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type SiteItemsVarSampFields = {
  __typename?: 'SiteItemsVarSampFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type SiteItemsVarianceFields = {
  __typename?: 'SiteItemsVarianceFields';
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the site item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
};

/** Metadata to access multiple related objects in S3 */
export type StorageMultiObjectsMetadata = {
  __typename?: 'StorageMultiObjectsMetadata';
  /** S3 bucket */
  bucket: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  /** Path to the directory in S3 */
  dirKey: Scalars['String']['output'];
  /** Array of file names stored in the S3 directory */
  fileNames: Array<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};

/** aggregated selection of "storage_multi_objects_metadata" */
export type StorageMultiObjectsMetadataAggregate = {
  __typename?: 'StorageMultiObjectsMetadataAggregate';
  aggregate?: Maybe<StorageMultiObjectsMetadataAggregateFields>;
  nodes: Array<StorageMultiObjectsMetadata>;
};

/** aggregate fields of "storage_multi_objects_metadata" */
export type StorageMultiObjectsMetadataAggregateFields = {
  __typename?: 'StorageMultiObjectsMetadataAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<StorageMultiObjectsMetadataMaxFields>;
  min?: Maybe<StorageMultiObjectsMetadataMinFields>;
};


/** aggregate fields of "storage_multi_objects_metadata" */
export type StorageMultiObjectsMetadataAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StorageMultiObjectsMetadataSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "storage_multi_objects_metadata". All fields are combined with a logical 'AND'. */
export type StorageMultiObjectsMetadataBoolExp = {
  _and?: InputMaybe<Array<StorageMultiObjectsMetadataBoolExp>>;
  _not?: InputMaybe<StorageMultiObjectsMetadataBoolExp>;
  _or?: InputMaybe<Array<StorageMultiObjectsMetadataBoolExp>>;
  bucket?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  dirKey?: InputMaybe<StringComparisonExp>;
  fileNames?: InputMaybe<StringArrayComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "storage_multi_objects_metadata" */
export enum StorageMultiObjectsMetadataConstraint {
  /** unique or primary key constraint on columns "id" */
  StorageMultiObjectsMetadataPkey = 'storage_multi_objects_metadata_pkey'
}

/** input type for inserting data into table "storage_multi_objects_metadata" */
export type StorageMultiObjectsMetadataInsertInput = {
  /** S3 bucket */
  bucket?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Path to the directory in S3 */
  dirKey?: InputMaybe<Scalars['String']['input']>;
  /** Array of file names stored in the S3 directory */
  fileNames?: InputMaybe<Array<Scalars['String']['input']>>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type StorageMultiObjectsMetadataMaxFields = {
  __typename?: 'StorageMultiObjectsMetadataMaxFields';
  /** S3 bucket */
  bucket?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Path to the directory in S3 */
  dirKey?: Maybe<Scalars['String']['output']>;
  /** Array of file names stored in the S3 directory */
  fileNames?: Maybe<Array<Scalars['String']['output']>>;
  id?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type StorageMultiObjectsMetadataMinFields = {
  __typename?: 'StorageMultiObjectsMetadataMinFields';
  /** S3 bucket */
  bucket?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Path to the directory in S3 */
  dirKey?: Maybe<Scalars['String']['output']>;
  /** Array of file names stored in the S3 directory */
  fileNames?: Maybe<Array<Scalars['String']['output']>>;
  id?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "storage_multi_objects_metadata" */
export type StorageMultiObjectsMetadataMutationResponse = {
  __typename?: 'StorageMultiObjectsMetadataMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<StorageMultiObjectsMetadata>;
};

/** input type for inserting object relation for remote table "storage_multi_objects_metadata" */
export type StorageMultiObjectsMetadataObjRelInsertInput = {
  data: StorageMultiObjectsMetadataInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<StorageMultiObjectsMetadataOnConflict>;
};

/** on_conflict condition type for table "storage_multi_objects_metadata" */
export type StorageMultiObjectsMetadataOnConflict = {
  constraint: StorageMultiObjectsMetadataConstraint;
  updateColumns?: Array<StorageMultiObjectsMetadataUpdateColumn>;
  where?: InputMaybe<StorageMultiObjectsMetadataBoolExp>;
};

/** Ordering options when selecting data from "storage_multi_objects_metadata". */
export type StorageMultiObjectsMetadataOrderBy = {
  bucket?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  dirKey?: InputMaybe<OrderBy>;
  fileNames?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: storage_multi_objects_metadata */
export type StorageMultiObjectsMetadataPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "storage_multi_objects_metadata" */
export enum StorageMultiObjectsMetadataSelectColumn {
  /** column name */
  Bucket = 'bucket',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DirKey = 'dirKey',
  /** column name */
  FileNames = 'fileNames',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "storage_multi_objects_metadata" */
export type StorageMultiObjectsMetadataSetInput = {
  /** S3 bucket */
  bucket?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Path to the directory in S3 */
  dirKey?: InputMaybe<Scalars['String']['input']>;
  /** Array of file names stored in the S3 directory */
  fileNames?: InputMaybe<Array<Scalars['String']['input']>>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "storage_multi_objects_metadata" */
export type StorageMultiObjectsMetadataStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: StorageMultiObjectsMetadataStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StorageMultiObjectsMetadataStreamCursorValueInput = {
  /** S3 bucket */
  bucket?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Path to the directory in S3 */
  dirKey?: InputMaybe<Scalars['String']['input']>;
  /** Array of file names stored in the S3 directory */
  fileNames?: InputMaybe<Array<Scalars['String']['input']>>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "storage_multi_objects_metadata" */
export enum StorageMultiObjectsMetadataUpdateColumn {
  /** column name */
  Bucket = 'bucket',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DirKey = 'dirKey',
  /** column name */
  FileNames = 'fileNames',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type StorageMultiObjectsMetadataUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StorageMultiObjectsMetadataSetInput>;
  /** filter the rows which have to be updated */
  where: StorageMultiObjectsMetadataBoolExp;
};

/** Metadata to access objects in the S3 */
export type StorageObjectsMetadata = {
  __typename?: 'StorageObjectsMetadata';
  bucket: Scalars['String']['output'];
  bytes?: Maybe<Scalars['bigint']['output']>;
  contentType?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  id: Scalars['uuid']['output'];
  key: Scalars['String']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};

/** aggregated selection of "storage_objects_metadata" */
export type StorageObjectsMetadataAggregate = {
  __typename?: 'StorageObjectsMetadataAggregate';
  aggregate?: Maybe<StorageObjectsMetadataAggregateFields>;
  nodes: Array<StorageObjectsMetadata>;
};

/** aggregate fields of "storage_objects_metadata" */
export type StorageObjectsMetadataAggregateFields = {
  __typename?: 'StorageObjectsMetadataAggregateFields';
  avg?: Maybe<StorageObjectsMetadataAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<StorageObjectsMetadataMaxFields>;
  min?: Maybe<StorageObjectsMetadataMinFields>;
  stddev?: Maybe<StorageObjectsMetadataStddevFields>;
  stddevPop?: Maybe<StorageObjectsMetadataStddevPopFields>;
  stddevSamp?: Maybe<StorageObjectsMetadataStddevSampFields>;
  sum?: Maybe<StorageObjectsMetadataSumFields>;
  varPop?: Maybe<StorageObjectsMetadataVarPopFields>;
  varSamp?: Maybe<StorageObjectsMetadataVarSampFields>;
  variance?: Maybe<StorageObjectsMetadataVarianceFields>;
};


/** aggregate fields of "storage_objects_metadata" */
export type StorageObjectsMetadataAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StorageObjectsMetadataSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StorageObjectsMetadataAvgFields = {
  __typename?: 'StorageObjectsMetadataAvgFields';
  bytes?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "storage_objects_metadata". All fields are combined with a logical 'AND'. */
export type StorageObjectsMetadataBoolExp = {
  _and?: InputMaybe<Array<StorageObjectsMetadataBoolExp>>;
  _not?: InputMaybe<StorageObjectsMetadataBoolExp>;
  _or?: InputMaybe<Array<StorageObjectsMetadataBoolExp>>;
  bucket?: InputMaybe<StringComparisonExp>;
  bytes?: InputMaybe<BigintComparisonExp>;
  contentType?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  key?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "storage_objects_metadata" */
export enum StorageObjectsMetadataConstraint {
  /** unique or primary key constraint on columns "id" */
  StorageObjectsMetadataPkey = 'storage_objects_metadata_pkey'
}

/** input type for incrementing numeric columns in table "storage_objects_metadata" */
export type StorageObjectsMetadataIncInput = {
  bytes?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "storage_objects_metadata" */
export type StorageObjectsMetadataInsertInput = {
  bucket?: InputMaybe<Scalars['String']['input']>;
  bytes?: InputMaybe<Scalars['bigint']['input']>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type StorageObjectsMetadataMaxFields = {
  __typename?: 'StorageObjectsMetadataMaxFields';
  bucket?: Maybe<Scalars['String']['output']>;
  bytes?: Maybe<Scalars['bigint']['output']>;
  contentType?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type StorageObjectsMetadataMinFields = {
  __typename?: 'StorageObjectsMetadataMinFields';
  bucket?: Maybe<Scalars['String']['output']>;
  bytes?: Maybe<Scalars['bigint']['output']>;
  contentType?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "storage_objects_metadata" */
export type StorageObjectsMetadataMutationResponse = {
  __typename?: 'StorageObjectsMetadataMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<StorageObjectsMetadata>;
};

/** input type for inserting object relation for remote table "storage_objects_metadata" */
export type StorageObjectsMetadataObjRelInsertInput = {
  data: StorageObjectsMetadataInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<StorageObjectsMetadataOnConflict>;
};

/** on_conflict condition type for table "storage_objects_metadata" */
export type StorageObjectsMetadataOnConflict = {
  constraint: StorageObjectsMetadataConstraint;
  updateColumns?: Array<StorageObjectsMetadataUpdateColumn>;
  where?: InputMaybe<StorageObjectsMetadataBoolExp>;
};

/** Ordering options when selecting data from "storage_objects_metadata". */
export type StorageObjectsMetadataOrderBy = {
  bucket?: InputMaybe<OrderBy>;
  bytes?: InputMaybe<OrderBy>;
  contentType?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  key?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: storage_objects_metadata */
export type StorageObjectsMetadataPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "storage_objects_metadata" */
export enum StorageObjectsMetadataSelectColumn {
  /** column name */
  Bucket = 'bucket',
  /** column name */
  Bytes = 'bytes',
  /** column name */
  ContentType = 'contentType',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "storage_objects_metadata" */
export type StorageObjectsMetadataSetInput = {
  bucket?: InputMaybe<Scalars['String']['input']>;
  bytes?: InputMaybe<Scalars['bigint']['input']>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type StorageObjectsMetadataStddevFields = {
  __typename?: 'StorageObjectsMetadataStddevFields';
  bytes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type StorageObjectsMetadataStddevPopFields = {
  __typename?: 'StorageObjectsMetadataStddevPopFields';
  bytes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type StorageObjectsMetadataStddevSampFields = {
  __typename?: 'StorageObjectsMetadataStddevSampFields';
  bytes?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "storage_objects_metadata" */
export type StorageObjectsMetadataStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: StorageObjectsMetadataStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StorageObjectsMetadataStreamCursorValueInput = {
  bucket?: InputMaybe<Scalars['String']['input']>;
  bytes?: InputMaybe<Scalars['bigint']['input']>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type StorageObjectsMetadataSumFields = {
  __typename?: 'StorageObjectsMetadataSumFields';
  bytes?: Maybe<Scalars['bigint']['output']>;
};

/** update columns of table "storage_objects_metadata" */
export enum StorageObjectsMetadataUpdateColumn {
  /** column name */
  Bucket = 'bucket',
  /** column name */
  Bytes = 'bytes',
  /** column name */
  ContentType = 'contentType',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type StorageObjectsMetadataUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<StorageObjectsMetadataIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<StorageObjectsMetadataSetInput>;
  /** filter the rows which have to be updated */
  where: StorageObjectsMetadataBoolExp;
};

/** aggregate varPop on columns */
export type StorageObjectsMetadataVarPopFields = {
  __typename?: 'StorageObjectsMetadataVarPopFields';
  bytes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type StorageObjectsMetadataVarSampFields = {
  __typename?: 'StorageObjectsMetadataVarSampFields';
  bytes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StorageObjectsMetadataVarianceFields = {
  __typename?: 'StorageObjectsMetadataVarianceFields';
  bytes?: Maybe<Scalars['Float']['output']>;
};

export type StoragePrice = {
  __typename?: 'StoragePrice';
  limitInGb?: Maybe<Scalars['Int']['output']>;
  price: Scalars['String']['output'];
};

export type StorageSubscriptionDetails = {
  __typename?: 'StorageSubscriptionDetails';
  amount: Scalars['String']['output'];
  nextInvoiceDate: Scalars['String']['output'];
  upperLimitInGb: Scalars['Int']['output'];
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type StringArrayComparisonExp = {
  /** is the array contained in the given array value */
  _containedIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the array contain the given value */
  _contains?: InputMaybe<Array<Scalars['String']['input']>>;
  _eq?: InputMaybe<Array<Scalars['String']['input']>>;
  _gt?: InputMaybe<Array<Scalars['String']['input']>>;
  _gte?: InputMaybe<Array<Scalars['String']['input']>>;
  _in?: InputMaybe<Array<Array<Scalars['String']['input']>>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Array<Scalars['String']['input']>>;
  _lte?: InputMaybe<Array<Scalars['String']['input']>>;
  _neq?: InputMaybe<Array<Scalars['String']['input']>>;
  _nin?: InputMaybe<Array<Array<Scalars['String']['input']>>>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type StringComparisonExp = {
  _eq?: InputMaybe<Scalars['String']['input']>;
  _gt?: InputMaybe<Scalars['String']['input']>;
  _gte?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']['input']>;
  _in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']['input']>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']['input']>;
  _lt?: InputMaybe<Scalars['String']['input']>;
  _lte?: InputMaybe<Scalars['String']['input']>;
  _neq?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']['input']>;
  _nin?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']['input']>;
};

export type Subscription = {
  __typename?: 'Subscription';
  freeTrial?: Maybe<FreeTrial>;
  numberOfSeats: NumberOfSeats;
  paidSubscription?: Maybe<PaidSubscription>;
  storageUsageInBytes: Scalars['Int']['output'];
};

/** columns and relationships of "subscription_statuses" */
export type SubscriptionStatuses = {
  __typename?: 'SubscriptionStatuses';
  value: Scalars['String']['output'];
};

/** aggregated selection of "subscription_statuses" */
export type SubscriptionStatusesAggregate = {
  __typename?: 'SubscriptionStatusesAggregate';
  aggregate?: Maybe<SubscriptionStatusesAggregateFields>;
  nodes: Array<SubscriptionStatuses>;
};

/** aggregate fields of "subscription_statuses" */
export type SubscriptionStatusesAggregateFields = {
  __typename?: 'SubscriptionStatusesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<SubscriptionStatusesMaxFields>;
  min?: Maybe<SubscriptionStatusesMinFields>;
};


/** aggregate fields of "subscription_statuses" */
export type SubscriptionStatusesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SubscriptionStatusesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "subscription_statuses". All fields are combined with a logical 'AND'. */
export type SubscriptionStatusesBoolExp = {
  _and?: InputMaybe<Array<SubscriptionStatusesBoolExp>>;
  _not?: InputMaybe<SubscriptionStatusesBoolExp>;
  _or?: InputMaybe<Array<SubscriptionStatusesBoolExp>>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "subscription_statuses" */
export enum SubscriptionStatusesConstraint {
  /** unique or primary key constraint on columns "value" */
  SubscriptionStatusesPkey = 'subscription_statuses_pkey'
}

export enum SubscriptionStatusesEnum {
  Cancelled = 'CANCELLED',
  Paid = 'PAID',
  PaidInArrears = 'PAID_IN_ARREARS',
  Trial = 'TRIAL',
  TrialExtended = 'TRIAL_EXTENDED'
}

/** Boolean expression to compare columns of type "SubscriptionStatusesEnum". All fields are combined with logical 'AND'. */
export type SubscriptionStatusesEnumComparisonExp = {
  _eq?: InputMaybe<SubscriptionStatusesEnum>;
  _in?: InputMaybe<Array<SubscriptionStatusesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<SubscriptionStatusesEnum>;
  _nin?: InputMaybe<Array<SubscriptionStatusesEnum>>;
};

/** input type for inserting data into table "subscription_statuses" */
export type SubscriptionStatusesInsertInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type SubscriptionStatusesMaxFields = {
  __typename?: 'SubscriptionStatusesMaxFields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type SubscriptionStatusesMinFields = {
  __typename?: 'SubscriptionStatusesMinFields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "subscription_statuses" */
export type SubscriptionStatusesMutationResponse = {
  __typename?: 'SubscriptionStatusesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SubscriptionStatuses>;
};

/** on_conflict condition type for table "subscription_statuses" */
export type SubscriptionStatusesOnConflict = {
  constraint: SubscriptionStatusesConstraint;
  updateColumns?: Array<SubscriptionStatusesUpdateColumn>;
  where?: InputMaybe<SubscriptionStatusesBoolExp>;
};

/** Ordering options when selecting data from "subscription_statuses". */
export type SubscriptionStatusesOrderBy = {
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: subscription_statuses */
export type SubscriptionStatusesPkColumnsInput = {
  value: Scalars['String']['input'];
};

/** select columns of table "subscription_statuses" */
export enum SubscriptionStatusesSelectColumn {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "subscription_statuses" */
export type SubscriptionStatusesSetInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "subscription_statuses" */
export type SubscriptionStatusesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SubscriptionStatusesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SubscriptionStatusesStreamCursorValueInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "subscription_statuses" */
export enum SubscriptionStatusesUpdateColumn {
  /** column name */
  Value = 'value'
}

export type SubscriptionStatusesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SubscriptionStatusesSetInput>;
  /** filter the rows which have to be updated */
  where: SubscriptionStatusesBoolExp;
};

/** columns and relationships of "subscription_types" */
export type SubscriptionTypes = {
  __typename?: 'SubscriptionTypes';
  value: Scalars['String']['output'];
};

/** aggregated selection of "subscription_types" */
export type SubscriptionTypesAggregate = {
  __typename?: 'SubscriptionTypesAggregate';
  aggregate?: Maybe<SubscriptionTypesAggregateFields>;
  nodes: Array<SubscriptionTypes>;
};

/** aggregate fields of "subscription_types" */
export type SubscriptionTypesAggregateFields = {
  __typename?: 'SubscriptionTypesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<SubscriptionTypesMaxFields>;
  min?: Maybe<SubscriptionTypesMinFields>;
};


/** aggregate fields of "subscription_types" */
export type SubscriptionTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SubscriptionTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "subscription_types". All fields are combined with a logical 'AND'. */
export type SubscriptionTypesBoolExp = {
  _and?: InputMaybe<Array<SubscriptionTypesBoolExp>>;
  _not?: InputMaybe<SubscriptionTypesBoolExp>;
  _or?: InputMaybe<Array<SubscriptionTypesBoolExp>>;
  value?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "subscription_types" */
export enum SubscriptionTypesConstraint {
  /** unique or primary key constraint on columns "value" */
  SubscriptionTypesPkey = 'subscription_types_pkey'
}

export enum SubscriptionTypesEnum {
  PerSeatAnnual = 'PER_SEAT_ANNUAL',
  PerSeatMonthly = 'PER_SEAT_MONTHLY',
  UnlimitedAnnual = 'UNLIMITED_ANNUAL',
  UnlimitedMonthly = 'UNLIMITED_MONTHLY'
}

/** Boolean expression to compare columns of type "SubscriptionTypesEnum". All fields are combined with logical 'AND'. */
export type SubscriptionTypesEnumComparisonExp = {
  _eq?: InputMaybe<SubscriptionTypesEnum>;
  _in?: InputMaybe<Array<SubscriptionTypesEnum>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<SubscriptionTypesEnum>;
  _nin?: InputMaybe<Array<SubscriptionTypesEnum>>;
};

/** input type for inserting data into table "subscription_types" */
export type SubscriptionTypesInsertInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type SubscriptionTypesMaxFields = {
  __typename?: 'SubscriptionTypesMaxFields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type SubscriptionTypesMinFields = {
  __typename?: 'SubscriptionTypesMinFields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "subscription_types" */
export type SubscriptionTypesMutationResponse = {
  __typename?: 'SubscriptionTypesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SubscriptionTypes>;
};

/** on_conflict condition type for table "subscription_types" */
export type SubscriptionTypesOnConflict = {
  constraint: SubscriptionTypesConstraint;
  updateColumns?: Array<SubscriptionTypesUpdateColumn>;
  where?: InputMaybe<SubscriptionTypesBoolExp>;
};

/** Ordering options when selecting data from "subscription_types". */
export type SubscriptionTypesOrderBy = {
  value?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: subscription_types */
export type SubscriptionTypesPkColumnsInput = {
  value: Scalars['String']['input'];
};

/** select columns of table "subscription_types" */
export enum SubscriptionTypesSelectColumn {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "subscription_types" */
export type SubscriptionTypesSetInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "subscription_types" */
export type SubscriptionTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SubscriptionTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SubscriptionTypesStreamCursorValueInput = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "subscription_types" */
export enum SubscriptionTypesUpdateColumn {
  /** column name */
  Value = 'value'
}

export type SubscriptionTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SubscriptionTypesSetInput>;
  /** filter the rows which have to be updated */
  where: SubscriptionTypesBoolExp;
};

/** [subtasks / to-do list] Remove - Documents previously had a to-do list tab. */
export type Suggestions = {
  __typename?: 'Suggestions';
  /** Content of the suggested subtask */
  content?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['timestamp']['output'];
  id: Scalars['bigint']['output'];
  reviewed: Scalars['Boolean']['output'];
  /** Transcription linked to suggestion */
  transcriptionId: Scalars['bigint']['output'];
  updatedAt: Scalars['timestamp']['output'];
};

/** aggregated selection of "suggestions" */
export type SuggestionsAggregate = {
  __typename?: 'SuggestionsAggregate';
  aggregate?: Maybe<SuggestionsAggregateFields>;
  nodes: Array<Suggestions>;
};

export type SuggestionsAggregateBoolExp = {
  bool_and?: InputMaybe<SuggestionsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<SuggestionsAggregateBoolExpBool_Or>;
  count?: InputMaybe<SuggestionsAggregateBoolExpCount>;
};

/** aggregate fields of "suggestions" */
export type SuggestionsAggregateFields = {
  __typename?: 'SuggestionsAggregateFields';
  avg?: Maybe<SuggestionsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<SuggestionsMaxFields>;
  min?: Maybe<SuggestionsMinFields>;
  stddev?: Maybe<SuggestionsStddevFields>;
  stddevPop?: Maybe<SuggestionsStddevPopFields>;
  stddevSamp?: Maybe<SuggestionsStddevSampFields>;
  sum?: Maybe<SuggestionsSumFields>;
  varPop?: Maybe<SuggestionsVarPopFields>;
  varSamp?: Maybe<SuggestionsVarSampFields>;
  variance?: Maybe<SuggestionsVarianceFields>;
};


/** aggregate fields of "suggestions" */
export type SuggestionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SuggestionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "suggestions" */
export type SuggestionsAggregateOrderBy = {
  avg?: InputMaybe<SuggestionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<SuggestionsMaxOrderBy>;
  min?: InputMaybe<SuggestionsMinOrderBy>;
  stddev?: InputMaybe<SuggestionsStddevOrderBy>;
  stddevPop?: InputMaybe<SuggestionsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<SuggestionsStddevSampOrderBy>;
  sum?: InputMaybe<SuggestionsSumOrderBy>;
  varPop?: InputMaybe<SuggestionsVarPopOrderBy>;
  varSamp?: InputMaybe<SuggestionsVarSampOrderBy>;
  variance?: InputMaybe<SuggestionsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "suggestions" */
export type SuggestionsArrRelInsertInput = {
  data: Array<SuggestionsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<SuggestionsOnConflict>;
};

/** aggregate avg on columns */
export type SuggestionsAvgFields = {
  __typename?: 'SuggestionsAvgFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Transcription linked to suggestion */
  transcriptionId?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "suggestions" */
export type SuggestionsAvgOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "suggestions". All fields are combined with a logical 'AND'. */
export type SuggestionsBoolExp = {
  _and?: InputMaybe<Array<SuggestionsBoolExp>>;
  _not?: InputMaybe<SuggestionsBoolExp>;
  _or?: InputMaybe<Array<SuggestionsBoolExp>>;
  content?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  reviewed?: InputMaybe<BooleanComparisonExp>;
  transcriptionId?: InputMaybe<BigintComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
};

/** unique or primary key constraints on table "suggestions" */
export enum SuggestionsConstraint {
  /** unique or primary key constraint on columns "id" */
  SuggestionsPkey = 'suggestions_pkey'
}

/** input type for incrementing numeric columns in table "suggestions" */
export type SuggestionsIncInput = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<Scalars['bigint']['input']>;
};

/** input type for inserting data into table "suggestions" */
export type SuggestionsInsertInput = {
  /** Content of the suggested subtask */
  content?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  reviewed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<Scalars['bigint']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate max on columns */
export type SuggestionsMaxFields = {
  __typename?: 'SuggestionsMaxFields';
  /** Content of the suggested subtask */
  content?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Transcription linked to suggestion */
  transcriptionId?: Maybe<Scalars['bigint']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by max() on columns of table "suggestions" */
export type SuggestionsMaxOrderBy = {
  /** Content of the suggested subtask */
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type SuggestionsMinFields = {
  __typename?: 'SuggestionsMinFields';
  /** Content of the suggested subtask */
  content?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Transcription linked to suggestion */
  transcriptionId?: Maybe<Scalars['bigint']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by min() on columns of table "suggestions" */
export type SuggestionsMinOrderBy = {
  /** Content of the suggested subtask */
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "suggestions" */
export type SuggestionsMutationResponse = {
  __typename?: 'SuggestionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Suggestions>;
};

/** on_conflict condition type for table "suggestions" */
export type SuggestionsOnConflict = {
  constraint: SuggestionsConstraint;
  updateColumns?: Array<SuggestionsUpdateColumn>;
  where?: InputMaybe<SuggestionsBoolExp>;
};

/** Ordering options when selecting data from "suggestions". */
export type SuggestionsOrderBy = {
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  reviewed?: InputMaybe<OrderBy>;
  transcriptionId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: suggestions */
export type SuggestionsPkColumnsInput = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "suggestions" */
export enum SuggestionsSelectColumn {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Reviewed = 'reviewed',
  /** column name */
  TranscriptionId = 'transcriptionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "suggestionsAggregateBoolExpBool_andArgumentsColumns" columns of table "suggestions" */
export enum SuggestionsSelectColumnSuggestionsAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  Reviewed = 'reviewed'
}

/** select "suggestionsAggregateBoolExpBool_orArgumentsColumns" columns of table "suggestions" */
export enum SuggestionsSelectColumnSuggestionsAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  Reviewed = 'reviewed'
}

/** input type for updating data in table "suggestions" */
export type SuggestionsSetInput = {
  /** Content of the suggested subtask */
  content?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  reviewed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<Scalars['bigint']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate stddev on columns */
export type SuggestionsStddevFields = {
  __typename?: 'SuggestionsStddevFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Transcription linked to suggestion */
  transcriptionId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "suggestions" */
export type SuggestionsStddevOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type SuggestionsStddevPopFields = {
  __typename?: 'SuggestionsStddevPopFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Transcription linked to suggestion */
  transcriptionId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "suggestions" */
export type SuggestionsStddevPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type SuggestionsStddevSampFields = {
  __typename?: 'SuggestionsStddevSampFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Transcription linked to suggestion */
  transcriptionId?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "suggestions" */
export type SuggestionsStddevSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "suggestions" */
export type SuggestionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SuggestionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SuggestionsStreamCursorValueInput = {
  /** Content of the suggested subtask */
  content?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  reviewed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<Scalars['bigint']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate sum on columns */
export type SuggestionsSumFields = {
  __typename?: 'SuggestionsSumFields';
  id?: Maybe<Scalars['bigint']['output']>;
  /** Transcription linked to suggestion */
  transcriptionId?: Maybe<Scalars['bigint']['output']>;
};

/** order by sum() on columns of table "suggestions" */
export type SuggestionsSumOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<OrderBy>;
};

/** update columns of table "suggestions" */
export enum SuggestionsUpdateColumn {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Reviewed = 'reviewed',
  /** column name */
  TranscriptionId = 'transcriptionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type SuggestionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<SuggestionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SuggestionsSetInput>;
  /** filter the rows which have to be updated */
  where: SuggestionsBoolExp;
};

/** aggregate varPop on columns */
export type SuggestionsVarPopFields = {
  __typename?: 'SuggestionsVarPopFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Transcription linked to suggestion */
  transcriptionId?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "suggestions" */
export type SuggestionsVarPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type SuggestionsVarSampFields = {
  __typename?: 'SuggestionsVarSampFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Transcription linked to suggestion */
  transcriptionId?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "suggestions" */
export type SuggestionsVarSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type SuggestionsVarianceFields = {
  __typename?: 'SuggestionsVarianceFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** Transcription linked to suggestion */
  transcriptionId?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "suggestions" */
export type SuggestionsVarianceOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** Transcription linked to suggestion */
  transcriptionId?: InputMaybe<OrderBy>;
};

/** [text docs] - part of new text documents feature */
export type TextItems = {
  __typename?: 'TextItems';
  accountId: Scalars['uuid']['output'];
  /** An object relationship */
  canvasItem?: Maybe<CanvasItems>;
  /** The parent canvas item */
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  createdAt: Scalars['timestamp']['output'];
  id: Scalars['uuid']['output'];
  processingStatus?: Maybe<Scalars['String']['output']>;
  textJson?: Maybe<Scalars['jsonb']['output']>;
  updatedAt: Scalars['timestamp']['output'];
  versionId: Scalars['uuid']['output'];
};


/** [text docs] - part of new text documents feature */
export type TextItemsTextJsonArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "text_items" */
export type TextItemsAggregate = {
  __typename?: 'TextItemsAggregate';
  aggregate?: Maybe<TextItemsAggregateFields>;
  nodes: Array<TextItems>;
};

/** aggregate fields of "text_items" */
export type TextItemsAggregateFields = {
  __typename?: 'TextItemsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<TextItemsMaxFields>;
  min?: Maybe<TextItemsMinFields>;
};


/** aggregate fields of "text_items" */
export type TextItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TextItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TextItemsAppendInput = {
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "text_items". All fields are combined with a logical 'AND'. */
export type TextItemsBoolExp = {
  _and?: InputMaybe<Array<TextItemsBoolExp>>;
  _not?: InputMaybe<TextItemsBoolExp>;
  _or?: InputMaybe<Array<TextItemsBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  canvasItem?: InputMaybe<CanvasItemsBoolExp>;
  canvasItemId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  processingStatus?: InputMaybe<StringComparisonExp>;
  textJson?: InputMaybe<JsonbComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  versionId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "text_items" */
export enum TextItemsConstraint {
  /** unique or primary key constraint on columns "canvas_item_id" */
  IndexTextItemsOnCanvasItemId = 'index_text_items_on_canvas_item_id',
  /** unique or primary key constraint on columns "id" */
  TextItemsPkey = 'text_items_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TextItemsDeleteAtPathInput = {
  textJson?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TextItemsDeleteElemInput = {
  textJson?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TextItemsDeleteKeyInput = {
  textJson?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "text_items" */
export type TextItemsInsertInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  canvasItem?: InputMaybe<CanvasItemsObjRelInsertInput>;
  /** The parent canvas item */
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  processingStatus?: InputMaybe<Scalars['String']['input']>;
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  versionId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TextItemsMaxFields = {
  __typename?: 'TextItemsMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** The parent canvas item */
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  processingStatus?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  versionId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type TextItemsMinFields = {
  __typename?: 'TextItemsMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** The parent canvas item */
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  processingStatus?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  versionId?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "text_items" */
export type TextItemsMutationResponse = {
  __typename?: 'TextItemsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<TextItems>;
};

/** input type for inserting object relation for remote table "text_items" */
export type TextItemsObjRelInsertInput = {
  data: TextItemsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<TextItemsOnConflict>;
};

/** on_conflict condition type for table "text_items" */
export type TextItemsOnConflict = {
  constraint: TextItemsConstraint;
  updateColumns?: Array<TextItemsUpdateColumn>;
  where?: InputMaybe<TextItemsBoolExp>;
};

/** Ordering options when selecting data from "text_items". */
export type TextItemsOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  canvasItem?: InputMaybe<CanvasItemsOrderBy>;
  canvasItemId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  textJson?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  versionId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: text_items */
export type TextItemsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TextItemsPrependInput = {
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "text_items" */
export enum TextItemsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CanvasItemId = 'canvasItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  ProcessingStatus = 'processingStatus',
  /** column name */
  TextJson = 'textJson',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VersionId = 'versionId'
}

/** input type for updating data in table "text_items" */
export type TextItemsSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** The parent canvas item */
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  processingStatus?: InputMaybe<Scalars['String']['input']>;
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  versionId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "text_items" */
export type TextItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: TextItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TextItemsStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** The parent canvas item */
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  processingStatus?: InputMaybe<Scalars['String']['input']>;
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  versionId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "text_items" */
export enum TextItemsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CanvasItemId = 'canvasItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  ProcessingStatus = 'processingStatus',
  /** column name */
  TextJson = 'textJson',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VersionId = 'versionId'
}

export type TextItemsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<TextItemsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<TextItemsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<TextItemsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<TextItemsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<TextItemsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TextItemsSetInput>;
  /** filter the rows which have to be updated */
  where: TextItemsBoolExp;
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type TimestampComparisonExp = {
  _eq?: InputMaybe<Scalars['timestamp']['input']>;
  _gt?: InputMaybe<Scalars['timestamp']['input']>;
  _gte?: InputMaybe<Scalars['timestamp']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamp']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamp']['input']>;
  _lte?: InputMaybe<Scalars['timestamp']['input']>;
  _neq?: InputMaybe<Scalars['timestamp']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamp']['input']>>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type TimestamptzComparisonExp = {
  _eq?: InputMaybe<Scalars['timestamptz']['input']>;
  _gt?: InputMaybe<Scalars['timestamptz']['input']>;
  _gte?: InputMaybe<Scalars['timestamptz']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamptz']['input']>;
  _lte?: InputMaybe<Scalars['timestamptz']['input']>;
  _neq?: InputMaybe<Scalars['timestamptz']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
};

/** Recordings are transcribed for easy reading and navigation */
export type Transcriptions = {
  __typename?: 'Transcriptions';
  /** Timestamped transcription content */
  content?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['timestamp']['output'];
  id: Scalars['bigint']['output'];
  /** Name of job in Amazon transcription service */
  jobName?: Maybe<Scalars['String']['output']>;
  /** status of job in Amazon transcription service */
  jobStatus?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  recording?: Maybe<Recordings>;
  /** recording this transcription relates to */
  recordingId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  suggestions: Array<Suggestions>;
  /** An aggregate relationship */
  suggestionsAggregate: SuggestionsAggregate;
  updatedAt: Scalars['timestamp']['output'];
};


/** Recordings are transcribed for easy reading and navigation */
export type TranscriptionsSuggestionsArgs = {
  distinctOn?: InputMaybe<Array<SuggestionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SuggestionsOrderBy>>;
  where?: InputMaybe<SuggestionsBoolExp>;
};


/** Recordings are transcribed for easy reading and navigation */
export type TranscriptionsSuggestionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SuggestionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SuggestionsOrderBy>>;
  where?: InputMaybe<SuggestionsBoolExp>;
};

/** aggregated selection of "transcriptions" */
export type TranscriptionsAggregate = {
  __typename?: 'TranscriptionsAggregate';
  aggregate?: Maybe<TranscriptionsAggregateFields>;
  nodes: Array<Transcriptions>;
};

export type TranscriptionsAggregateBoolExp = {
  count?: InputMaybe<TranscriptionsAggregateBoolExpCount>;
};

/** aggregate fields of "transcriptions" */
export type TranscriptionsAggregateFields = {
  __typename?: 'TranscriptionsAggregateFields';
  avg?: Maybe<TranscriptionsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<TranscriptionsMaxFields>;
  min?: Maybe<TranscriptionsMinFields>;
  stddev?: Maybe<TranscriptionsStddevFields>;
  stddevPop?: Maybe<TranscriptionsStddevPopFields>;
  stddevSamp?: Maybe<TranscriptionsStddevSampFields>;
  sum?: Maybe<TranscriptionsSumFields>;
  varPop?: Maybe<TranscriptionsVarPopFields>;
  varSamp?: Maybe<TranscriptionsVarSampFields>;
  variance?: Maybe<TranscriptionsVarianceFields>;
};


/** aggregate fields of "transcriptions" */
export type TranscriptionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TranscriptionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "transcriptions" */
export type TranscriptionsAggregateOrderBy = {
  avg?: InputMaybe<TranscriptionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<TranscriptionsMaxOrderBy>;
  min?: InputMaybe<TranscriptionsMinOrderBy>;
  stddev?: InputMaybe<TranscriptionsStddevOrderBy>;
  stddevPop?: InputMaybe<TranscriptionsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<TranscriptionsStddevSampOrderBy>;
  sum?: InputMaybe<TranscriptionsSumOrderBy>;
  varPop?: InputMaybe<TranscriptionsVarPopOrderBy>;
  varSamp?: InputMaybe<TranscriptionsVarSampOrderBy>;
  variance?: InputMaybe<TranscriptionsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "transcriptions" */
export type TranscriptionsArrRelInsertInput = {
  data: Array<TranscriptionsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<TranscriptionsOnConflict>;
};

/** aggregate avg on columns */
export type TranscriptionsAvgFields = {
  __typename?: 'TranscriptionsAvgFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** status of job in Amazon transcription service */
  jobStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "transcriptions" */
export type TranscriptionsAvgOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "transcriptions". All fields are combined with a logical 'AND'. */
export type TranscriptionsBoolExp = {
  _and?: InputMaybe<Array<TranscriptionsBoolExp>>;
  _not?: InputMaybe<TranscriptionsBoolExp>;
  _or?: InputMaybe<Array<TranscriptionsBoolExp>>;
  content?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<BigintComparisonExp>;
  jobName?: InputMaybe<StringComparisonExp>;
  jobStatus?: InputMaybe<IntComparisonExp>;
  recording?: InputMaybe<RecordingsBoolExp>;
  recordingId?: InputMaybe<UuidComparisonExp>;
  suggestions?: InputMaybe<SuggestionsBoolExp>;
  suggestionsAggregate?: InputMaybe<SuggestionsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
};

/** unique or primary key constraints on table "transcriptions" */
export enum TranscriptionsConstraint {
  /** unique or primary key constraint on columns "id" */
  TranscriptionsPkey = 'transcriptions_pkey'
}

/** input type for incrementing numeric columns in table "transcriptions" */
export type TranscriptionsIncInput = {
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "transcriptions" */
export type TranscriptionsInsertInput = {
  /** Timestamped transcription content */
  content?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Name of job in Amazon transcription service */
  jobName?: InputMaybe<Scalars['String']['input']>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<Scalars['Int']['input']>;
  recording?: InputMaybe<RecordingsObjRelInsertInput>;
  /** recording this transcription relates to */
  recordingId?: InputMaybe<Scalars['uuid']['input']>;
  suggestions?: InputMaybe<SuggestionsArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate max on columns */
export type TranscriptionsMaxFields = {
  __typename?: 'TranscriptionsMaxFields';
  /** Timestamped transcription content */
  content?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Name of job in Amazon transcription service */
  jobName?: Maybe<Scalars['String']['output']>;
  /** status of job in Amazon transcription service */
  jobStatus?: Maybe<Scalars['Int']['output']>;
  /** recording this transcription relates to */
  recordingId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by max() on columns of table "transcriptions" */
export type TranscriptionsMaxOrderBy = {
  /** Timestamped transcription content */
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** Name of job in Amazon transcription service */
  jobName?: InputMaybe<OrderBy>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<OrderBy>;
  /** recording this transcription relates to */
  recordingId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TranscriptionsMinFields = {
  __typename?: 'TranscriptionsMinFields';
  /** Timestamped transcription content */
  content?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  id?: Maybe<Scalars['bigint']['output']>;
  /** Name of job in Amazon transcription service */
  jobName?: Maybe<Scalars['String']['output']>;
  /** status of job in Amazon transcription service */
  jobStatus?: Maybe<Scalars['Int']['output']>;
  /** recording this transcription relates to */
  recordingId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** order by min() on columns of table "transcriptions" */
export type TranscriptionsMinOrderBy = {
  /** Timestamped transcription content */
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** Name of job in Amazon transcription service */
  jobName?: InputMaybe<OrderBy>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<OrderBy>;
  /** recording this transcription relates to */
  recordingId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "transcriptions" */
export type TranscriptionsMutationResponse = {
  __typename?: 'TranscriptionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Transcriptions>;
};

/** on_conflict condition type for table "transcriptions" */
export type TranscriptionsOnConflict = {
  constraint: TranscriptionsConstraint;
  updateColumns?: Array<TranscriptionsUpdateColumn>;
  where?: InputMaybe<TranscriptionsBoolExp>;
};

/** Ordering options when selecting data from "transcriptions". */
export type TranscriptionsOrderBy = {
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  jobName?: InputMaybe<OrderBy>;
  jobStatus?: InputMaybe<OrderBy>;
  recording?: InputMaybe<RecordingsOrderBy>;
  recordingId?: InputMaybe<OrderBy>;
  suggestionsAggregate?: InputMaybe<SuggestionsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: transcriptions */
export type TranscriptionsPkColumnsInput = {
  id: Scalars['bigint']['input'];
};

/** select columns of table "transcriptions" */
export enum TranscriptionsSelectColumn {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobName = 'jobName',
  /** column name */
  JobStatus = 'jobStatus',
  /** column name */
  RecordingId = 'recordingId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "transcriptions" */
export type TranscriptionsSetInput = {
  /** Timestamped transcription content */
  content?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Name of job in Amazon transcription service */
  jobName?: InputMaybe<Scalars['String']['input']>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<Scalars['Int']['input']>;
  /** recording this transcription relates to */
  recordingId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate stddev on columns */
export type TranscriptionsStddevFields = {
  __typename?: 'TranscriptionsStddevFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** status of job in Amazon transcription service */
  jobStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "transcriptions" */
export type TranscriptionsStddevOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type TranscriptionsStddevPopFields = {
  __typename?: 'TranscriptionsStddevPopFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** status of job in Amazon transcription service */
  jobStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "transcriptions" */
export type TranscriptionsStddevPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type TranscriptionsStddevSampFields = {
  __typename?: 'TranscriptionsStddevSampFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** status of job in Amazon transcription service */
  jobStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "transcriptions" */
export type TranscriptionsStddevSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "transcriptions" */
export type TranscriptionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: TranscriptionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TranscriptionsStreamCursorValueInput = {
  /** Timestamped transcription content */
  content?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  id?: InputMaybe<Scalars['bigint']['input']>;
  /** Name of job in Amazon transcription service */
  jobName?: InputMaybe<Scalars['String']['input']>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<Scalars['Int']['input']>;
  /** recording this transcription relates to */
  recordingId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate sum on columns */
export type TranscriptionsSumFields = {
  __typename?: 'TranscriptionsSumFields';
  id?: Maybe<Scalars['bigint']['output']>;
  /** status of job in Amazon transcription service */
  jobStatus?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "transcriptions" */
export type TranscriptionsSumOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<OrderBy>;
};

/** update columns of table "transcriptions" */
export enum TranscriptionsUpdateColumn {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobName = 'jobName',
  /** column name */
  JobStatus = 'jobStatus',
  /** column name */
  RecordingId = 'recordingId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type TranscriptionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TranscriptionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TranscriptionsSetInput>;
  /** filter the rows which have to be updated */
  where: TranscriptionsBoolExp;
};

/** aggregate varPop on columns */
export type TranscriptionsVarPopFields = {
  __typename?: 'TranscriptionsVarPopFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** status of job in Amazon transcription service */
  jobStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "transcriptions" */
export type TranscriptionsVarPopOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type TranscriptionsVarSampFields = {
  __typename?: 'TranscriptionsVarSampFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** status of job in Amazon transcription service */
  jobStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "transcriptions" */
export type TranscriptionsVarSampOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type TranscriptionsVarianceFields = {
  __typename?: 'TranscriptionsVarianceFields';
  id?: Maybe<Scalars['Float']['output']>;
  /** status of job in Amazon transcription service */
  jobStatus?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "transcriptions" */
export type TranscriptionsVarianceOrderBy = {
  id?: InputMaybe<OrderBy>;
  /** status of job in Amazon transcription service */
  jobStatus?: InputMaybe<OrderBy>;
};

/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type Users = {
  __typename?: 'Users';
  /** [analytics] was the user created from a share link? */
  accountCreatedFromShareLink?: Maybe<Scalars['Boolean']['output']>;
  /** An array relationship */
  accountUsers: Array<AccountUsers>;
  /** An aggregate relationship */
  accountUsersAggregate: AccountUsersAggregate;
  /** An array relationship */
  accountsAsOwner: Array<Accounts>;
  /** An aggregate relationship */
  accountsAsOwnerAggregate: AccountsAggregate;
  affiliateCode?: Maybe<Scalars['String']['output']>;
  /** [one-click sign in] */
  authenticationId?: Maybe<Scalars['String']['output']>;
  /** background colour for user avatar when no profile picture is present */
  color?: Maybe<Scalars['String']['output']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmationSentAt?: Maybe<Scalars['timestamp']['output']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmationToken?: Maybe<Scalars['String']['output']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmedAt?: Maybe<Scalars['timestamp']['output']>;
  createdAt: Scalars['timestamp']['output'];
  /** An object relationship */
  currentAccount?: Maybe<Accounts>;
  /** The account (workspace) that the user has most recently viewed */
  currentAccountId?: Maybe<Scalars['uuid']['output']>;
  /** [recordings] ID of the camera the user has selected */
  currentCamera?: Maybe<Scalars['String']['output']>;
  /** [recordings] ID of the microphone the user has selected */
  currentMic?: Maybe<Scalars['String']['output']>;
  /** route that the user was last viewing, so that they can be returned there on next login */
  currentRoute?: Maybe<Scalars['String']['output']>;
  /** [chat] remove - stored last route within the now unshipped messages app */
  currentRouteMessages?: Maybe<Scalars['String']['output']>;
  /** [storage] remove - stores the last route within the storage app */
  currentRouteStorage?: Maybe<Scalars['String']['output']>;
  /** [analytics] check if working and possible remove */
  currentSignInAt?: Maybe<Scalars['timestamp']['output']>;
  /** [analytics] check if working and possible remove */
  currentSignInIp?: Maybe<Scalars['String']['output']>;
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  documentUsers: Array<DocumentUsers>;
  /** An aggregate relationship */
  documentUsersAggregate: DocumentUsersAggregate;
  /** An array relationship */
  documentsAsAssignee: Array<Documents>;
  /** An aggregate relationship */
  documentsAsAssigneeAggregate: DocumentsAggregate;
  /** An array relationship */
  documentsAsAssigner: Array<Documents>;
  /** An aggregate relationship */
  documentsAsAssignerAggregate: DocumentsAggregate;
  /** An array relationship */
  documentsAsOwner: Array<Documents>;
  /** An aggregate relationship */
  documentsAsOwnerAggregate: DocumentsAggregate;
  email: Scalars['String']['output'];
  /** User is enrolled in our monthly product newsletter */
  emailOnProductUpdates: Scalars['Boolean']['output'];
  /** remove - previous user setting allowed users to specify a maximum of 1 email per day */
  emailedAt?: Maybe<Scalars['timestamp']['output']>;
  /** skin tone selected for emojis */
  emojiSkinTone?: Maybe<Scalars['String']['output']>;
  /** Has the user turned on browser-based / electron-app-based desktop notifications? */
  enableDesktopNotifications?: Maybe<Scalars['Boolean']['output']>;
  /** [notifications] - whether or not user has enabled email notifiations */
  enableEmailNotifications: Scalars['Boolean']['output'];
  /** [notifications] - whether or not user has enabled slack notifiations. While the account can connect or disconnect Slack overall, the user also has a setting to turn off Slack notifications if they don't want them. */
  enableSlackNotifications: Scalars['Boolean']['output'];
  encryptedPassword: Scalars['String']['output'];
  /** remove */
  feedbackEmailedAt?: Maybe<Scalars['timestamp']['output']>;
  /** Figma API auth state, used as a part of the OAuth2 flow */
  figmaApiAuthState?: Maybe<Scalars['String']['output']>;
  /** Figma API auth token, used for API access */
  figmaApiAuthToken?: Maybe<Scalars['String']['output']>;
  /** Figma API refresh token, used to get a new access token */
  figmaApiRefreshToken?: Maybe<Scalars['String']['output']>;
  /** Figma API token expiry time */
  figmaApiTokenExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  /** User's first name */
  firstName?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  guidedTour?: Maybe<GuidedTours>;
  /** [desktop app] tracks if user has the desktop app installed, both for analytics and as previously the UI pushed users to install the app if they did not have it */
  hasDesktopApp?: Maybe<Scalars['Boolean']['output']>;
  hasRunEnableApprovals: Scalars['Boolean']['output'];
  hideResolvedComments: Scalars['Boolean']['output'];
  id: Scalars['uuid']['output'];
  /** [sign up] - could remove, consolidating with user id. Used to in urls that invite users such as the project guest invite flow to look up the user */
  inviteToken: Scalars['uuid']['output'];
  invitedByAffiliateId?: Maybe<Scalars['uuid']['output']>;
  /** [analytics] - used to remove demo or internal users from analytics */
  isDemo: Scalars['Boolean']['output'];
  /** remove, unused */
  isSuperuser: Scalars['Boolean']['output'];
  /** View only users are temporary users created when a user views a shared asset, prior to them creating an account with an email */
  isViewOnly?: Maybe<Scalars['Boolean']['output']>;
  /** User's last name */
  lastName?: Maybe<Scalars['String']['output']>;
  /** [analytics] check if working and possible remove */
  lastSignInAt?: Maybe<Scalars['timestamp']['output']>;
  /** [analytics] check if working and possible remove */
  lastSignInIp?: Maybe<Scalars['String']['output']>;
  /** This stores the query params from the webflow homepage or our /sign-up page */
  marketingAttribution?: Maybe<Scalars['jsonb']['output']>;
  /** This stores a single string value that sums up the marketing source */
  marketingSource?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  messages: Array<Messages>;
  /** An aggregate relationship */
  messagesAggregate: MessagesAggregate;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount: Scalars['Int']['output'];
  /** An array relationship */
  notifications: Array<Notifications>;
  /** An aggregate relationship */
  notificationsAggregate: NotificationsAggregate;
  /** An array relationship */
  notificationsAsOriginator: Array<Notifications>;
  /** An aggregate relationship */
  notificationsAsOriginatorAggregate: NotificationsAggregate;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: Maybe<Scalars['float8']['output']>;
  /** [desktop app] has a banner been shown to offer the user the desktop app */
  offerDesktopApp: Scalars['Boolean']['output'];
  /** Has the user been shown a banner offering desktop notifications */
  offerDesktopNotifications: Scalars['Boolean']['output'];
  /** remove - previous ability for users to draw on canvas items */
  penColor: Scalars['String']['output'];
  /** remove - previous ability for users to draw on canvas items */
  penSize: Scalars['float8']['output'];
  /** Any error message while processing the user's profile photo */
  photoProcessingError?: Maybe<Scalars['String']['output']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus: Scalars['Int']['output'];
  /** [one-click sign in] url of photo provided by google, prior to adding to user */
  photoTemporary?: Maybe<Scalars['String']['output']>;
  /** URL pointing to the profile picture thumbnail */
  profilePictureThumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the asset URL expires */
  profilePictureThumbnailUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  /** URL pointing to the full resolution profile picture */
  profilePictureUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the asset URL expires */
  profilePictureUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  /** An array relationship */
  projectUsers: Array<ProjectUsers>;
  /** An aggregate relationship */
  projectUsersAggregate: ProjectUsersAggregate;
  /** [one-click sign in] email provider used (e.g. Google) */
  provider: Scalars['String']['output'];
  /** [sites] check and remove - part of old authentication flow for allowing users to make requests from within the proxy. May not be used now */
  proxyAuthCode?: Maybe<Scalars['String']['output']>;
  /** [sites] check and remove - part of old authentication flow for allowing users to make requests from within the proxy. May not be used now */
  proxyAuthCodeCreatedAt?: Maybe<Scalars['timestamp']['output']>;
  referralCodeUsed?: Maybe<Scalars['String']['output']>;
  referredByAccountId?: Maybe<Scalars['uuid']['output']>;
  /** remove - part of old remember-me checkbox */
  rememberCreatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** [analytics] - consolidate with is_demo, removes user from analytics */
  removeFromAnalytics?: Maybe<Scalars['Boolean']['output']>;
  resetPasswordSentAt?: Maybe<Scalars['timestamp']['output']>;
  resetPasswordToken?: Maybe<Scalars['String']['output']>;
  /** remove - unused */
  sentEmailSatisfactionSurvey: Scalars['Boolean']['output'];
  /** remove - previous payments system */
  sentEmailUpgradeToAnnual: Scalars['Boolean']['output'];
  /** [replicache] Set to true to remotely clear the replicache cache for a user */
  shouldRefreshReplicache?: Maybe<Scalars['Boolean']['output']>;
  /** rename from modal to page - whether or not the user has the sidepanel open on the document page */
  showDocumentModalPanel: Scalars['Boolean']['output'];
  /** Whether or not the user has the dashboard sidebar open, so that this setting can be remembered across sessions and devices */
  showSidebar: Scalars['Boolean']['output'];
  /** check and possibly remove - has user displayed or hidden text inputs */
  showTextToolbars: Scalars['Boolean']['output'];
  /** [analytics] check if working and possible remove */
  signInCount: Scalars['Int']['output'];
  /** [enum] which stage of the registration flow the user is at */
  status?: Maybe<Scalars['Int']['output']>;
  /** [one-click sign in] Google (or in other) user id */
  uid?: Maybe<Scalars['String']['output']>;
  /** stores proposed new email before the user has confirmed that email address */
  unconfirmedEmail?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['timestamp']['output'];
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersAccountUsersArgs = {
  distinctOn?: InputMaybe<Array<AccountUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountUsersOrderBy>>;
  where?: InputMaybe<AccountUsersBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersAccountUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountUsersOrderBy>>;
  where?: InputMaybe<AccountUsersBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersAccountsAsOwnerArgs = {
  distinctOn?: InputMaybe<Array<AccountsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  where?: InputMaybe<AccountsBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersAccountsAsOwnerAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  where?: InputMaybe<AccountsBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersDocumentUsersArgs = {
  distinctOn?: InputMaybe<Array<DocumentUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentUsersOrderBy>>;
  where?: InputMaybe<DocumentUsersBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersDocumentUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentUsersOrderBy>>;
  where?: InputMaybe<DocumentUsersBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersDocumentsAsAssigneeArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersDocumentsAsAssigneeAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersDocumentsAsAssignerArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersDocumentsAsAssignerAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersDocumentsAsOwnerArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersDocumentsAsOwnerAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersMarketingAttributionArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersMessagesArgs = {
  distinctOn?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersMessagesAggregateArgs = {
  distinctOn?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersNotificationsArgs = {
  distinctOn?: InputMaybe<Array<NotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
  where?: InputMaybe<NotificationsBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersNotificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<NotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
  where?: InputMaybe<NotificationsBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersNotificationsAsOriginatorArgs = {
  distinctOn?: InputMaybe<Array<NotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
  where?: InputMaybe<NotificationsBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersNotificationsAsOriginatorAggregateArgs = {
  distinctOn?: InputMaybe<Array<NotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
  where?: InputMaybe<NotificationsBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersProjectUsersArgs = {
  distinctOn?: InputMaybe<Array<ProjectUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
  where?: InputMaybe<ProjectUsersBoolExp>;
};


/** Individual login credentials and identity for a user One user can belong to multiple workspace */
export type UsersProjectUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<ProjectUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
  where?: InputMaybe<ProjectUsersBoolExp>;
};

/** aggregated selection of "users" */
export type UsersAggregate = {
  __typename?: 'UsersAggregate';
  aggregate?: Maybe<UsersAggregateFields>;
  nodes: Array<Users>;
};

/** aggregate fields of "users" */
export type UsersAggregateFields = {
  __typename?: 'UsersAggregateFields';
  avg?: Maybe<UsersAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<UsersMaxFields>;
  min?: Maybe<UsersMinFields>;
  stddev?: Maybe<UsersStddevFields>;
  stddevPop?: Maybe<UsersStddevPopFields>;
  stddevSamp?: Maybe<UsersStddevSampFields>;
  sum?: Maybe<UsersSumFields>;
  varPop?: Maybe<UsersVarPopFields>;
  varSamp?: Maybe<UsersVarSampFields>;
  variance?: Maybe<UsersVarianceFields>;
};


/** aggregate fields of "users" */
export type UsersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type UsersAppendInput = {
  /** This stores the query params from the webflow homepage or our /sign-up page */
  marketingAttribution?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type UsersAvgFields = {
  __typename?: 'UsersAvgFields';
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: Maybe<Scalars['Float']['output']>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: Maybe<Scalars['Float']['output']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: Maybe<Scalars['Float']['output']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** [analytics] check if working and possible remove */
  signInCount?: Maybe<Scalars['Float']['output']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'. */
export type UsersBoolExp = {
  _and?: InputMaybe<Array<UsersBoolExp>>;
  _not?: InputMaybe<UsersBoolExp>;
  _or?: InputMaybe<Array<UsersBoolExp>>;
  accountCreatedFromShareLink?: InputMaybe<BooleanComparisonExp>;
  accountUsers?: InputMaybe<AccountUsersBoolExp>;
  accountUsersAggregate?: InputMaybe<AccountUsersAggregateBoolExp>;
  accountsAsOwner?: InputMaybe<AccountsBoolExp>;
  accountsAsOwnerAggregate?: InputMaybe<AccountsAggregateBoolExp>;
  affiliateCode?: InputMaybe<StringComparisonExp>;
  authenticationId?: InputMaybe<StringComparisonExp>;
  color?: InputMaybe<StringComparisonExp>;
  confirmationSentAt?: InputMaybe<TimestampComparisonExp>;
  confirmationToken?: InputMaybe<StringComparisonExp>;
  confirmedAt?: InputMaybe<TimestampComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  currentAccount?: InputMaybe<AccountsBoolExp>;
  currentAccountId?: InputMaybe<UuidComparisonExp>;
  currentCamera?: InputMaybe<StringComparisonExp>;
  currentMic?: InputMaybe<StringComparisonExp>;
  currentRoute?: InputMaybe<StringComparisonExp>;
  currentRouteMessages?: InputMaybe<StringComparisonExp>;
  currentRouteStorage?: InputMaybe<StringComparisonExp>;
  currentSignInAt?: InputMaybe<TimestampComparisonExp>;
  currentSignInIp?: InputMaybe<StringComparisonExp>;
  currentVideoMode?: InputMaybe<IntComparisonExp>;
  documentUsers?: InputMaybe<DocumentUsersBoolExp>;
  documentUsersAggregate?: InputMaybe<DocumentUsersAggregateBoolExp>;
  documentsAsAssignee?: InputMaybe<DocumentsBoolExp>;
  documentsAsAssigneeAggregate?: InputMaybe<DocumentsAggregateBoolExp>;
  documentsAsAssigner?: InputMaybe<DocumentsBoolExp>;
  documentsAsAssignerAggregate?: InputMaybe<DocumentsAggregateBoolExp>;
  documentsAsOwner?: InputMaybe<DocumentsBoolExp>;
  documentsAsOwnerAggregate?: InputMaybe<DocumentsAggregateBoolExp>;
  email?: InputMaybe<StringComparisonExp>;
  emailOnProductUpdates?: InputMaybe<BooleanComparisonExp>;
  emailedAt?: InputMaybe<TimestampComparisonExp>;
  emojiSkinTone?: InputMaybe<StringComparisonExp>;
  enableDesktopNotifications?: InputMaybe<BooleanComparisonExp>;
  enableEmailNotifications?: InputMaybe<BooleanComparisonExp>;
  enableSlackNotifications?: InputMaybe<BooleanComparisonExp>;
  encryptedPassword?: InputMaybe<StringComparisonExp>;
  feedbackEmailedAt?: InputMaybe<TimestampComparisonExp>;
  figmaApiAuthState?: InputMaybe<StringComparisonExp>;
  figmaApiAuthToken?: InputMaybe<StringComparisonExp>;
  figmaApiRefreshToken?: InputMaybe<StringComparisonExp>;
  figmaApiTokenExpiresAt?: InputMaybe<TimestampComparisonExp>;
  firstName?: InputMaybe<StringComparisonExp>;
  guidedTour?: InputMaybe<GuidedToursBoolExp>;
  hasDesktopApp?: InputMaybe<BooleanComparisonExp>;
  hasRunEnableApprovals?: InputMaybe<BooleanComparisonExp>;
  hideResolvedComments?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  inviteToken?: InputMaybe<UuidComparisonExp>;
  invitedByAffiliateId?: InputMaybe<UuidComparisonExp>;
  isDemo?: InputMaybe<BooleanComparisonExp>;
  isSuperuser?: InputMaybe<BooleanComparisonExp>;
  isViewOnly?: InputMaybe<BooleanComparisonExp>;
  lastName?: InputMaybe<StringComparisonExp>;
  lastSignInAt?: InputMaybe<TimestampComparisonExp>;
  lastSignInIp?: InputMaybe<StringComparisonExp>;
  marketingAttribution?: InputMaybe<JsonbComparisonExp>;
  marketingSource?: InputMaybe<StringComparisonExp>;
  messages?: InputMaybe<MessagesBoolExp>;
  messagesAggregate?: InputMaybe<MessagesAggregateBoolExp>;
  notificationCount?: InputMaybe<IntComparisonExp>;
  notifications?: InputMaybe<NotificationsBoolExp>;
  notificationsAggregate?: InputMaybe<NotificationsAggregateBoolExp>;
  notificationsAsOriginator?: InputMaybe<NotificationsBoolExp>;
  notificationsAsOriginatorAggregate?: InputMaybe<NotificationsAggregateBoolExp>;
  notificationsDelayEmail?: InputMaybe<Float8ComparisonExp>;
  offerDesktopApp?: InputMaybe<BooleanComparisonExp>;
  offerDesktopNotifications?: InputMaybe<BooleanComparisonExp>;
  penColor?: InputMaybe<StringComparisonExp>;
  penSize?: InputMaybe<Float8ComparisonExp>;
  photoProcessingError?: InputMaybe<StringComparisonExp>;
  photoProcessingStatus?: InputMaybe<IntComparisonExp>;
  photoTemporary?: InputMaybe<StringComparisonExp>;
  profilePictureThumbnailUrl?: InputMaybe<StringComparisonExp>;
  profilePictureThumbnailUrlExpiresAt?: InputMaybe<TimestampComparisonExp>;
  profilePictureUrl?: InputMaybe<StringComparisonExp>;
  profilePictureUrlExpiresAt?: InputMaybe<TimestampComparisonExp>;
  projectUsers?: InputMaybe<ProjectUsersBoolExp>;
  projectUsersAggregate?: InputMaybe<ProjectUsersAggregateBoolExp>;
  provider?: InputMaybe<StringComparisonExp>;
  proxyAuthCode?: InputMaybe<StringComparisonExp>;
  proxyAuthCodeCreatedAt?: InputMaybe<TimestampComparisonExp>;
  referralCodeUsed?: InputMaybe<StringComparisonExp>;
  referredByAccountId?: InputMaybe<UuidComparisonExp>;
  rememberCreatedAt?: InputMaybe<TimestampComparisonExp>;
  removeFromAnalytics?: InputMaybe<BooleanComparisonExp>;
  resetPasswordSentAt?: InputMaybe<TimestampComparisonExp>;
  resetPasswordToken?: InputMaybe<StringComparisonExp>;
  sentEmailSatisfactionSurvey?: InputMaybe<BooleanComparisonExp>;
  sentEmailUpgradeToAnnual?: InputMaybe<BooleanComparisonExp>;
  shouldRefreshReplicache?: InputMaybe<BooleanComparisonExp>;
  showDocumentModalPanel?: InputMaybe<BooleanComparisonExp>;
  showSidebar?: InputMaybe<BooleanComparisonExp>;
  showTextToolbars?: InputMaybe<BooleanComparisonExp>;
  signInCount?: InputMaybe<IntComparisonExp>;
  status?: InputMaybe<IntComparisonExp>;
  uid?: InputMaybe<StringComparisonExp>;
  unconfirmedEmail?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
};

/** unique or primary key constraints on table "users" */
export enum UsersConstraint {
  /** unique or primary key constraint on columns "affiliate_code" */
  IndexUsersAffiliateCode = 'index_users_affiliate_code',
  /** unique or primary key constraint on columns "authentication_id" */
  IndexUsersOnAuthenticationId = 'index_users_on_authentication_id',
  /** unique or primary key constraint on columns "email" */
  IndexUsersOnEmail = 'index_users_on_email',
  /** unique or primary key constraint on columns "reset_password_token" */
  IndexUsersOnResetPasswordToken = 'index_users_on_reset_password_token',
  /** unique or primary key constraint on columns "uid" */
  IndexUsersOnUid = 'index_users_on_uid',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type UsersDeleteAtPathInput = {
  /** This stores the query params from the webflow homepage or our /sign-up page */
  marketingAttribution?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type UsersDeleteElemInput = {
  /** This stores the query params from the webflow homepage or our /sign-up page */
  marketingAttribution?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type UsersDeleteKeyInput = {
  /** This stores the query params from the webflow homepage or our /sign-up page */
  marketingAttribution?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "users" */
export type UsersIncInput = {
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: InputMaybe<Scalars['Int']['input']>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: InputMaybe<Scalars['Int']['input']>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: InputMaybe<Scalars['float8']['input']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: InputMaybe<Scalars['float8']['input']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [analytics] check if working and possible remove */
  signInCount?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "users" */
export type UsersInsertInput = {
  /** [analytics] was the user created from a share link? */
  accountCreatedFromShareLink?: InputMaybe<Scalars['Boolean']['input']>;
  accountUsers?: InputMaybe<AccountUsersArrRelInsertInput>;
  accountsAsOwner?: InputMaybe<AccountsArrRelInsertInput>;
  affiliateCode?: InputMaybe<Scalars['String']['input']>;
  /** [one-click sign in] */
  authenticationId?: InputMaybe<Scalars['String']['input']>;
  /** background colour for user avatar when no profile picture is present */
  color?: InputMaybe<Scalars['String']['input']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmationSentAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmationToken?: InputMaybe<Scalars['String']['input']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmedAt?: InputMaybe<Scalars['timestamp']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  currentAccount?: InputMaybe<AccountsObjRelInsertInput>;
  /** The account (workspace) that the user has most recently viewed */
  currentAccountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [recordings] ID of the camera the user has selected */
  currentCamera?: InputMaybe<Scalars['String']['input']>;
  /** [recordings] ID of the microphone the user has selected */
  currentMic?: InputMaybe<Scalars['String']['input']>;
  /** route that the user was last viewing, so that they can be returned there on next login */
  currentRoute?: InputMaybe<Scalars['String']['input']>;
  /** [chat] remove - stored last route within the now unshipped messages app */
  currentRouteMessages?: InputMaybe<Scalars['String']['input']>;
  /** [storage] remove - stores the last route within the storage app */
  currentRouteStorage?: InputMaybe<Scalars['String']['input']>;
  /** [analytics] check if working and possible remove */
  currentSignInAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [analytics] check if working and possible remove */
  currentSignInIp?: InputMaybe<Scalars['String']['input']>;
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: InputMaybe<Scalars['Int']['input']>;
  documentUsers?: InputMaybe<DocumentUsersArrRelInsertInput>;
  documentsAsAssignee?: InputMaybe<DocumentsArrRelInsertInput>;
  documentsAsAssigner?: InputMaybe<DocumentsArrRelInsertInput>;
  documentsAsOwner?: InputMaybe<DocumentsArrRelInsertInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  /** User is enrolled in our monthly product newsletter */
  emailOnProductUpdates?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove - previous user setting allowed users to specify a maximum of 1 email per day */
  emailedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** skin tone selected for emojis */
  emojiSkinTone?: InputMaybe<Scalars['String']['input']>;
  /** Has the user turned on browser-based / electron-app-based desktop notifications? */
  enableDesktopNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  /** [notifications] - whether or not user has enabled email notifiations */
  enableEmailNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  /** [notifications] - whether or not user has enabled slack notifiations. While the account can connect or disconnect Slack overall, the user also has a setting to turn off Slack notifications if they don't want them. */
  enableSlackNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  encryptedPassword?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  feedbackEmailedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Figma API auth state, used as a part of the OAuth2 flow */
  figmaApiAuthState?: InputMaybe<Scalars['String']['input']>;
  /** Figma API auth token, used for API access */
  figmaApiAuthToken?: InputMaybe<Scalars['String']['input']>;
  /** Figma API refresh token, used to get a new access token */
  figmaApiRefreshToken?: InputMaybe<Scalars['String']['input']>;
  /** Figma API token expiry time */
  figmaApiTokenExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** User's first name */
  firstName?: InputMaybe<Scalars['String']['input']>;
  guidedTour?: InputMaybe<GuidedToursObjRelInsertInput>;
  /** [desktop app] tracks if user has the desktop app installed, both for analytics and as previously the UI pushed users to install the app if they did not have it */
  hasDesktopApp?: InputMaybe<Scalars['Boolean']['input']>;
  hasRunEnableApprovals?: InputMaybe<Scalars['Boolean']['input']>;
  hideResolvedComments?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [sign up] - could remove, consolidating with user id. Used to in urls that invite users such as the project guest invite flow to look up the user */
  inviteToken?: InputMaybe<Scalars['uuid']['input']>;
  invitedByAffiliateId?: InputMaybe<Scalars['uuid']['input']>;
  /** [analytics] - used to remove demo or internal users from analytics */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove, unused */
  isSuperuser?: InputMaybe<Scalars['Boolean']['input']>;
  /** View only users are temporary users created when a user views a shared asset, prior to them creating an account with an email */
  isViewOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** User's last name */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** [analytics] check if working and possible remove */
  lastSignInAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [analytics] check if working and possible remove */
  lastSignInIp?: InputMaybe<Scalars['String']['input']>;
  /** This stores the query params from the webflow homepage or our /sign-up page */
  marketingAttribution?: InputMaybe<Scalars['jsonb']['input']>;
  /** This stores a single string value that sums up the marketing source */
  marketingSource?: InputMaybe<Scalars['String']['input']>;
  messages?: InputMaybe<MessagesArrRelInsertInput>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: InputMaybe<Scalars['Int']['input']>;
  notifications?: InputMaybe<NotificationsArrRelInsertInput>;
  notificationsAsOriginator?: InputMaybe<NotificationsArrRelInsertInput>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: InputMaybe<Scalars['float8']['input']>;
  /** [desktop app] has a banner been shown to offer the user the desktop app */
  offerDesktopApp?: InputMaybe<Scalars['Boolean']['input']>;
  /** Has the user been shown a banner offering desktop notifications */
  offerDesktopNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove - previous ability for users to draw on canvas items */
  penColor?: InputMaybe<Scalars['String']['input']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: InputMaybe<Scalars['float8']['input']>;
  /** Any error message while processing the user's profile photo */
  photoProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [one-click sign in] url of photo provided by google, prior to adding to user */
  photoTemporary?: InputMaybe<Scalars['String']['input']>;
  /** URL pointing to the profile picture thumbnail */
  profilePictureThumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the asset URL expires */
  profilePictureThumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** URL pointing to the full resolution profile picture */
  profilePictureUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the asset URL expires */
  profilePictureUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  projectUsers?: InputMaybe<ProjectUsersArrRelInsertInput>;
  /** [one-click sign in] email provider used (e.g. Google) */
  provider?: InputMaybe<Scalars['String']['input']>;
  /** [sites] check and remove - part of old authentication flow for allowing users to make requests from within the proxy. May not be used now */
  proxyAuthCode?: InputMaybe<Scalars['String']['input']>;
  /** [sites] check and remove - part of old authentication flow for allowing users to make requests from within the proxy. May not be used now */
  proxyAuthCodeCreatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  referralCodeUsed?: InputMaybe<Scalars['String']['input']>;
  referredByAccountId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove - part of old remember-me checkbox */
  rememberCreatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [analytics] - consolidate with is_demo, removes user from analytics */
  removeFromAnalytics?: InputMaybe<Scalars['Boolean']['input']>;
  resetPasswordSentAt?: InputMaybe<Scalars['timestamp']['input']>;
  resetPasswordToken?: InputMaybe<Scalars['String']['input']>;
  /** remove - unused */
  sentEmailSatisfactionSurvey?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove - previous payments system */
  sentEmailUpgradeToAnnual?: InputMaybe<Scalars['Boolean']['input']>;
  /** [replicache] Set to true to remotely clear the replicache cache for a user */
  shouldRefreshReplicache?: InputMaybe<Scalars['Boolean']['input']>;
  /** rename from modal to page - whether or not the user has the sidepanel open on the document page */
  showDocumentModalPanel?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not the user has the dashboard sidebar open, so that this setting can be remembered across sessions and devices */
  showSidebar?: InputMaybe<Scalars['Boolean']['input']>;
  /** check and possibly remove - has user displayed or hidden text inputs */
  showTextToolbars?: InputMaybe<Scalars['Boolean']['input']>;
  /** [analytics] check if working and possible remove */
  signInCount?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** [one-click sign in] Google (or in other) user id */
  uid?: InputMaybe<Scalars['String']['input']>;
  /** stores proposed new email before the user has confirmed that email address */
  unconfirmedEmail?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate max on columns */
export type UsersMaxFields = {
  __typename?: 'UsersMaxFields';
  affiliateCode?: Maybe<Scalars['String']['output']>;
  /** [one-click sign in] */
  authenticationId?: Maybe<Scalars['String']['output']>;
  /** background colour for user avatar when no profile picture is present */
  color?: Maybe<Scalars['String']['output']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmationSentAt?: Maybe<Scalars['timestamp']['output']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmationToken?: Maybe<Scalars['String']['output']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmedAt?: Maybe<Scalars['timestamp']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** The account (workspace) that the user has most recently viewed */
  currentAccountId?: Maybe<Scalars['uuid']['output']>;
  /** [recordings] ID of the camera the user has selected */
  currentCamera?: Maybe<Scalars['String']['output']>;
  /** [recordings] ID of the microphone the user has selected */
  currentMic?: Maybe<Scalars['String']['output']>;
  /** route that the user was last viewing, so that they can be returned there on next login */
  currentRoute?: Maybe<Scalars['String']['output']>;
  /** [chat] remove - stored last route within the now unshipped messages app */
  currentRouteMessages?: Maybe<Scalars['String']['output']>;
  /** [storage] remove - stores the last route within the storage app */
  currentRouteStorage?: Maybe<Scalars['String']['output']>;
  /** [analytics] check if working and possible remove */
  currentSignInAt?: Maybe<Scalars['timestamp']['output']>;
  /** [analytics] check if working and possible remove */
  currentSignInIp?: Maybe<Scalars['String']['output']>;
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: Maybe<Scalars['Int']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  /** remove - previous user setting allowed users to specify a maximum of 1 email per day */
  emailedAt?: Maybe<Scalars['timestamp']['output']>;
  /** skin tone selected for emojis */
  emojiSkinTone?: Maybe<Scalars['String']['output']>;
  encryptedPassword?: Maybe<Scalars['String']['output']>;
  /** remove */
  feedbackEmailedAt?: Maybe<Scalars['timestamp']['output']>;
  /** Figma API auth state, used as a part of the OAuth2 flow */
  figmaApiAuthState?: Maybe<Scalars['String']['output']>;
  /** Figma API auth token, used for API access */
  figmaApiAuthToken?: Maybe<Scalars['String']['output']>;
  /** Figma API refresh token, used to get a new access token */
  figmaApiRefreshToken?: Maybe<Scalars['String']['output']>;
  /** Figma API token expiry time */
  figmaApiTokenExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  /** User's first name */
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** [sign up] - could remove, consolidating with user id. Used to in urls that invite users such as the project guest invite flow to look up the user */
  inviteToken?: Maybe<Scalars['uuid']['output']>;
  invitedByAffiliateId?: Maybe<Scalars['uuid']['output']>;
  /** User's last name */
  lastName?: Maybe<Scalars['String']['output']>;
  /** [analytics] check if working and possible remove */
  lastSignInAt?: Maybe<Scalars['timestamp']['output']>;
  /** [analytics] check if working and possible remove */
  lastSignInIp?: Maybe<Scalars['String']['output']>;
  /** This stores a single string value that sums up the marketing source */
  marketingSource?: Maybe<Scalars['String']['output']>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: Maybe<Scalars['Int']['output']>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: Maybe<Scalars['float8']['output']>;
  /** remove - previous ability for users to draw on canvas items */
  penColor?: Maybe<Scalars['String']['output']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: Maybe<Scalars['float8']['output']>;
  /** Any error message while processing the user's profile photo */
  photoProcessingError?: Maybe<Scalars['String']['output']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** [one-click sign in] url of photo provided by google, prior to adding to user */
  photoTemporary?: Maybe<Scalars['String']['output']>;
  /** URL pointing to the profile picture thumbnail */
  profilePictureThumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the asset URL expires */
  profilePictureThumbnailUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  /** URL pointing to the full resolution profile picture */
  profilePictureUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the asset URL expires */
  profilePictureUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  /** [one-click sign in] email provider used (e.g. Google) */
  provider?: Maybe<Scalars['String']['output']>;
  /** [sites] check and remove - part of old authentication flow for allowing users to make requests from within the proxy. May not be used now */
  proxyAuthCode?: Maybe<Scalars['String']['output']>;
  /** [sites] check and remove - part of old authentication flow for allowing users to make requests from within the proxy. May not be used now */
  proxyAuthCodeCreatedAt?: Maybe<Scalars['timestamp']['output']>;
  referralCodeUsed?: Maybe<Scalars['String']['output']>;
  referredByAccountId?: Maybe<Scalars['uuid']['output']>;
  /** remove - part of old remember-me checkbox */
  rememberCreatedAt?: Maybe<Scalars['timestamp']['output']>;
  resetPasswordSentAt?: Maybe<Scalars['timestamp']['output']>;
  resetPasswordToken?: Maybe<Scalars['String']['output']>;
  /** [analytics] check if working and possible remove */
  signInCount?: Maybe<Scalars['Int']['output']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: Maybe<Scalars['Int']['output']>;
  /** [one-click sign in] Google (or in other) user id */
  uid?: Maybe<Scalars['String']['output']>;
  /** stores proposed new email before the user has confirmed that email address */
  unconfirmedEmail?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** aggregate min on columns */
export type UsersMinFields = {
  __typename?: 'UsersMinFields';
  affiliateCode?: Maybe<Scalars['String']['output']>;
  /** [one-click sign in] */
  authenticationId?: Maybe<Scalars['String']['output']>;
  /** background colour for user avatar when no profile picture is present */
  color?: Maybe<Scalars['String']['output']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmationSentAt?: Maybe<Scalars['timestamp']['output']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmationToken?: Maybe<Scalars['String']['output']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmedAt?: Maybe<Scalars['timestamp']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** The account (workspace) that the user has most recently viewed */
  currentAccountId?: Maybe<Scalars['uuid']['output']>;
  /** [recordings] ID of the camera the user has selected */
  currentCamera?: Maybe<Scalars['String']['output']>;
  /** [recordings] ID of the microphone the user has selected */
  currentMic?: Maybe<Scalars['String']['output']>;
  /** route that the user was last viewing, so that they can be returned there on next login */
  currentRoute?: Maybe<Scalars['String']['output']>;
  /** [chat] remove - stored last route within the now unshipped messages app */
  currentRouteMessages?: Maybe<Scalars['String']['output']>;
  /** [storage] remove - stores the last route within the storage app */
  currentRouteStorage?: Maybe<Scalars['String']['output']>;
  /** [analytics] check if working and possible remove */
  currentSignInAt?: Maybe<Scalars['timestamp']['output']>;
  /** [analytics] check if working and possible remove */
  currentSignInIp?: Maybe<Scalars['String']['output']>;
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: Maybe<Scalars['Int']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  /** remove - previous user setting allowed users to specify a maximum of 1 email per day */
  emailedAt?: Maybe<Scalars['timestamp']['output']>;
  /** skin tone selected for emojis */
  emojiSkinTone?: Maybe<Scalars['String']['output']>;
  encryptedPassword?: Maybe<Scalars['String']['output']>;
  /** remove */
  feedbackEmailedAt?: Maybe<Scalars['timestamp']['output']>;
  /** Figma API auth state, used as a part of the OAuth2 flow */
  figmaApiAuthState?: Maybe<Scalars['String']['output']>;
  /** Figma API auth token, used for API access */
  figmaApiAuthToken?: Maybe<Scalars['String']['output']>;
  /** Figma API refresh token, used to get a new access token */
  figmaApiRefreshToken?: Maybe<Scalars['String']['output']>;
  /** Figma API token expiry time */
  figmaApiTokenExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  /** User's first name */
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** [sign up] - could remove, consolidating with user id. Used to in urls that invite users such as the project guest invite flow to look up the user */
  inviteToken?: Maybe<Scalars['uuid']['output']>;
  invitedByAffiliateId?: Maybe<Scalars['uuid']['output']>;
  /** User's last name */
  lastName?: Maybe<Scalars['String']['output']>;
  /** [analytics] check if working and possible remove */
  lastSignInAt?: Maybe<Scalars['timestamp']['output']>;
  /** [analytics] check if working and possible remove */
  lastSignInIp?: Maybe<Scalars['String']['output']>;
  /** This stores a single string value that sums up the marketing source */
  marketingSource?: Maybe<Scalars['String']['output']>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: Maybe<Scalars['Int']['output']>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: Maybe<Scalars['float8']['output']>;
  /** remove - previous ability for users to draw on canvas items */
  penColor?: Maybe<Scalars['String']['output']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: Maybe<Scalars['float8']['output']>;
  /** Any error message while processing the user's profile photo */
  photoProcessingError?: Maybe<Scalars['String']['output']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** [one-click sign in] url of photo provided by google, prior to adding to user */
  photoTemporary?: Maybe<Scalars['String']['output']>;
  /** URL pointing to the profile picture thumbnail */
  profilePictureThumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the asset URL expires */
  profilePictureThumbnailUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  /** URL pointing to the full resolution profile picture */
  profilePictureUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the asset URL expires */
  profilePictureUrlExpiresAt?: Maybe<Scalars['timestamp']['output']>;
  /** [one-click sign in] email provider used (e.g. Google) */
  provider?: Maybe<Scalars['String']['output']>;
  /** [sites] check and remove - part of old authentication flow for allowing users to make requests from within the proxy. May not be used now */
  proxyAuthCode?: Maybe<Scalars['String']['output']>;
  /** [sites] check and remove - part of old authentication flow for allowing users to make requests from within the proxy. May not be used now */
  proxyAuthCodeCreatedAt?: Maybe<Scalars['timestamp']['output']>;
  referralCodeUsed?: Maybe<Scalars['String']['output']>;
  referredByAccountId?: Maybe<Scalars['uuid']['output']>;
  /** remove - part of old remember-me checkbox */
  rememberCreatedAt?: Maybe<Scalars['timestamp']['output']>;
  resetPasswordSentAt?: Maybe<Scalars['timestamp']['output']>;
  resetPasswordToken?: Maybe<Scalars['String']['output']>;
  /** [analytics] check if working and possible remove */
  signInCount?: Maybe<Scalars['Int']['output']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: Maybe<Scalars['Int']['output']>;
  /** [one-click sign in] Google (or in other) user id */
  uid?: Maybe<Scalars['String']['output']>;
  /** stores proposed new email before the user has confirmed that email address */
  unconfirmedEmail?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
};

/** response of any mutation on the table "users" */
export type UsersMutationResponse = {
  __typename?: 'UsersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "users" */
export type UsersObjRelInsertInput = {
  data: UsersInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<UsersOnConflict>;
};

/** on_conflict condition type for table "users" */
export type UsersOnConflict = {
  constraint: UsersConstraint;
  updateColumns?: Array<UsersUpdateColumn>;
  where?: InputMaybe<UsersBoolExp>;
};

/** Ordering options when selecting data from "users". */
export type UsersOrderBy = {
  accountCreatedFromShareLink?: InputMaybe<OrderBy>;
  accountUsersAggregate?: InputMaybe<AccountUsersAggregateOrderBy>;
  accountsAsOwnerAggregate?: InputMaybe<AccountsAggregateOrderBy>;
  affiliateCode?: InputMaybe<OrderBy>;
  authenticationId?: InputMaybe<OrderBy>;
  color?: InputMaybe<OrderBy>;
  confirmationSentAt?: InputMaybe<OrderBy>;
  confirmationToken?: InputMaybe<OrderBy>;
  confirmedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currentAccount?: InputMaybe<AccountsOrderBy>;
  currentAccountId?: InputMaybe<OrderBy>;
  currentCamera?: InputMaybe<OrderBy>;
  currentMic?: InputMaybe<OrderBy>;
  currentRoute?: InputMaybe<OrderBy>;
  currentRouteMessages?: InputMaybe<OrderBy>;
  currentRouteStorage?: InputMaybe<OrderBy>;
  currentSignInAt?: InputMaybe<OrderBy>;
  currentSignInIp?: InputMaybe<OrderBy>;
  currentVideoMode?: InputMaybe<OrderBy>;
  documentUsersAggregate?: InputMaybe<DocumentUsersAggregateOrderBy>;
  documentsAsAssigneeAggregate?: InputMaybe<DocumentsAggregateOrderBy>;
  documentsAsAssignerAggregate?: InputMaybe<DocumentsAggregateOrderBy>;
  documentsAsOwnerAggregate?: InputMaybe<DocumentsAggregateOrderBy>;
  email?: InputMaybe<OrderBy>;
  emailOnProductUpdates?: InputMaybe<OrderBy>;
  emailedAt?: InputMaybe<OrderBy>;
  emojiSkinTone?: InputMaybe<OrderBy>;
  enableDesktopNotifications?: InputMaybe<OrderBy>;
  enableEmailNotifications?: InputMaybe<OrderBy>;
  enableSlackNotifications?: InputMaybe<OrderBy>;
  encryptedPassword?: InputMaybe<OrderBy>;
  feedbackEmailedAt?: InputMaybe<OrderBy>;
  figmaApiAuthState?: InputMaybe<OrderBy>;
  figmaApiAuthToken?: InputMaybe<OrderBy>;
  figmaApiRefreshToken?: InputMaybe<OrderBy>;
  figmaApiTokenExpiresAt?: InputMaybe<OrderBy>;
  firstName?: InputMaybe<OrderBy>;
  guidedTour?: InputMaybe<GuidedToursOrderBy>;
  hasDesktopApp?: InputMaybe<OrderBy>;
  hasRunEnableApprovals?: InputMaybe<OrderBy>;
  hideResolvedComments?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  inviteToken?: InputMaybe<OrderBy>;
  invitedByAffiliateId?: InputMaybe<OrderBy>;
  isDemo?: InputMaybe<OrderBy>;
  isSuperuser?: InputMaybe<OrderBy>;
  isViewOnly?: InputMaybe<OrderBy>;
  lastName?: InputMaybe<OrderBy>;
  lastSignInAt?: InputMaybe<OrderBy>;
  lastSignInIp?: InputMaybe<OrderBy>;
  marketingAttribution?: InputMaybe<OrderBy>;
  marketingSource?: InputMaybe<OrderBy>;
  messagesAggregate?: InputMaybe<MessagesAggregateOrderBy>;
  notificationCount?: InputMaybe<OrderBy>;
  notificationsAggregate?: InputMaybe<NotificationsAggregateOrderBy>;
  notificationsAsOriginatorAggregate?: InputMaybe<NotificationsAggregateOrderBy>;
  notificationsDelayEmail?: InputMaybe<OrderBy>;
  offerDesktopApp?: InputMaybe<OrderBy>;
  offerDesktopNotifications?: InputMaybe<OrderBy>;
  penColor?: InputMaybe<OrderBy>;
  penSize?: InputMaybe<OrderBy>;
  photoProcessingError?: InputMaybe<OrderBy>;
  photoProcessingStatus?: InputMaybe<OrderBy>;
  photoTemporary?: InputMaybe<OrderBy>;
  profilePictureThumbnailUrl?: InputMaybe<OrderBy>;
  profilePictureThumbnailUrlExpiresAt?: InputMaybe<OrderBy>;
  profilePictureUrl?: InputMaybe<OrderBy>;
  profilePictureUrlExpiresAt?: InputMaybe<OrderBy>;
  projectUsersAggregate?: InputMaybe<ProjectUsersAggregateOrderBy>;
  provider?: InputMaybe<OrderBy>;
  proxyAuthCode?: InputMaybe<OrderBy>;
  proxyAuthCodeCreatedAt?: InputMaybe<OrderBy>;
  referralCodeUsed?: InputMaybe<OrderBy>;
  referredByAccountId?: InputMaybe<OrderBy>;
  rememberCreatedAt?: InputMaybe<OrderBy>;
  removeFromAnalytics?: InputMaybe<OrderBy>;
  resetPasswordSentAt?: InputMaybe<OrderBy>;
  resetPasswordToken?: InputMaybe<OrderBy>;
  sentEmailSatisfactionSurvey?: InputMaybe<OrderBy>;
  sentEmailUpgradeToAnnual?: InputMaybe<OrderBy>;
  shouldRefreshReplicache?: InputMaybe<OrderBy>;
  showDocumentModalPanel?: InputMaybe<OrderBy>;
  showSidebar?: InputMaybe<OrderBy>;
  showTextToolbars?: InputMaybe<OrderBy>;
  signInCount?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  uid?: InputMaybe<OrderBy>;
  unconfirmedEmail?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: users */
export type UsersPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type UsersPrependInput = {
  /** This stores the query params from the webflow homepage or our /sign-up page */
  marketingAttribution?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "users" */
export enum UsersSelectColumn {
  /** column name */
  AccountCreatedFromShareLink = 'accountCreatedFromShareLink',
  /** column name */
  AffiliateCode = 'affiliateCode',
  /** column name */
  AuthenticationId = 'authenticationId',
  /** column name */
  Color = 'color',
  /** column name */
  ConfirmationSentAt = 'confirmationSentAt',
  /** column name */
  ConfirmationToken = 'confirmationToken',
  /** column name */
  ConfirmedAt = 'confirmedAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CurrentAccountId = 'currentAccountId',
  /** column name */
  CurrentCamera = 'currentCamera',
  /** column name */
  CurrentMic = 'currentMic',
  /** column name */
  CurrentRoute = 'currentRoute',
  /** column name */
  CurrentRouteMessages = 'currentRouteMessages',
  /** column name */
  CurrentRouteStorage = 'currentRouteStorage',
  /** column name */
  CurrentSignInAt = 'currentSignInAt',
  /** column name */
  CurrentSignInIp = 'currentSignInIp',
  /** column name */
  CurrentVideoMode = 'currentVideoMode',
  /** column name */
  Email = 'email',
  /** column name */
  EmailOnProductUpdates = 'emailOnProductUpdates',
  /** column name */
  EmailedAt = 'emailedAt',
  /** column name */
  EmojiSkinTone = 'emojiSkinTone',
  /** column name */
  EnableDesktopNotifications = 'enableDesktopNotifications',
  /** column name */
  EnableEmailNotifications = 'enableEmailNotifications',
  /** column name */
  EnableSlackNotifications = 'enableSlackNotifications',
  /** column name */
  EncryptedPassword = 'encryptedPassword',
  /** column name */
  FeedbackEmailedAt = 'feedbackEmailedAt',
  /** column name */
  FigmaApiAuthState = 'figmaApiAuthState',
  /** column name */
  FigmaApiAuthToken = 'figmaApiAuthToken',
  /** column name */
  FigmaApiRefreshToken = 'figmaApiRefreshToken',
  /** column name */
  FigmaApiTokenExpiresAt = 'figmaApiTokenExpiresAt',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  HasDesktopApp = 'hasDesktopApp',
  /** column name */
  HasRunEnableApprovals = 'hasRunEnableApprovals',
  /** column name */
  HideResolvedComments = 'hideResolvedComments',
  /** column name */
  Id = 'id',
  /** column name */
  InviteToken = 'inviteToken',
  /** column name */
  InvitedByAffiliateId = 'invitedByAffiliateId',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  IsSuperuser = 'isSuperuser',
  /** column name */
  IsViewOnly = 'isViewOnly',
  /** column name */
  LastName = 'lastName',
  /** column name */
  LastSignInAt = 'lastSignInAt',
  /** column name */
  LastSignInIp = 'lastSignInIp',
  /** column name */
  MarketingAttribution = 'marketingAttribution',
  /** column name */
  MarketingSource = 'marketingSource',
  /** column name */
  NotificationCount = 'notificationCount',
  /** column name */
  NotificationsDelayEmail = 'notificationsDelayEmail',
  /** column name */
  OfferDesktopApp = 'offerDesktopApp',
  /** column name */
  OfferDesktopNotifications = 'offerDesktopNotifications',
  /** column name */
  PenColor = 'penColor',
  /** column name */
  PenSize = 'penSize',
  /** column name */
  PhotoProcessingError = 'photoProcessingError',
  /** column name */
  PhotoProcessingStatus = 'photoProcessingStatus',
  /** column name */
  PhotoTemporary = 'photoTemporary',
  /** column name */
  ProfilePictureThumbnailUrl = 'profilePictureThumbnailUrl',
  /** column name */
  ProfilePictureThumbnailUrlExpiresAt = 'profilePictureThumbnailUrlExpiresAt',
  /** column name */
  ProfilePictureUrl = 'profilePictureUrl',
  /** column name */
  ProfilePictureUrlExpiresAt = 'profilePictureUrlExpiresAt',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProxyAuthCode = 'proxyAuthCode',
  /** column name */
  ProxyAuthCodeCreatedAt = 'proxyAuthCodeCreatedAt',
  /** column name */
  ReferralCodeUsed = 'referralCodeUsed',
  /** column name */
  ReferredByAccountId = 'referredByAccountId',
  /** column name */
  RememberCreatedAt = 'rememberCreatedAt',
  /** column name */
  RemoveFromAnalytics = 'removeFromAnalytics',
  /** column name */
  ResetPasswordSentAt = 'resetPasswordSentAt',
  /** column name */
  ResetPasswordToken = 'resetPasswordToken',
  /** column name */
  SentEmailSatisfactionSurvey = 'sentEmailSatisfactionSurvey',
  /** column name */
  SentEmailUpgradeToAnnual = 'sentEmailUpgradeToAnnual',
  /** column name */
  ShouldRefreshReplicache = 'shouldRefreshReplicache',
  /** column name */
  ShowDocumentModalPanel = 'showDocumentModalPanel',
  /** column name */
  ShowSidebar = 'showSidebar',
  /** column name */
  ShowTextToolbars = 'showTextToolbars',
  /** column name */
  SignInCount = 'signInCount',
  /** column name */
  Status = 'status',
  /** column name */
  Uid = 'uid',
  /** column name */
  UnconfirmedEmail = 'unconfirmedEmail',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "users" */
export type UsersSetInput = {
  /** [analytics] was the user created from a share link? */
  accountCreatedFromShareLink?: InputMaybe<Scalars['Boolean']['input']>;
  affiliateCode?: InputMaybe<Scalars['String']['input']>;
  /** [one-click sign in] */
  authenticationId?: InputMaybe<Scalars['String']['input']>;
  /** background colour for user avatar when no profile picture is present */
  color?: InputMaybe<Scalars['String']['input']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmationSentAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmationToken?: InputMaybe<Scalars['String']['input']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmedAt?: InputMaybe<Scalars['timestamp']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The account (workspace) that the user has most recently viewed */
  currentAccountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [recordings] ID of the camera the user has selected */
  currentCamera?: InputMaybe<Scalars['String']['input']>;
  /** [recordings] ID of the microphone the user has selected */
  currentMic?: InputMaybe<Scalars['String']['input']>;
  /** route that the user was last viewing, so that they can be returned there on next login */
  currentRoute?: InputMaybe<Scalars['String']['input']>;
  /** [chat] remove - stored last route within the now unshipped messages app */
  currentRouteMessages?: InputMaybe<Scalars['String']['input']>;
  /** [storage] remove - stores the last route within the storage app */
  currentRouteStorage?: InputMaybe<Scalars['String']['input']>;
  /** [analytics] check if working and possible remove */
  currentSignInAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [analytics] check if working and possible remove */
  currentSignInIp?: InputMaybe<Scalars['String']['input']>;
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  /** User is enrolled in our monthly product newsletter */
  emailOnProductUpdates?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove - previous user setting allowed users to specify a maximum of 1 email per day */
  emailedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** skin tone selected for emojis */
  emojiSkinTone?: InputMaybe<Scalars['String']['input']>;
  /** Has the user turned on browser-based / electron-app-based desktop notifications? */
  enableDesktopNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  /** [notifications] - whether or not user has enabled email notifiations */
  enableEmailNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  /** [notifications] - whether or not user has enabled slack notifiations. While the account can connect or disconnect Slack overall, the user also has a setting to turn off Slack notifications if they don't want them. */
  enableSlackNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  encryptedPassword?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  feedbackEmailedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Figma API auth state, used as a part of the OAuth2 flow */
  figmaApiAuthState?: InputMaybe<Scalars['String']['input']>;
  /** Figma API auth token, used for API access */
  figmaApiAuthToken?: InputMaybe<Scalars['String']['input']>;
  /** Figma API refresh token, used to get a new access token */
  figmaApiRefreshToken?: InputMaybe<Scalars['String']['input']>;
  /** Figma API token expiry time */
  figmaApiTokenExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** User's first name */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** [desktop app] tracks if user has the desktop app installed, both for analytics and as previously the UI pushed users to install the app if they did not have it */
  hasDesktopApp?: InputMaybe<Scalars['Boolean']['input']>;
  hasRunEnableApprovals?: InputMaybe<Scalars['Boolean']['input']>;
  hideResolvedComments?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [sign up] - could remove, consolidating with user id. Used to in urls that invite users such as the project guest invite flow to look up the user */
  inviteToken?: InputMaybe<Scalars['uuid']['input']>;
  invitedByAffiliateId?: InputMaybe<Scalars['uuid']['input']>;
  /** [analytics] - used to remove demo or internal users from analytics */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove, unused */
  isSuperuser?: InputMaybe<Scalars['Boolean']['input']>;
  /** View only users are temporary users created when a user views a shared asset, prior to them creating an account with an email */
  isViewOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** User's last name */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** [analytics] check if working and possible remove */
  lastSignInAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [analytics] check if working and possible remove */
  lastSignInIp?: InputMaybe<Scalars['String']['input']>;
  /** This stores the query params from the webflow homepage or our /sign-up page */
  marketingAttribution?: InputMaybe<Scalars['jsonb']['input']>;
  /** This stores a single string value that sums up the marketing source */
  marketingSource?: InputMaybe<Scalars['String']['input']>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: InputMaybe<Scalars['Int']['input']>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: InputMaybe<Scalars['float8']['input']>;
  /** [desktop app] has a banner been shown to offer the user the desktop app */
  offerDesktopApp?: InputMaybe<Scalars['Boolean']['input']>;
  /** Has the user been shown a banner offering desktop notifications */
  offerDesktopNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove - previous ability for users to draw on canvas items */
  penColor?: InputMaybe<Scalars['String']['input']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: InputMaybe<Scalars['float8']['input']>;
  /** Any error message while processing the user's profile photo */
  photoProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [one-click sign in] url of photo provided by google, prior to adding to user */
  photoTemporary?: InputMaybe<Scalars['String']['input']>;
  /** URL pointing to the profile picture thumbnail */
  profilePictureThumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the asset URL expires */
  profilePictureThumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** URL pointing to the full resolution profile picture */
  profilePictureUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the asset URL expires */
  profilePictureUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [one-click sign in] email provider used (e.g. Google) */
  provider?: InputMaybe<Scalars['String']['input']>;
  /** [sites] check and remove - part of old authentication flow for allowing users to make requests from within the proxy. May not be used now */
  proxyAuthCode?: InputMaybe<Scalars['String']['input']>;
  /** [sites] check and remove - part of old authentication flow for allowing users to make requests from within the proxy. May not be used now */
  proxyAuthCodeCreatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  referralCodeUsed?: InputMaybe<Scalars['String']['input']>;
  referredByAccountId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove - part of old remember-me checkbox */
  rememberCreatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [analytics] - consolidate with is_demo, removes user from analytics */
  removeFromAnalytics?: InputMaybe<Scalars['Boolean']['input']>;
  resetPasswordSentAt?: InputMaybe<Scalars['timestamp']['input']>;
  resetPasswordToken?: InputMaybe<Scalars['String']['input']>;
  /** remove - unused */
  sentEmailSatisfactionSurvey?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove - previous payments system */
  sentEmailUpgradeToAnnual?: InputMaybe<Scalars['Boolean']['input']>;
  /** [replicache] Set to true to remotely clear the replicache cache for a user */
  shouldRefreshReplicache?: InputMaybe<Scalars['Boolean']['input']>;
  /** rename from modal to page - whether or not the user has the sidepanel open on the document page */
  showDocumentModalPanel?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not the user has the dashboard sidebar open, so that this setting can be remembered across sessions and devices */
  showSidebar?: InputMaybe<Scalars['Boolean']['input']>;
  /** check and possibly remove - has user displayed or hidden text inputs */
  showTextToolbars?: InputMaybe<Scalars['Boolean']['input']>;
  /** [analytics] check if working and possible remove */
  signInCount?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** [one-click sign in] Google (or in other) user id */
  uid?: InputMaybe<Scalars['String']['input']>;
  /** stores proposed new email before the user has confirmed that email address */
  unconfirmedEmail?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate stddev on columns */
export type UsersStddevFields = {
  __typename?: 'UsersStddevFields';
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: Maybe<Scalars['Float']['output']>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: Maybe<Scalars['Float']['output']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: Maybe<Scalars['Float']['output']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** [analytics] check if working and possible remove */
  signInCount?: Maybe<Scalars['Float']['output']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type UsersStddevPopFields = {
  __typename?: 'UsersStddevPopFields';
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: Maybe<Scalars['Float']['output']>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: Maybe<Scalars['Float']['output']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: Maybe<Scalars['Float']['output']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** [analytics] check if working and possible remove */
  signInCount?: Maybe<Scalars['Float']['output']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type UsersStddevSampFields = {
  __typename?: 'UsersStddevSampFields';
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: Maybe<Scalars['Float']['output']>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: Maybe<Scalars['Float']['output']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: Maybe<Scalars['Float']['output']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** [analytics] check if working and possible remove */
  signInCount?: Maybe<Scalars['Float']['output']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "users" */
export type UsersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UsersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UsersStreamCursorValueInput = {
  /** [analytics] was the user created from a share link? */
  accountCreatedFromShareLink?: InputMaybe<Scalars['Boolean']['input']>;
  affiliateCode?: InputMaybe<Scalars['String']['input']>;
  /** [one-click sign in] */
  authenticationId?: InputMaybe<Scalars['String']['input']>;
  /** background colour for user avatar when no profile picture is present */
  color?: InputMaybe<Scalars['String']['input']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmationSentAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmationToken?: InputMaybe<Scalars['String']['input']>;
  /** [confirm email] This feature is hidden but can be quickly turned on in the case of account creation abuse. */
  confirmedAt?: InputMaybe<Scalars['timestamp']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The account (workspace) that the user has most recently viewed */
  currentAccountId?: InputMaybe<Scalars['uuid']['input']>;
  /** [recordings] ID of the camera the user has selected */
  currentCamera?: InputMaybe<Scalars['String']['input']>;
  /** [recordings] ID of the microphone the user has selected */
  currentMic?: InputMaybe<Scalars['String']['input']>;
  /** route that the user was last viewing, so that they can be returned there on next login */
  currentRoute?: InputMaybe<Scalars['String']['input']>;
  /** [chat] remove - stored last route within the now unshipped messages app */
  currentRouteMessages?: InputMaybe<Scalars['String']['input']>;
  /** [storage] remove - stores the last route within the storage app */
  currentRouteStorage?: InputMaybe<Scalars['String']['input']>;
  /** [analytics] check if working and possible remove */
  currentSignInAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [analytics] check if working and possible remove */
  currentSignInIp?: InputMaybe<Scalars['String']['input']>;
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: InputMaybe<Scalars['Int']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  /** User is enrolled in our monthly product newsletter */
  emailOnProductUpdates?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove - previous user setting allowed users to specify a maximum of 1 email per day */
  emailedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** skin tone selected for emojis */
  emojiSkinTone?: InputMaybe<Scalars['String']['input']>;
  /** Has the user turned on browser-based / electron-app-based desktop notifications? */
  enableDesktopNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  /** [notifications] - whether or not user has enabled email notifiations */
  enableEmailNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  /** [notifications] - whether or not user has enabled slack notifiations. While the account can connect or disconnect Slack overall, the user also has a setting to turn off Slack notifications if they don't want them. */
  enableSlackNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  encryptedPassword?: InputMaybe<Scalars['String']['input']>;
  /** remove */
  feedbackEmailedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Figma API auth state, used as a part of the OAuth2 flow */
  figmaApiAuthState?: InputMaybe<Scalars['String']['input']>;
  /** Figma API auth token, used for API access */
  figmaApiAuthToken?: InputMaybe<Scalars['String']['input']>;
  /** Figma API refresh token, used to get a new access token */
  figmaApiRefreshToken?: InputMaybe<Scalars['String']['input']>;
  /** Figma API token expiry time */
  figmaApiTokenExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** User's first name */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** [desktop app] tracks if user has the desktop app installed, both for analytics and as previously the UI pushed users to install the app if they did not have it */
  hasDesktopApp?: InputMaybe<Scalars['Boolean']['input']>;
  hasRunEnableApprovals?: InputMaybe<Scalars['Boolean']['input']>;
  hideResolvedComments?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [sign up] - could remove, consolidating with user id. Used to in urls that invite users such as the project guest invite flow to look up the user */
  inviteToken?: InputMaybe<Scalars['uuid']['input']>;
  invitedByAffiliateId?: InputMaybe<Scalars['uuid']['input']>;
  /** [analytics] - used to remove demo or internal users from analytics */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove, unused */
  isSuperuser?: InputMaybe<Scalars['Boolean']['input']>;
  /** View only users are temporary users created when a user views a shared asset, prior to them creating an account with an email */
  isViewOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** User's last name */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** [analytics] check if working and possible remove */
  lastSignInAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [analytics] check if working and possible remove */
  lastSignInIp?: InputMaybe<Scalars['String']['input']>;
  /** This stores the query params from the webflow homepage or our /sign-up page */
  marketingAttribution?: InputMaybe<Scalars['jsonb']['input']>;
  /** This stores a single string value that sums up the marketing source */
  marketingSource?: InputMaybe<Scalars['String']['input']>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: InputMaybe<Scalars['Int']['input']>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: InputMaybe<Scalars['float8']['input']>;
  /** [desktop app] has a banner been shown to offer the user the desktop app */
  offerDesktopApp?: InputMaybe<Scalars['Boolean']['input']>;
  /** Has the user been shown a banner offering desktop notifications */
  offerDesktopNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove - previous ability for users to draw on canvas items */
  penColor?: InputMaybe<Scalars['String']['input']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: InputMaybe<Scalars['float8']['input']>;
  /** Any error message while processing the user's profile photo */
  photoProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [one-click sign in] url of photo provided by google, prior to adding to user */
  photoTemporary?: InputMaybe<Scalars['String']['input']>;
  /** URL pointing to the profile picture thumbnail */
  profilePictureThumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the asset URL expires */
  profilePictureThumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** URL pointing to the full resolution profile picture */
  profilePictureUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the asset URL expires */
  profilePictureUrlExpiresAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [one-click sign in] email provider used (e.g. Google) */
  provider?: InputMaybe<Scalars['String']['input']>;
  /** [sites] check and remove - part of old authentication flow for allowing users to make requests from within the proxy. May not be used now */
  proxyAuthCode?: InputMaybe<Scalars['String']['input']>;
  /** [sites] check and remove - part of old authentication flow for allowing users to make requests from within the proxy. May not be used now */
  proxyAuthCodeCreatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  referralCodeUsed?: InputMaybe<Scalars['String']['input']>;
  referredByAccountId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove - part of old remember-me checkbox */
  rememberCreatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** [analytics] - consolidate with is_demo, removes user from analytics */
  removeFromAnalytics?: InputMaybe<Scalars['Boolean']['input']>;
  resetPasswordSentAt?: InputMaybe<Scalars['timestamp']['input']>;
  resetPasswordToken?: InputMaybe<Scalars['String']['input']>;
  /** remove - unused */
  sentEmailSatisfactionSurvey?: InputMaybe<Scalars['Boolean']['input']>;
  /** remove - previous payments system */
  sentEmailUpgradeToAnnual?: InputMaybe<Scalars['Boolean']['input']>;
  /** [replicache] Set to true to remotely clear the replicache cache for a user */
  shouldRefreshReplicache?: InputMaybe<Scalars['Boolean']['input']>;
  /** rename from modal to page - whether or not the user has the sidepanel open on the document page */
  showDocumentModalPanel?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not the user has the dashboard sidebar open, so that this setting can be remembered across sessions and devices */
  showSidebar?: InputMaybe<Scalars['Boolean']['input']>;
  /** check and possibly remove - has user displayed or hidden text inputs */
  showTextToolbars?: InputMaybe<Scalars['Boolean']['input']>;
  /** [analytics] check if working and possible remove */
  signInCount?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** [one-click sign in] Google (or in other) user id */
  uid?: InputMaybe<Scalars['String']['input']>;
  /** stores proposed new email before the user has confirmed that email address */
  unconfirmedEmail?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate sum on columns */
export type UsersSumFields = {
  __typename?: 'UsersSumFields';
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: Maybe<Scalars['Int']['output']>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: Maybe<Scalars['Int']['output']>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: Maybe<Scalars['float8']['output']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: Maybe<Scalars['float8']['output']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** [analytics] check if working and possible remove */
  signInCount?: Maybe<Scalars['Int']['output']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "users" */
export enum UsersUpdateColumn {
  /** column name */
  AccountCreatedFromShareLink = 'accountCreatedFromShareLink',
  /** column name */
  AffiliateCode = 'affiliateCode',
  /** column name */
  AuthenticationId = 'authenticationId',
  /** column name */
  Color = 'color',
  /** column name */
  ConfirmationSentAt = 'confirmationSentAt',
  /** column name */
  ConfirmationToken = 'confirmationToken',
  /** column name */
  ConfirmedAt = 'confirmedAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CurrentAccountId = 'currentAccountId',
  /** column name */
  CurrentCamera = 'currentCamera',
  /** column name */
  CurrentMic = 'currentMic',
  /** column name */
  CurrentRoute = 'currentRoute',
  /** column name */
  CurrentRouteMessages = 'currentRouteMessages',
  /** column name */
  CurrentRouteStorage = 'currentRouteStorage',
  /** column name */
  CurrentSignInAt = 'currentSignInAt',
  /** column name */
  CurrentSignInIp = 'currentSignInIp',
  /** column name */
  CurrentVideoMode = 'currentVideoMode',
  /** column name */
  Email = 'email',
  /** column name */
  EmailOnProductUpdates = 'emailOnProductUpdates',
  /** column name */
  EmailedAt = 'emailedAt',
  /** column name */
  EmojiSkinTone = 'emojiSkinTone',
  /** column name */
  EnableDesktopNotifications = 'enableDesktopNotifications',
  /** column name */
  EnableEmailNotifications = 'enableEmailNotifications',
  /** column name */
  EnableSlackNotifications = 'enableSlackNotifications',
  /** column name */
  EncryptedPassword = 'encryptedPassword',
  /** column name */
  FeedbackEmailedAt = 'feedbackEmailedAt',
  /** column name */
  FigmaApiAuthState = 'figmaApiAuthState',
  /** column name */
  FigmaApiAuthToken = 'figmaApiAuthToken',
  /** column name */
  FigmaApiRefreshToken = 'figmaApiRefreshToken',
  /** column name */
  FigmaApiTokenExpiresAt = 'figmaApiTokenExpiresAt',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  HasDesktopApp = 'hasDesktopApp',
  /** column name */
  HasRunEnableApprovals = 'hasRunEnableApprovals',
  /** column name */
  HideResolvedComments = 'hideResolvedComments',
  /** column name */
  Id = 'id',
  /** column name */
  InviteToken = 'inviteToken',
  /** column name */
  InvitedByAffiliateId = 'invitedByAffiliateId',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  IsSuperuser = 'isSuperuser',
  /** column name */
  IsViewOnly = 'isViewOnly',
  /** column name */
  LastName = 'lastName',
  /** column name */
  LastSignInAt = 'lastSignInAt',
  /** column name */
  LastSignInIp = 'lastSignInIp',
  /** column name */
  MarketingAttribution = 'marketingAttribution',
  /** column name */
  MarketingSource = 'marketingSource',
  /** column name */
  NotificationCount = 'notificationCount',
  /** column name */
  NotificationsDelayEmail = 'notificationsDelayEmail',
  /** column name */
  OfferDesktopApp = 'offerDesktopApp',
  /** column name */
  OfferDesktopNotifications = 'offerDesktopNotifications',
  /** column name */
  PenColor = 'penColor',
  /** column name */
  PenSize = 'penSize',
  /** column name */
  PhotoProcessingError = 'photoProcessingError',
  /** column name */
  PhotoProcessingStatus = 'photoProcessingStatus',
  /** column name */
  PhotoTemporary = 'photoTemporary',
  /** column name */
  ProfilePictureThumbnailUrl = 'profilePictureThumbnailUrl',
  /** column name */
  ProfilePictureThumbnailUrlExpiresAt = 'profilePictureThumbnailUrlExpiresAt',
  /** column name */
  ProfilePictureUrl = 'profilePictureUrl',
  /** column name */
  ProfilePictureUrlExpiresAt = 'profilePictureUrlExpiresAt',
  /** column name */
  Provider = 'provider',
  /** column name */
  ProxyAuthCode = 'proxyAuthCode',
  /** column name */
  ProxyAuthCodeCreatedAt = 'proxyAuthCodeCreatedAt',
  /** column name */
  ReferralCodeUsed = 'referralCodeUsed',
  /** column name */
  ReferredByAccountId = 'referredByAccountId',
  /** column name */
  RememberCreatedAt = 'rememberCreatedAt',
  /** column name */
  RemoveFromAnalytics = 'removeFromAnalytics',
  /** column name */
  ResetPasswordSentAt = 'resetPasswordSentAt',
  /** column name */
  ResetPasswordToken = 'resetPasswordToken',
  /** column name */
  SentEmailSatisfactionSurvey = 'sentEmailSatisfactionSurvey',
  /** column name */
  SentEmailUpgradeToAnnual = 'sentEmailUpgradeToAnnual',
  /** column name */
  ShouldRefreshReplicache = 'shouldRefreshReplicache',
  /** column name */
  ShowDocumentModalPanel = 'showDocumentModalPanel',
  /** column name */
  ShowSidebar = 'showSidebar',
  /** column name */
  ShowTextToolbars = 'showTextToolbars',
  /** column name */
  SignInCount = 'signInCount',
  /** column name */
  Status = 'status',
  /** column name */
  Uid = 'uid',
  /** column name */
  UnconfirmedEmail = 'unconfirmedEmail',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type UsersUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<UsersAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<UsersDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<UsersDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<UsersDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UsersIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<UsersPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UsersSetInput>;
  /** filter the rows which have to be updated */
  where: UsersBoolExp;
};

/** aggregate varPop on columns */
export type UsersVarPopFields = {
  __typename?: 'UsersVarPopFields';
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: Maybe<Scalars['Float']['output']>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: Maybe<Scalars['Float']['output']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: Maybe<Scalars['Float']['output']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** [analytics] check if working and possible remove */
  signInCount?: Maybe<Scalars['Float']['output']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type UsersVarSampFields = {
  __typename?: 'UsersVarSampFields';
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: Maybe<Scalars['Float']['output']>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: Maybe<Scalars['Float']['output']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: Maybe<Scalars['Float']['output']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** [analytics] check if working and possible remove */
  signInCount?: Maybe<Scalars['Float']['output']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type UsersVarianceFields = {
  __typename?: 'UsersVarianceFields';
  /** [enum] whether a user has their camera enabled or not for recordings */
  currentVideoMode?: Maybe<Scalars['Float']['output']>;
  /** check and possibly remove - a cache of how many outstanding notifications are present */
  notificationCount?: Maybe<Scalars['Float']['output']>;
  /** Delay in minutes for sending email notifications as a batch */
  notificationsDelayEmail?: Maybe<Scalars['Float']['output']>;
  /** remove - previous ability for users to draw on canvas items */
  penSize?: Maybe<Scalars['Float']['output']>;
  /** Status of processing the user's profile photo */
  photoProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** [analytics] check if working and possible remove */
  signInCount?: Maybe<Scalars['Float']['output']>;
  /** [enum] which stage of the registration flow the user is at */
  status?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type UuidComparisonExp = {
  _eq?: InputMaybe<Scalars['uuid']['input']>;
  _gt?: InputMaybe<Scalars['uuid']['input']>;
  _gte?: InputMaybe<Scalars['uuid']['input']>;
  _in?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['uuid']['input']>;
  _lte?: InputMaybe<Scalars['uuid']['input']>;
  _neq?: InputMaybe<Scalars['uuid']['input']>;
  _nin?: InputMaybe<Array<Scalars['uuid']['input']>>;
};

/** Each document (task) may have zero or more versions, which are individual or collections of creative assets */
export type Versions = {
  __typename?: 'Versions';
  /** Account that the version belongs to */
  accountId: Scalars['uuid']['output'];
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewError?: Maybe<Scalars['String']['output']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewId?: Maybe<Scalars['uuid']['output']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  canvasItems: Array<CanvasItems>;
  /** An aggregate relationship */
  canvasItemsAggregate: CanvasItemsAggregate;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: Maybe<Scalars['Int']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  /** Allows user to add a name for this version, e.g. Prototype */
  customName?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  document: Documents;
  /** Document that the version is on */
  documentId: Scalars['uuid']['output'];
  /** [figma sync] refactor needed into separate table - stores the JSON representation of the figma file that the user uploaded via the Figma plugin, allowing comments to be added onto specific frames in Figma even if the frames has been moved. Refactor needed as this JSON object can potentially be huge, causing the version to need to load a lot of data into memory in ruby when loaded. */
  figmaJsonRepresentation?: Maybe<Scalars['jsonb']['output']>;
  /** Rename - any external URL relating to this asset. Used for both figma files and sites. */
  figmaLink?: Maybe<Scalars['String']['output']>;
  /** The Figma page that the message is on has an ID */
  figmaPageId?: Maybe<Scalars['String']['output']>;
  /** check and remove - previously if the first file for a version was an image, we would be able to temporarily instantly show a thumbnail for a new task without waiting for thumbnail processing to finish by simply displaying the asset itself. */
  firstFileIsImage: Scalars['Boolean']['output'];
  id: Scalars['uuid']['output'];
  /** [analytics] remove demo content from analytics */
  isDemo: Scalars['Boolean']['output'];
  /** An array relationship */
  items: Array<Items>;
  /** An aggregate relationship */
  itemsAggregate: ItemsAggregate;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion: Scalars['Int']['output'];
  /** Optimistic locking for concurrent processing. */
  lockVersion: Scalars['Int']['output'];
  /** An array relationship */
  messages: Array<Messages>;
  /** An aggregate relationship */
  messagesAggregate: MessagesAggregate;
  /** check and remove - slug used by urls for lookups */
  slug?: Maybe<Scalars['String']['output']>;
  /** check and remove */
  textJson?: Maybe<Scalars['jsonb']['output']>;
  /** [DEPRECATED] Any processing error for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus: Scalars['Int']['output'];
  /** [DEPRECATED] */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** [DEPRECATED] */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
  /** User who created the version */
  userId: Scalars['uuid']['output'];
  /** Version number displayed to users */
  versionNumber: Scalars['Int']['output'];
};


/** Each document (task) may have zero or more versions, which are individual or collections of creative assets */
export type VersionsCanvasItemsArgs = {
  distinctOn?: InputMaybe<Array<CanvasItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CanvasItemsOrderBy>>;
  where?: InputMaybe<CanvasItemsBoolExp>;
};


/** Each document (task) may have zero or more versions, which are individual or collections of creative assets */
export type VersionsCanvasItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CanvasItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CanvasItemsOrderBy>>;
  where?: InputMaybe<CanvasItemsBoolExp>;
};


/** Each document (task) may have zero or more versions, which are individual or collections of creative assets */
export type VersionsFigmaJsonRepresentationArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Each document (task) may have zero or more versions, which are individual or collections of creative assets */
export type VersionsItemsArgs = {
  distinctOn?: InputMaybe<Array<ItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ItemsOrderBy>>;
  where?: InputMaybe<ItemsBoolExp>;
};


/** Each document (task) may have zero or more versions, which are individual or collections of creative assets */
export type VersionsItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ItemsOrderBy>>;
  where?: InputMaybe<ItemsBoolExp>;
};


/** Each document (task) may have zero or more versions, which are individual or collections of creative assets */
export type VersionsMessagesArgs = {
  distinctOn?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


/** Each document (task) may have zero or more versions, which are individual or collections of creative assets */
export type VersionsMessagesAggregateArgs = {
  distinctOn?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


/** Each document (task) may have zero or more versions, which are individual or collections of creative assets */
export type VersionsTextJsonArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "versions" */
export type VersionsAggregate = {
  __typename?: 'VersionsAggregate';
  aggregate?: Maybe<VersionsAggregateFields>;
  nodes: Array<Versions>;
};

export type VersionsAggregateBoolExp = {
  bool_and?: InputMaybe<VersionsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<VersionsAggregateBoolExpBool_Or>;
  count?: InputMaybe<VersionsAggregateBoolExpCount>;
};

/** aggregate fields of "versions" */
export type VersionsAggregateFields = {
  __typename?: 'VersionsAggregateFields';
  avg?: Maybe<VersionsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<VersionsMaxFields>;
  min?: Maybe<VersionsMinFields>;
  stddev?: Maybe<VersionsStddevFields>;
  stddevPop?: Maybe<VersionsStddevPopFields>;
  stddevSamp?: Maybe<VersionsStddevSampFields>;
  sum?: Maybe<VersionsSumFields>;
  varPop?: Maybe<VersionsVarPopFields>;
  varSamp?: Maybe<VersionsVarSampFields>;
  variance?: Maybe<VersionsVarianceFields>;
};


/** aggregate fields of "versions" */
export type VersionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VersionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "versions" */
export type VersionsAggregateOrderBy = {
  avg?: InputMaybe<VersionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<VersionsMaxOrderBy>;
  min?: InputMaybe<VersionsMinOrderBy>;
  stddev?: InputMaybe<VersionsStddevOrderBy>;
  stddevPop?: InputMaybe<VersionsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<VersionsStddevSampOrderBy>;
  sum?: InputMaybe<VersionsSumOrderBy>;
  varPop?: InputMaybe<VersionsVarPopOrderBy>;
  varSamp?: InputMaybe<VersionsVarSampOrderBy>;
  variance?: InputMaybe<VersionsVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type VersionsAppendInput = {
  /** [figma sync] refactor needed into separate table - stores the JSON representation of the figma file that the user uploaded via the Figma plugin, allowing comments to be added onto specific frames in Figma even if the frames has been moved. Refactor needed as this JSON object can potentially be huge, causing the version to need to load a lot of data into memory in ruby when loaded. */
  figmaJsonRepresentation?: InputMaybe<Scalars['jsonb']['input']>;
  /** check and remove */
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "versions" */
export type VersionsArrRelInsertInput = {
  data: Array<VersionsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<VersionsOnConflict>;
};

/** aggregate avg on columns */
export type VersionsAvgFields = {
  __typename?: 'VersionsAvgFields';
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: Maybe<Scalars['Float']['output']>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: Maybe<Scalars['Float']['output']>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** Version number displayed to users */
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "versions" */
export type VersionsAvgOrderBy = {
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<OrderBy>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<OrderBy>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<OrderBy>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "versions". All fields are combined with a logical 'AND'. */
export type VersionsBoolExp = {
  _and?: InputMaybe<Array<VersionsBoolExp>>;
  _not?: InputMaybe<VersionsBoolExp>;
  _or?: InputMaybe<Array<VersionsBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  aiReviewError?: InputMaybe<StringComparisonExp>;
  aiReviewId?: InputMaybe<UuidComparisonExp>;
  aiReviewStatus?: InputMaybe<IntComparisonExp>;
  canvasItems?: InputMaybe<CanvasItemsBoolExp>;
  canvasItemsAggregate?: InputMaybe<CanvasItemsAggregateBoolExp>;
  category?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  customName?: InputMaybe<StringComparisonExp>;
  document?: InputMaybe<DocumentsBoolExp>;
  documentId?: InputMaybe<UuidComparisonExp>;
  figmaJsonRepresentation?: InputMaybe<JsonbComparisonExp>;
  figmaLink?: InputMaybe<StringComparisonExp>;
  figmaPageId?: InputMaybe<StringComparisonExp>;
  firstFileIsImage?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isDemo?: InputMaybe<BooleanComparisonExp>;
  items?: InputMaybe<ItemsBoolExp>;
  itemsAggregate?: InputMaybe<ItemsAggregateBoolExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  lockVersion?: InputMaybe<IntComparisonExp>;
  messages?: InputMaybe<MessagesBoolExp>;
  messagesAggregate?: InputMaybe<MessagesAggregateBoolExp>;
  slug?: InputMaybe<StringComparisonExp>;
  textJson?: InputMaybe<JsonbComparisonExp>;
  thumbnailProcessingError?: InputMaybe<StringComparisonExp>;
  thumbnailProcessingStatus?: InputMaybe<IntComparisonExp>;
  thumbnailUrl?: InputMaybe<StringComparisonExp>;
  thumbnailUrlExpiresAt?: InputMaybe<TimestamptzComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  versionNumber?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "versions" */
export enum VersionsConstraint {
  /** unique or primary key constraint on columns "slug" */
  IndexVersionsOnSlug = 'index_versions_on_slug',
  /** unique or primary key constraint on columns "id" */
  VersionsPkey = 'versions_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type VersionsDeleteAtPathInput = {
  /** [figma sync] refactor needed into separate table - stores the JSON representation of the figma file that the user uploaded via the Figma plugin, allowing comments to be added onto specific frames in Figma even if the frames has been moved. Refactor needed as this JSON object can potentially be huge, causing the version to need to load a lot of data into memory in ruby when loaded. */
  figmaJsonRepresentation?: InputMaybe<Array<Scalars['String']['input']>>;
  /** check and remove */
  textJson?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type VersionsDeleteElemInput = {
  /** [figma sync] refactor needed into separate table - stores the JSON representation of the figma file that the user uploaded via the Figma plugin, allowing comments to be added onto specific frames in Figma even if the frames has been moved. Refactor needed as this JSON object can potentially be huge, causing the version to need to load a lot of data into memory in ruby when loaded. */
  figmaJsonRepresentation?: InputMaybe<Scalars['Int']['input']>;
  /** check and remove */
  textJson?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type VersionsDeleteKeyInput = {
  /** [figma sync] refactor needed into separate table - stores the JSON representation of the figma file that the user uploaded via the Figma plugin, allowing comments to be added onto specific frames in Figma even if the frames has been moved. Refactor needed as this JSON object can potentially be huge, causing the version to need to load a lot of data into memory in ruby when loaded. */
  figmaJsonRepresentation?: InputMaybe<Scalars['String']['input']>;
  /** check and remove */
  textJson?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "versions" */
export type VersionsIncInput = {
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<Scalars['Int']['input']>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<Scalars['Int']['input']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "versions" */
export type VersionsInsertInput = {
  /** Account that the version belongs to */
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewError?: InputMaybe<Scalars['String']['input']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<Scalars['Int']['input']>;
  canvasItems?: InputMaybe<CanvasItemsArrRelInsertInput>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Allows user to add a name for this version, e.g. Prototype */
  customName?: InputMaybe<Scalars['String']['input']>;
  document?: InputMaybe<DocumentsObjRelInsertInput>;
  /** Document that the version is on */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** [figma sync] refactor needed into separate table - stores the JSON representation of the figma file that the user uploaded via the Figma plugin, allowing comments to be added onto specific frames in Figma even if the frames has been moved. Refactor needed as this JSON object can potentially be huge, causing the version to need to load a lot of data into memory in ruby when loaded. */
  figmaJsonRepresentation?: InputMaybe<Scalars['jsonb']['input']>;
  /** Rename - any external URL relating to this asset. Used for both figma files and sites. */
  figmaLink?: InputMaybe<Scalars['String']['input']>;
  /** The Figma page that the message is on has an ID */
  figmaPageId?: InputMaybe<Scalars['String']['input']>;
  /** check and remove - previously if the first file for a version was an image, we would be able to temporarily instantly show a thumbnail for a new task without waiting for thumbnail processing to finish by simply displaying the asset itself. */
  firstFileIsImage?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [analytics] remove demo content from analytics */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  items?: InputMaybe<ItemsArrRelInsertInput>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<Scalars['Int']['input']>;
  messages?: InputMaybe<MessagesArrRelInsertInput>;
  /** check and remove - slug used by urls for lookups */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** check and remove */
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
  /** [DEPRECATED] Any processing error for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [DEPRECATED] */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** [DEPRECATED] */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User who created the version */
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type VersionsMaxFields = {
  __typename?: 'VersionsMaxFields';
  /** Account that the version belongs to */
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewError?: Maybe<Scalars['String']['output']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewId?: Maybe<Scalars['uuid']['output']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: Maybe<Scalars['Int']['output']>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Allows user to add a name for this version, e.g. Prototype */
  customName?: Maybe<Scalars['String']['output']>;
  /** Document that the version is on */
  documentId?: Maybe<Scalars['uuid']['output']>;
  /** Rename - any external URL relating to this asset. Used for both figma files and sites. */
  figmaLink?: Maybe<Scalars['String']['output']>;
  /** The Figma page that the message is on has an ID */
  figmaPageId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Int']['output']>;
  /** check and remove - slug used by urls for lookups */
  slug?: Maybe<Scalars['String']['output']>;
  /** [DEPRECATED] Any processing error for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** [DEPRECATED] */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** [DEPRECATED] */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User who created the version */
  userId?: Maybe<Scalars['uuid']['output']>;
  /** Version number displayed to users */
  versionNumber?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "versions" */
export type VersionsMaxOrderBy = {
  /** Account that the version belongs to */
  accountId?: InputMaybe<OrderBy>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewError?: InputMaybe<OrderBy>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewId?: InputMaybe<OrderBy>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<OrderBy>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** Allows user to add a name for this version, e.g. Prototype */
  customName?: InputMaybe<OrderBy>;
  /** Document that the version is on */
  documentId?: InputMaybe<OrderBy>;
  /** Rename - any external URL relating to this asset. Used for both figma files and sites. */
  figmaLink?: InputMaybe<OrderBy>;
  /** The Figma page that the message is on has an ID */
  figmaPageId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<OrderBy>;
  /** check and remove - slug used by urls for lookups */
  slug?: InputMaybe<OrderBy>;
  /** [DEPRECATED] Any processing error for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingError?: InputMaybe<OrderBy>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** [DEPRECATED] */
  thumbnailUrl?: InputMaybe<OrderBy>;
  /** [DEPRECATED] */
  thumbnailUrlExpiresAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** User who created the version */
  userId?: InputMaybe<OrderBy>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type VersionsMinFields = {
  __typename?: 'VersionsMinFields';
  /** Account that the version belongs to */
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewError?: Maybe<Scalars['String']['output']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewId?: Maybe<Scalars['uuid']['output']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: Maybe<Scalars['Int']['output']>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Allows user to add a name for this version, e.g. Prototype */
  customName?: Maybe<Scalars['String']['output']>;
  /** Document that the version is on */
  documentId?: Maybe<Scalars['uuid']['output']>;
  /** Rename - any external URL relating to this asset. Used for both figma files and sites. */
  figmaLink?: Maybe<Scalars['String']['output']>;
  /** The Figma page that the message is on has an ID */
  figmaPageId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Int']['output']>;
  /** check and remove - slug used by urls for lookups */
  slug?: Maybe<Scalars['String']['output']>;
  /** [DEPRECATED] Any processing error for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** [DEPRECATED] */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** [DEPRECATED] */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User who created the version */
  userId?: Maybe<Scalars['uuid']['output']>;
  /** Version number displayed to users */
  versionNumber?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "versions" */
export type VersionsMinOrderBy = {
  /** Account that the version belongs to */
  accountId?: InputMaybe<OrderBy>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewError?: InputMaybe<OrderBy>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewId?: InputMaybe<OrderBy>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<OrderBy>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** Allows user to add a name for this version, e.g. Prototype */
  customName?: InputMaybe<OrderBy>;
  /** Document that the version is on */
  documentId?: InputMaybe<OrderBy>;
  /** Rename - any external URL relating to this asset. Used for both figma files and sites. */
  figmaLink?: InputMaybe<OrderBy>;
  /** The Figma page that the message is on has an ID */
  figmaPageId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<OrderBy>;
  /** check and remove - slug used by urls for lookups */
  slug?: InputMaybe<OrderBy>;
  /** [DEPRECATED] Any processing error for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingError?: InputMaybe<OrderBy>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** [DEPRECATED] */
  thumbnailUrl?: InputMaybe<OrderBy>;
  /** [DEPRECATED] */
  thumbnailUrlExpiresAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** User who created the version */
  userId?: InputMaybe<OrderBy>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "versions" */
export type VersionsMutationResponse = {
  __typename?: 'VersionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Versions>;
};

/** input type for inserting object relation for remote table "versions" */
export type VersionsObjRelInsertInput = {
  data: VersionsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<VersionsOnConflict>;
};

/** on_conflict condition type for table "versions" */
export type VersionsOnConflict = {
  constraint: VersionsConstraint;
  updateColumns?: Array<VersionsUpdateColumn>;
  where?: InputMaybe<VersionsBoolExp>;
};

/** Ordering options when selecting data from "versions". */
export type VersionsOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  aiReviewError?: InputMaybe<OrderBy>;
  aiReviewId?: InputMaybe<OrderBy>;
  aiReviewStatus?: InputMaybe<OrderBy>;
  canvasItemsAggregate?: InputMaybe<CanvasItemsAggregateOrderBy>;
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  customName?: InputMaybe<OrderBy>;
  document?: InputMaybe<DocumentsOrderBy>;
  documentId?: InputMaybe<OrderBy>;
  figmaJsonRepresentation?: InputMaybe<OrderBy>;
  figmaLink?: InputMaybe<OrderBy>;
  figmaPageId?: InputMaybe<OrderBy>;
  firstFileIsImage?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isDemo?: InputMaybe<OrderBy>;
  itemsAggregate?: InputMaybe<ItemsAggregateOrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  lockVersion?: InputMaybe<OrderBy>;
  messagesAggregate?: InputMaybe<MessagesAggregateOrderBy>;
  slug?: InputMaybe<OrderBy>;
  textJson?: InputMaybe<OrderBy>;
  thumbnailProcessingError?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  thumbnailUrl?: InputMaybe<OrderBy>;
  thumbnailUrlExpiresAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: versions */
export type VersionsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type VersionsPrependInput = {
  /** [figma sync] refactor needed into separate table - stores the JSON representation of the figma file that the user uploaded via the Figma plugin, allowing comments to be added onto specific frames in Figma even if the frames has been moved. Refactor needed as this JSON object can potentially be huge, causing the version to need to load a lot of data into memory in ruby when loaded. */
  figmaJsonRepresentation?: InputMaybe<Scalars['jsonb']['input']>;
  /** check and remove */
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "versions" */
export enum VersionsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  AiReviewError = 'aiReviewError',
  /** column name */
  AiReviewId = 'aiReviewId',
  /** column name */
  AiReviewStatus = 'aiReviewStatus',
  /** column name */
  Category = 'category',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomName = 'customName',
  /** column name */
  DocumentId = 'documentId',
  /** column name */
  FigmaJsonRepresentation = 'figmaJsonRepresentation',
  /** column name */
  FigmaLink = 'figmaLink',
  /** column name */
  FigmaPageId = 'figmaPageId',
  /** column name */
  FirstFileIsImage = 'firstFileIsImage',
  /** column name */
  Id = 'id',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LockVersion = 'lockVersion',
  /** column name */
  Slug = 'slug',
  /** column name */
  TextJson = 'textJson',
  /** column name */
  ThumbnailProcessingError = 'thumbnailProcessingError',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  ThumbnailUrl = 'thumbnailUrl',
  /** column name */
  ThumbnailUrlExpiresAt = 'thumbnailUrlExpiresAt',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  VersionNumber = 'versionNumber'
}

/** select "versionsAggregateBoolExpBool_andArgumentsColumns" columns of table "versions" */
export enum VersionsSelectColumnVersionsAggregateBoolExpBool_AndArgumentsColumns {
  /** column name */
  FirstFileIsImage = 'firstFileIsImage',
  /** column name */
  IsDemo = 'isDemo'
}

/** select "versionsAggregateBoolExpBool_orArgumentsColumns" columns of table "versions" */
export enum VersionsSelectColumnVersionsAggregateBoolExpBool_OrArgumentsColumns {
  /** column name */
  FirstFileIsImage = 'firstFileIsImage',
  /** column name */
  IsDemo = 'isDemo'
}

/** input type for updating data in table "versions" */
export type VersionsSetInput = {
  /** Account that the version belongs to */
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewError?: InputMaybe<Scalars['String']['input']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Allows user to add a name for this version, e.g. Prototype */
  customName?: InputMaybe<Scalars['String']['input']>;
  /** Document that the version is on */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** [figma sync] refactor needed into separate table - stores the JSON representation of the figma file that the user uploaded via the Figma plugin, allowing comments to be added onto specific frames in Figma even if the frames has been moved. Refactor needed as this JSON object can potentially be huge, causing the version to need to load a lot of data into memory in ruby when loaded. */
  figmaJsonRepresentation?: InputMaybe<Scalars['jsonb']['input']>;
  /** Rename - any external URL relating to this asset. Used for both figma files and sites. */
  figmaLink?: InputMaybe<Scalars['String']['input']>;
  /** The Figma page that the message is on has an ID */
  figmaPageId?: InputMaybe<Scalars['String']['input']>;
  /** check and remove - previously if the first file for a version was an image, we would be able to temporarily instantly show a thumbnail for a new task without waiting for thumbnail processing to finish by simply displaying the asset itself. */
  firstFileIsImage?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [analytics] remove demo content from analytics */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<Scalars['Int']['input']>;
  /** check and remove - slug used by urls for lookups */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** check and remove */
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
  /** [DEPRECATED] Any processing error for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [DEPRECATED] */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** [DEPRECATED] */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User who created the version */
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type VersionsStddevFields = {
  __typename?: 'VersionsStddevFields';
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: Maybe<Scalars['Float']['output']>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: Maybe<Scalars['Float']['output']>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** Version number displayed to users */
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "versions" */
export type VersionsStddevOrderBy = {
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<OrderBy>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<OrderBy>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<OrderBy>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type VersionsStddevPopFields = {
  __typename?: 'VersionsStddevPopFields';
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: Maybe<Scalars['Float']['output']>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: Maybe<Scalars['Float']['output']>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** Version number displayed to users */
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "versions" */
export type VersionsStddevPopOrderBy = {
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<OrderBy>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<OrderBy>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<OrderBy>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type VersionsStddevSampFields = {
  __typename?: 'VersionsStddevSampFields';
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: Maybe<Scalars['Float']['output']>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: Maybe<Scalars['Float']['output']>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** Version number displayed to users */
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "versions" */
export type VersionsStddevSampOrderBy = {
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<OrderBy>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<OrderBy>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<OrderBy>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "versions" */
export type VersionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VersionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VersionsStreamCursorValueInput = {
  /** Account that the version belongs to */
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewError?: InputMaybe<Scalars['String']['input']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewId?: InputMaybe<Scalars['uuid']['input']>;
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Allows user to add a name for this version, e.g. Prototype */
  customName?: InputMaybe<Scalars['String']['input']>;
  /** Document that the version is on */
  documentId?: InputMaybe<Scalars['uuid']['input']>;
  /** [figma sync] refactor needed into separate table - stores the JSON representation of the figma file that the user uploaded via the Figma plugin, allowing comments to be added onto specific frames in Figma even if the frames has been moved. Refactor needed as this JSON object can potentially be huge, causing the version to need to load a lot of data into memory in ruby when loaded. */
  figmaJsonRepresentation?: InputMaybe<Scalars['jsonb']['input']>;
  /** Rename - any external URL relating to this asset. Used for both figma files and sites. */
  figmaLink?: InputMaybe<Scalars['String']['input']>;
  /** The Figma page that the message is on has an ID */
  figmaPageId?: InputMaybe<Scalars['String']['input']>;
  /** check and remove - previously if the first file for a version was an image, we would be able to temporarily instantly show a thumbnail for a new task without waiting for thumbnail processing to finish by simply displaying the asset itself. */
  firstFileIsImage?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** [analytics] remove demo content from analytics */
  isDemo?: InputMaybe<Scalars['Boolean']['input']>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<Scalars['Int']['input']>;
  /** check and remove - slug used by urls for lookups */
  slug?: InputMaybe<Scalars['String']['input']>;
  /** check and remove */
  textJson?: InputMaybe<Scalars['jsonb']['input']>;
  /** [DEPRECATED] Any processing error for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** [DEPRECATED] */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** [DEPRECATED] */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User who created the version */
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type VersionsSumFields = {
  __typename?: 'VersionsSumFields';
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: Maybe<Scalars['Int']['output']>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: Maybe<Scalars['Int']['output']>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Int']['output']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** Version number displayed to users */
  versionNumber?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "versions" */
export type VersionsSumOrderBy = {
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<OrderBy>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<OrderBy>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<OrderBy>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<OrderBy>;
};

/** update columns of table "versions" */
export enum VersionsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  AiReviewError = 'aiReviewError',
  /** column name */
  AiReviewId = 'aiReviewId',
  /** column name */
  AiReviewStatus = 'aiReviewStatus',
  /** column name */
  Category = 'category',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomName = 'customName',
  /** column name */
  DocumentId = 'documentId',
  /** column name */
  FigmaJsonRepresentation = 'figmaJsonRepresentation',
  /** column name */
  FigmaLink = 'figmaLink',
  /** column name */
  FigmaPageId = 'figmaPageId',
  /** column name */
  FirstFileIsImage = 'firstFileIsImage',
  /** column name */
  Id = 'id',
  /** column name */
  IsDemo = 'isDemo',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LockVersion = 'lockVersion',
  /** column name */
  Slug = 'slug',
  /** column name */
  TextJson = 'textJson',
  /** column name */
  ThumbnailProcessingError = 'thumbnailProcessingError',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  ThumbnailUrl = 'thumbnailUrl',
  /** column name */
  ThumbnailUrlExpiresAt = 'thumbnailUrlExpiresAt',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  VersionNumber = 'versionNumber'
}

export type VersionsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<VersionsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<VersionsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<VersionsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<VersionsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<VersionsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<VersionsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VersionsSetInput>;
  /** filter the rows which have to be updated */
  where: VersionsBoolExp;
};

/** aggregate varPop on columns */
export type VersionsVarPopFields = {
  __typename?: 'VersionsVarPopFields';
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: Maybe<Scalars['Float']['output']>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: Maybe<Scalars['Float']['output']>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** Version number displayed to users */
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "versions" */
export type VersionsVarPopOrderBy = {
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<OrderBy>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<OrderBy>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<OrderBy>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type VersionsVarSampFields = {
  __typename?: 'VersionsVarSampFields';
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: Maybe<Scalars['Float']['output']>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: Maybe<Scalars['Float']['output']>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** Version number displayed to users */
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "versions" */
export type VersionsVarSampOrderBy = {
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<OrderBy>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<OrderBy>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<OrderBy>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type VersionsVarianceFields = {
  __typename?: 'VersionsVarianceFields';
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: Maybe<Scalars['Float']['output']>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: Maybe<Scalars['Float']['output']>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** Version number displayed to users */
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "versions" */
export type VersionsVarianceOrderBy = {
  /** remove - part of old ai review system, unrelated to new ai checks system */
  aiReviewStatus?: InputMaybe<OrderBy>;
  /** [enum] type of content for the version, e.g. images, sites */
  category?: InputMaybe<OrderBy>;
  /** [replicache] Version number of the last modified version */
  lastModifiedVersion?: InputMaybe<OrderBy>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<OrderBy>;
  /** [DEPRECATED] Processing status for the thumbnail. The thumbnail of the latest version of an asset is displayed on the Kanban board. */
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  /** Version number displayed to users */
  versionNumber?: InputMaybe<OrderBy>;
};

/** CanvasItem subtype that stores the metadata relating to videos */
export type VideoItems = {
  __typename?: 'VideoItems';
  accountId: Scalars['uuid']['output'];
  /** An object relationship */
  canvasItem?: Maybe<CanvasItems>;
  /** The parent canvas item */
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  createdAt: Scalars['timestamp']['output'];
  /** URL pointing to the fallback (.mp4) video file */
  fallbackVideoUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the fallback video URL expires */
  fallbackVideoUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Int']['output']>;
  id: Scalars['uuid']['output'];
  lastModifiedVersion: Scalars['Int']['output'];
  /** Optimistic locking for concurrent processing. */
  lockVersion: Scalars['Int']['output'];
  /** URL pointing to the original video file */
  originalVideoUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the original video URL expires */
  originalVideoUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  /** The error reason of the file item processing, if applicable. */
  processingErrorReason?: Maybe<Scalars['String']['output']>;
  /** The processing status of the file item. */
  processingStatus: Scalars['Int']['output'];
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus: Scalars['Int']['output'];
  /** Thumbnail presigned URL */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt: Scalars['timestamp']['output'];
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "video_items" */
export type VideoItemsAggregate = {
  __typename?: 'VideoItemsAggregate';
  aggregate?: Maybe<VideoItemsAggregateFields>;
  nodes: Array<VideoItems>;
};

/** aggregate fields of "video_items" */
export type VideoItemsAggregateFields = {
  __typename?: 'VideoItemsAggregateFields';
  avg?: Maybe<VideoItemsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<VideoItemsMaxFields>;
  min?: Maybe<VideoItemsMinFields>;
  stddev?: Maybe<VideoItemsStddevFields>;
  stddevPop?: Maybe<VideoItemsStddevPopFields>;
  stddevSamp?: Maybe<VideoItemsStddevSampFields>;
  sum?: Maybe<VideoItemsSumFields>;
  varPop?: Maybe<VideoItemsVarPopFields>;
  varSamp?: Maybe<VideoItemsVarSampFields>;
  variance?: Maybe<VideoItemsVarianceFields>;
};


/** aggregate fields of "video_items" */
export type VideoItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<VideoItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type VideoItemsAvgFields = {
  __typename?: 'VideoItemsAvgFields';
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item. */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "video_items". All fields are combined with a logical 'AND'. */
export type VideoItemsBoolExp = {
  _and?: InputMaybe<Array<VideoItemsBoolExp>>;
  _not?: InputMaybe<VideoItemsBoolExp>;
  _or?: InputMaybe<Array<VideoItemsBoolExp>>;
  accountId?: InputMaybe<UuidComparisonExp>;
  canvasItem?: InputMaybe<CanvasItemsBoolExp>;
  canvasItemId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  fallbackVideoUrl?: InputMaybe<StringComparisonExp>;
  fallbackVideoUrlExpiresAt?: InputMaybe<TimestamptzComparisonExp>;
  height?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastModifiedVersion?: InputMaybe<IntComparisonExp>;
  lockVersion?: InputMaybe<IntComparisonExp>;
  originalVideoUrl?: InputMaybe<StringComparisonExp>;
  originalVideoUrlExpiresAt?: InputMaybe<TimestamptzComparisonExp>;
  processingErrorReason?: InputMaybe<StringComparisonExp>;
  processingStatus?: InputMaybe<IntComparisonExp>;
  thumbnailProcessingError?: InputMaybe<StringComparisonExp>;
  thumbnailProcessingStatus?: InputMaybe<IntComparisonExp>;
  thumbnailUrl?: InputMaybe<StringComparisonExp>;
  thumbnailUrlExpiresAt?: InputMaybe<TimestamptzComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  width?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "video_items" */
export enum VideoItemsConstraint {
  /** unique or primary key constraint on columns "canvas_item_id" */
  IndexVideoItemsOnCanvasItemId = 'index_video_items_on_canvas_item_id',
  /** unique or primary key constraint on columns "id" */
  VideoItemsPkey = 'video_items_pkey'
}

/** input type for incrementing numeric columns in table "video_items" */
export type VideoItemsIncInput = {
  /** The width of the item. Calculated async. */
  height?: InputMaybe<Scalars['Int']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<Scalars['Int']['input']>;
  /** The processing status of the file item. */
  processingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** The width of the item. Calculated async. */
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "video_items" */
export type VideoItemsInsertInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  canvasItem?: InputMaybe<CanvasItemsObjRelInsertInput>;
  /** The parent canvas item */
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** URL pointing to the fallback (.mp4) video file */
  fallbackVideoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the fallback video URL expires */
  fallbackVideoUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The width of the item. Calculated async. */
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<Scalars['Int']['input']>;
  /** URL pointing to the original video file */
  originalVideoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the original video URL expires */
  originalVideoUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The error reason of the file item processing, if applicable. */
  processingErrorReason?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the file item. */
  processingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** Thumbnail presigned URL */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The width of the item. Calculated async. */
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type VideoItemsMaxFields = {
  __typename?: 'VideoItemsMaxFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** The parent canvas item */
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** URL pointing to the fallback (.mp4) video file */
  fallbackVideoUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the fallback video URL expires */
  fallbackVideoUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Int']['output']>;
  /** URL pointing to the original video file */
  originalVideoUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the original video URL expires */
  originalVideoUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  /** The error reason of the file item processing, if applicable. */
  processingErrorReason?: Maybe<Scalars['String']['output']>;
  /** The processing status of the file item. */
  processingStatus?: Maybe<Scalars['Int']['output']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** Thumbnail presigned URL */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type VideoItemsMinFields = {
  __typename?: 'VideoItemsMinFields';
  accountId?: Maybe<Scalars['uuid']['output']>;
  /** The parent canvas item */
  canvasItemId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** URL pointing to the fallback (.mp4) video file */
  fallbackVideoUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the fallback video URL expires */
  fallbackVideoUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Int']['output']>;
  /** URL pointing to the original video file */
  originalVideoUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the original video URL expires */
  originalVideoUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  /** The error reason of the file item processing, if applicable. */
  processingErrorReason?: Maybe<Scalars['String']['output']>;
  /** The processing status of the file item. */
  processingStatus?: Maybe<Scalars['Int']['output']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: Maybe<Scalars['String']['output']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** Thumbnail presigned URL */
  thumbnailUrl?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "video_items" */
export type VideoItemsMutationResponse = {
  __typename?: 'VideoItemsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<VideoItems>;
};

/** input type for inserting object relation for remote table "video_items" */
export type VideoItemsObjRelInsertInput = {
  data: VideoItemsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<VideoItemsOnConflict>;
};

/** on_conflict condition type for table "video_items" */
export type VideoItemsOnConflict = {
  constraint: VideoItemsConstraint;
  updateColumns?: Array<VideoItemsUpdateColumn>;
  where?: InputMaybe<VideoItemsBoolExp>;
};

/** Ordering options when selecting data from "video_items". */
export type VideoItemsOrderBy = {
  accountId?: InputMaybe<OrderBy>;
  canvasItem?: InputMaybe<CanvasItemsOrderBy>;
  canvasItemId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  fallbackVideoUrl?: InputMaybe<OrderBy>;
  fallbackVideoUrlExpiresAt?: InputMaybe<OrderBy>;
  height?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastModifiedVersion?: InputMaybe<OrderBy>;
  lockVersion?: InputMaybe<OrderBy>;
  originalVideoUrl?: InputMaybe<OrderBy>;
  originalVideoUrlExpiresAt?: InputMaybe<OrderBy>;
  processingErrorReason?: InputMaybe<OrderBy>;
  processingStatus?: InputMaybe<OrderBy>;
  thumbnailProcessingError?: InputMaybe<OrderBy>;
  thumbnailProcessingStatus?: InputMaybe<OrderBy>;
  thumbnailUrl?: InputMaybe<OrderBy>;
  thumbnailUrlExpiresAt?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  width?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: video_items */
export type VideoItemsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "video_items" */
export enum VideoItemsSelectColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CanvasItemId = 'canvasItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FallbackVideoUrl = 'fallbackVideoUrl',
  /** column name */
  FallbackVideoUrlExpiresAt = 'fallbackVideoUrlExpiresAt',
  /** column name */
  Height = 'height',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LockVersion = 'lockVersion',
  /** column name */
  OriginalVideoUrl = 'originalVideoUrl',
  /** column name */
  OriginalVideoUrlExpiresAt = 'originalVideoUrlExpiresAt',
  /** column name */
  ProcessingErrorReason = 'processingErrorReason',
  /** column name */
  ProcessingStatus = 'processingStatus',
  /** column name */
  ThumbnailProcessingError = 'thumbnailProcessingError',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  ThumbnailUrl = 'thumbnailUrl',
  /** column name */
  ThumbnailUrlExpiresAt = 'thumbnailUrlExpiresAt',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Width = 'width'
}

/** input type for updating data in table "video_items" */
export type VideoItemsSetInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** The parent canvas item */
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** URL pointing to the fallback (.mp4) video file */
  fallbackVideoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the fallback video URL expires */
  fallbackVideoUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The width of the item. Calculated async. */
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<Scalars['Int']['input']>;
  /** URL pointing to the original video file */
  originalVideoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the original video URL expires */
  originalVideoUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The error reason of the file item processing, if applicable. */
  processingErrorReason?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the file item. */
  processingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** Thumbnail presigned URL */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The width of the item. Calculated async. */
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type VideoItemsStddevFields = {
  __typename?: 'VideoItemsStddevFields';
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item. */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type VideoItemsStddevPopFields = {
  __typename?: 'VideoItemsStddevPopFields';
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item. */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type VideoItemsStddevSampFields = {
  __typename?: 'VideoItemsStddevSampFields';
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item. */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "video_items" */
export type VideoItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: VideoItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type VideoItemsStreamCursorValueInput = {
  accountId?: InputMaybe<Scalars['uuid']['input']>;
  /** The parent canvas item */
  canvasItemId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** URL pointing to the fallback (.mp4) video file */
  fallbackVideoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the fallback video URL expires */
  fallbackVideoUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The width of the item. Calculated async. */
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastModifiedVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: InputMaybe<Scalars['Int']['input']>;
  /** URL pointing to the original video file */
  originalVideoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the original video URL expires */
  originalVideoUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** The error reason of the file item processing, if applicable. */
  processingErrorReason?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the file item. */
  processingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** The error reason of the thumbnail processing, if applicable. */
  thumbnailProcessingError?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: InputMaybe<Scalars['Int']['input']>;
  /** Thumbnail presigned URL */
  thumbnailUrl?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the thumbnail URL expires */
  thumbnailUrlExpiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** The width of the item. Calculated async. */
  width?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type VideoItemsSumFields = {
  __typename?: 'VideoItemsSumFields';
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Int']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Int']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Int']['output']>;
  /** The processing status of the file item. */
  processingStatus?: Maybe<Scalars['Int']['output']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Int']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "video_items" */
export enum VideoItemsUpdateColumn {
  /** column name */
  AccountId = 'accountId',
  /** column name */
  CanvasItemId = 'canvasItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FallbackVideoUrl = 'fallbackVideoUrl',
  /** column name */
  FallbackVideoUrlExpiresAt = 'fallbackVideoUrlExpiresAt',
  /** column name */
  Height = 'height',
  /** column name */
  Id = 'id',
  /** column name */
  LastModifiedVersion = 'lastModifiedVersion',
  /** column name */
  LockVersion = 'lockVersion',
  /** column name */
  OriginalVideoUrl = 'originalVideoUrl',
  /** column name */
  OriginalVideoUrlExpiresAt = 'originalVideoUrlExpiresAt',
  /** column name */
  ProcessingErrorReason = 'processingErrorReason',
  /** column name */
  ProcessingStatus = 'processingStatus',
  /** column name */
  ThumbnailProcessingError = 'thumbnailProcessingError',
  /** column name */
  ThumbnailProcessingStatus = 'thumbnailProcessingStatus',
  /** column name */
  ThumbnailUrl = 'thumbnailUrl',
  /** column name */
  ThumbnailUrlExpiresAt = 'thumbnailUrlExpiresAt',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Width = 'width'
}

export type VideoItemsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<VideoItemsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<VideoItemsSetInput>;
  /** filter the rows which have to be updated */
  where: VideoItemsBoolExp;
};

/** aggregate varPop on columns */
export type VideoItemsVarPopFields = {
  __typename?: 'VideoItemsVarPopFields';
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item. */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type VideoItemsVarSampFields = {
  __typename?: 'VideoItemsVarSampFields';
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item. */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type VideoItemsVarianceFields = {
  __typename?: 'VideoItemsVarianceFields';
  /** The width of the item. Calculated async. */
  height?: Maybe<Scalars['Float']['output']>;
  lastModifiedVersion?: Maybe<Scalars['Float']['output']>;
  /** Optimistic locking for concurrent processing. */
  lockVersion?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the file item. */
  processingStatus?: Maybe<Scalars['Float']['output']>;
  /** The processing status of the thumbnail of the video item. */
  thumbnailProcessingStatus?: Maybe<Scalars['Float']['output']>;
  /** The width of the item. Calculated async. */
  width?: Maybe<Scalars['Float']['output']>;
};

export type Viewport = {
  height: Scalars['Int']['input'];
  width: Scalars['Int']['input'];
};

export type AccountInvoicesAggregateBoolExpBool_And = {
  arguments: AccountInvoicesSelectColumnAccountInvoicesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AccountInvoicesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type AccountInvoicesAggregateBoolExpBool_Or = {
  arguments: AccountInvoicesSelectColumnAccountInvoicesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AccountInvoicesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type AccountInvoicesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<AccountInvoicesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AccountInvoicesBoolExp>;
  predicate: IntComparisonExp;
};

export type AccountUsersAggregateBoolExpBool_And = {
  arguments: AccountUsersSelectColumnAccountUsersAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AccountUsersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type AccountUsersAggregateBoolExpBool_Or = {
  arguments: AccountUsersSelectColumnAccountUsersAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AccountUsersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type AccountUsersAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<AccountUsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AccountUsersBoolExp>;
  predicate: IntComparisonExp;
};

export type AccountsAggregateBoolExpBool_And = {
  arguments: AccountsSelectColumnAccountsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AccountsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type AccountsAggregateBoolExpBool_Or = {
  arguments: AccountsSelectColumnAccountsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AccountsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type AccountsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<AccountsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AccountsBoolExp>;
  predicate: IntComparisonExp;
};

export type CanvasItemsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<CanvasItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<CanvasItemsBoolExp>;
  predicate: IntComparisonExp;
};

export type CreateStorageObjectForAssetOutput = {
  __typename?: 'createStorageObjectForAssetOutput';
  signedUrl: Scalars['String']['output'];
  storageObjectId: Scalars['uuid']['output'];
};

export type DocumentLabelsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<DocumentLabelsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<DocumentLabelsBoolExp>;
  predicate: IntComparisonExp;
};

export type DocumentUsersAggregateBoolExpBool_And = {
  arguments: DocumentUsersSelectColumnDocumentUsersAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<DocumentUsersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type DocumentUsersAggregateBoolExpBool_Or = {
  arguments: DocumentUsersSelectColumnDocumentUsersAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<DocumentUsersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type DocumentUsersAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<DocumentUsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<DocumentUsersBoolExp>;
  predicate: IntComparisonExp;
};

export type DocumentsAggregateBoolExpBool_And = {
  arguments: DocumentsSelectColumnDocumentsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<DocumentsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type DocumentsAggregateBoolExpBool_Or = {
  arguments: DocumentsSelectColumnDocumentsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<DocumentsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type DocumentsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<DocumentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<DocumentsBoolExp>;
  predicate: IntComparisonExp;
};

export type ItemsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ItemsBoolExp>;
  predicate: IntComparisonExp;
};

export type LabelsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LabelsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<LabelsBoolExp>;
  predicate: IntComparisonExp;
};

export type LanesAggregateBoolExpBool_And = {
  arguments: LanesSelectColumnLanesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<LanesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type LanesAggregateBoolExpBool_Or = {
  arguments: LanesSelectColumnLanesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<LanesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type LanesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LanesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<LanesBoolExp>;
  predicate: IntComparisonExp;
};

export type MessageFilesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<MessageFilesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessageFilesBoolExp>;
  predicate: IntComparisonExp;
};

export type MessageUsersAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<MessageUsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessageUsersBoolExp>;
  predicate: IntComparisonExp;
};

export type MessagesAggregateBoolExpAvg = {
  arguments: MessagesSelectColumnMessagesAggregateBoolExpAvgArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessagesBoolExp>;
  predicate: Float8ComparisonExp;
};

export type MessagesAggregateBoolExpBool_And = {
  arguments: MessagesSelectColumnMessagesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessagesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type MessagesAggregateBoolExpBool_Or = {
  arguments: MessagesSelectColumnMessagesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessagesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type MessagesAggregateBoolExpCorr = {
  arguments: MessagesAggregateBoolExpCorrArguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessagesBoolExp>;
  predicate: Float8ComparisonExp;
};

export type MessagesAggregateBoolExpCorrArguments = {
  X: MessagesSelectColumnMessagesAggregateBoolExpCorrArgumentsColumns;
  Y: MessagesSelectColumnMessagesAggregateBoolExpCorrArgumentsColumns;
};

export type MessagesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<MessagesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessagesBoolExp>;
  predicate: IntComparisonExp;
};

export type MessagesAggregateBoolExpCovar_Samp = {
  arguments: MessagesAggregateBoolExpCovar_SampArguments;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessagesBoolExp>;
  predicate: Float8ComparisonExp;
};

export type MessagesAggregateBoolExpCovar_SampArguments = {
  X: MessagesSelectColumnMessagesAggregateBoolExpCovar_SampArgumentsColumns;
  Y: MessagesSelectColumnMessagesAggregateBoolExpCovar_SampArgumentsColumns;
};

export type MessagesAggregateBoolExpMax = {
  arguments: MessagesSelectColumnMessagesAggregateBoolExpMaxArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessagesBoolExp>;
  predicate: Float8ComparisonExp;
};

export type MessagesAggregateBoolExpMin = {
  arguments: MessagesSelectColumnMessagesAggregateBoolExpMinArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessagesBoolExp>;
  predicate: Float8ComparisonExp;
};

export type MessagesAggregateBoolExpStddev_Samp = {
  arguments: MessagesSelectColumnMessagesAggregateBoolExpStddev_SampArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessagesBoolExp>;
  predicate: Float8ComparisonExp;
};

export type MessagesAggregateBoolExpSum = {
  arguments: MessagesSelectColumnMessagesAggregateBoolExpSumArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessagesBoolExp>;
  predicate: Float8ComparisonExp;
};

export type MessagesAggregateBoolExpVar_Samp = {
  arguments: MessagesSelectColumnMessagesAggregateBoolExpVar_SampArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MessagesBoolExp>;
  predicate: Float8ComparisonExp;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  /** completeMultipartUpload */
  completeMultipartUpload?: Maybe<CompleteMultipartUploadOutput>;
  /** createDocumentWithVersionBlobs */
  createDocumentWithVersionBlobs?: Maybe<CreateDocumentOutput>;
  /** createDocumentWithVersionSite */
  createDocumentWithVersionSite?: Maybe<CreateDocumentOutput>;
  /** createDocumentWithVersionSiteAdmin */
  createDocumentWithVersionSiteAdmin?: Maybe<CreateDocumentOutput>;
  /** createDocumentWithoutVersion */
  createDocumentWithoutVersion?: Maybe<CreateDocumentOutput>;
  /** Create a MessageFile */
  createMessageFile?: Maybe<CreateMessageFileOutput>;
  /** CreateStorageObjectForAsset */
  createStorageObjectForAsset?: Maybe<CreateStorageObjectForAssetOutput>;
  /** createVersionWithBlobs */
  createVersionWithBlobs?: Maybe<CreateVersionOutput>;
  /** createVersionWithSite */
  createVersionWithSite?: Maybe<CreateVersionOutput>;
  /** createVersionWithTextDoc */
  createVersionWithTextDoc?: Maybe<CreateVersionOutput>;
  /** delete data from the table: "account_invoice_stripe_statuses" */
  deleteAccountInvoiceStripeStatuses?: Maybe<AccountInvoiceStripeStatusesMutationResponse>;
  /** delete single row from the table: "account_invoice_stripe_statuses" */
  deleteAccountInvoiceStripeStatusesByPk?: Maybe<AccountInvoiceStripeStatuses>;
  /** delete data from the table: "account_invoice_types" */
  deleteAccountInvoiceTypes?: Maybe<AccountInvoiceTypesMutationResponse>;
  /** delete single row from the table: "account_invoice_types" */
  deleteAccountInvoiceTypesByPk?: Maybe<AccountInvoiceTypes>;
  /** delete data from the table: "account_invoices" */
  deleteAccountInvoices?: Maybe<AccountInvoicesMutationResponse>;
  /** delete single row from the table: "account_invoices" */
  deleteAccountInvoicesByPk?: Maybe<AccountInvoices>;
  /** delete data from the table: "account_user_roles" */
  deleteAccountUserRoles?: Maybe<AccountUserRolesMutationResponse>;
  /** delete single row from the table: "account_user_roles" */
  deleteAccountUserRolesByPk?: Maybe<AccountUserRoles>;
  /** delete data from the table: "account_users" */
  deleteAccountUsers?: Maybe<AccountUsersMutationResponse>;
  /** delete single row from the table: "account_users" */
  deleteAccountUsersByPk?: Maybe<AccountUsers>;
  /** delete data from the table: "accounts" */
  deleteAccounts?: Maybe<AccountsMutationResponse>;
  /** delete single row from the table: "accounts" */
  deleteAccountsByPk?: Maybe<Accounts>;
  /** delete data from the table: "canvas_items" */
  deleteCanvasItems?: Maybe<CanvasItemsMutationResponse>;
  /** delete single row from the table: "canvas_items" */
  deleteCanvasItemsByPk?: Maybe<CanvasItems>;
  /** delete data from the table: "db_event_log_types" */
  deleteDbEventLogTypes?: Maybe<DbEventLogTypesMutationResponse>;
  /** delete single row from the table: "db_event_log_types" */
  deleteDbEventLogTypesByPk?: Maybe<DbEventLogTypes>;
  /** delete data from the table: "db_event_logs" */
  deleteDbEventLogs?: Maybe<DbEventLogsMutationResponse>;
  /** delete single row from the table: "db_event_logs" */
  deleteDbEventLogsByPk?: Maybe<DbEventLogs>;
  /** delete data from the table: "document_labels" */
  deleteDocumentLabels?: Maybe<DocumentLabelsMutationResponse>;
  /** delete single row from the table: "document_labels" */
  deleteDocumentLabelsByPk?: Maybe<DocumentLabels>;
  /** delete data from the table: "document_users" */
  deleteDocumentUsers?: Maybe<DocumentUsersMutationResponse>;
  /** delete single row from the table: "document_users" */
  deleteDocumentUsersByPk?: Maybe<DocumentUsers>;
  /** delete data from the table: "documents" */
  deleteDocuments?: Maybe<DocumentsMutationResponse>;
  /** delete single row from the table: "documents" */
  deleteDocumentsByPk?: Maybe<Documents>;
  /** delete data from the table: "emails" */
  deleteEmails?: Maybe<EmailsMutationResponse>;
  /** delete single row from the table: "emails" */
  deleteEmailsByPk?: Maybe<Emails>;
  /** delete data from the table: "file_items" */
  deleteFileItems?: Maybe<FileItemsMutationResponse>;
  /** delete single row from the table: "file_items" */
  deleteFileItemsByPk?: Maybe<FileItems>;
  /** delete data from the table: "guided_tours" */
  deleteGuidedTours?: Maybe<GuidedToursMutationResponse>;
  /** delete single row from the table: "guided_tours" */
  deleteGuidedToursByPk?: Maybe<GuidedTours>;
  /** delete data from the table: "items" */
  deleteItems?: Maybe<ItemsMutationResponse>;
  /** delete single row from the table: "items" */
  deleteItemsByPk?: Maybe<Items>;
  /** delete data from the table: "labels" */
  deleteLabels?: Maybe<LabelsMutationResponse>;
  /** delete single row from the table: "labels" */
  deleteLabelsByPk?: Maybe<Labels>;
  /** delete data from the table: "lanes" */
  deleteLanes?: Maybe<LanesMutationResponse>;
  /** delete single row from the table: "lanes" */
  deleteLanesByPk?: Maybe<Lanes>;
  /** delete data from the table: "mentions" */
  deleteMentions?: Maybe<MentionsMutationResponse>;
  /** delete single row from the table: "mentions" */
  deleteMentionsByPk?: Maybe<Mentions>;
  /** delete data from the table: "message_files" */
  deleteMessageFiles?: Maybe<MessageFilesMutationResponse>;
  /** delete single row from the table: "message_files" */
  deleteMessageFilesByPk?: Maybe<MessageFiles>;
  /** delete data from the table: "message_users" */
  deleteMessageUsers?: Maybe<MessageUsersMutationResponse>;
  /** delete single row from the table: "message_users" */
  deleteMessageUsersByPk?: Maybe<MessageUsers>;
  /** delete data from the table: "messages" */
  deleteMessages?: Maybe<MessagesMutationResponse>;
  /** delete single row from the table: "messages" */
  deleteMessagesByPk?: Maybe<Messages>;
  /** delete data from the table: "my_document_users" */
  deleteMyDocumentUsers?: Maybe<MyDocumentUsersMutationResponse>;
  /** delete data from the table: "my_user_info" */
  deleteMyUserInfo?: Maybe<MyUserInfoMutationResponse>;
  /** delete data from the table: "notifications" */
  deleteNotifications?: Maybe<NotificationsMutationResponse>;
  /** delete single row from the table: "notifications" */
  deleteNotificationsByPk?: Maybe<Notifications>;
  /** delete data from the table: "pdf_items" */
  deletePdfItems?: Maybe<PdfItemsMutationResponse>;
  /** delete single row from the table: "pdf_items" */
  deletePdfItemsByPk?: Maybe<PdfItems>;
  /** delete data from the table: "project_and_folder_organizers" */
  deleteProjectAndFolderOrganizers?: Maybe<ProjectAndFolderOrganizersMutationResponse>;
  /** delete single row from the table: "project_and_folder_organizers" */
  deleteProjectAndFolderOrganizersByPk?: Maybe<ProjectAndFolderOrganizers>;
  /** delete data from the table: "project_folders" */
  deleteProjectFolders?: Maybe<ProjectFoldersMutationResponse>;
  /** delete single row from the table: "project_folders" */
  deleteProjectFoldersByPk?: Maybe<ProjectFolders>;
  /** delete data from the table: "project_users" */
  deleteProjectUsers?: Maybe<ProjectUsersMutationResponse>;
  /** delete single row from the table: "project_users" */
  deleteProjectUsersByPk?: Maybe<ProjectUsers>;
  /** delete data from the table: "projects" */
  deleteProjects?: Maybe<ProjectsMutationResponse>;
  /** delete single row from the table: "projects" */
  deleteProjectsByPk?: Maybe<Projects>;
  /** delete data from the table: "reactions" */
  deleteReactions?: Maybe<ReactionsMutationResponse>;
  /** delete single row from the table: "reactions" */
  deleteReactionsByPk?: Maybe<Reactions>;
  /** delete data from the table: "recordings" */
  deleteRecordings?: Maybe<RecordingsMutationResponse>;
  /** delete single row from the table: "recordings" */
  deleteRecordingsByPk?: Maybe<Recordings>;
  /** delete data from the table: "site_items" */
  deleteSiteItems?: Maybe<SiteItemsMutationResponse>;
  /** delete single row from the table: "site_items" */
  deleteSiteItemsByPk?: Maybe<SiteItems>;
  /** delete data from the table: "storage_multi_objects_metadata" */
  deleteStorageMultiObjectsMetadata?: Maybe<StorageMultiObjectsMetadataMutationResponse>;
  /** delete single row from the table: "storage_multi_objects_metadata" */
  deleteStorageMultiObjectsMetadataByPk?: Maybe<StorageMultiObjectsMetadata>;
  /** delete data from the table: "storage_objects_metadata" */
  deleteStorageObjectsMetadata?: Maybe<StorageObjectsMetadataMutationResponse>;
  /** delete single row from the table: "storage_objects_metadata" */
  deleteStorageObjectsMetadataByPk?: Maybe<StorageObjectsMetadata>;
  /** delete data from the table: "subscription_statuses" */
  deleteSubscriptionStatuses?: Maybe<SubscriptionStatusesMutationResponse>;
  /** delete single row from the table: "subscription_statuses" */
  deleteSubscriptionStatusesByPk?: Maybe<SubscriptionStatuses>;
  /** delete data from the table: "subscription_types" */
  deleteSubscriptionTypes?: Maybe<SubscriptionTypesMutationResponse>;
  /** delete single row from the table: "subscription_types" */
  deleteSubscriptionTypesByPk?: Maybe<SubscriptionTypes>;
  /** delete data from the table: "suggestions" */
  deleteSuggestions?: Maybe<SuggestionsMutationResponse>;
  /** delete single row from the table: "suggestions" */
  deleteSuggestionsByPk?: Maybe<Suggestions>;
  /** delete data from the table: "text_items" */
  deleteTextItems?: Maybe<TextItemsMutationResponse>;
  /** delete single row from the table: "text_items" */
  deleteTextItemsByPk?: Maybe<TextItems>;
  /** delete data from the table: "transcriptions" */
  deleteTranscriptions?: Maybe<TranscriptionsMutationResponse>;
  /** delete single row from the table: "transcriptions" */
  deleteTranscriptionsByPk?: Maybe<Transcriptions>;
  /** delete data from the table: "users" */
  deleteUsers?: Maybe<UsersMutationResponse>;
  /** delete single row from the table: "users" */
  deleteUsersByPk?: Maybe<Users>;
  /** delete data from the table: "versions" */
  deleteVersions?: Maybe<VersionsMutationResponse>;
  /** delete single row from the table: "versions" */
  deleteVersionsByPk?: Maybe<Versions>;
  /** delete data from the table: "video_items" */
  deleteVideoItems?: Maybe<VideoItemsMutationResponse>;
  /** delete single row from the table: "video_items" */
  deleteVideoItemsByPk?: Maybe<VideoItems>;
  /** Duplicate Document (task) */
  duplicateDocument?: Maybe<DuplicateDocumentOutput>;
  /** getPresignedUrlForMultipartUpload */
  getPresignedUrlForMultipartUpload?: Maybe<GetPresignedUrlForMultipartUploadOutput>;
  /** initiateMultipartUpload */
  initiateMultipartUpload?: Maybe<InitiateMultipartUploadOutput>;
  /** insert data into the table: "account_invoice_stripe_statuses" */
  insertAccountInvoiceStripeStatuses?: Maybe<AccountInvoiceStripeStatusesMutationResponse>;
  /** insert a single row into the table: "account_invoice_stripe_statuses" */
  insertAccountInvoiceStripeStatusesOne?: Maybe<AccountInvoiceStripeStatuses>;
  /** insert data into the table: "account_invoice_types" */
  insertAccountInvoiceTypes?: Maybe<AccountInvoiceTypesMutationResponse>;
  /** insert a single row into the table: "account_invoice_types" */
  insertAccountInvoiceTypesOne?: Maybe<AccountInvoiceTypes>;
  /** insert data into the table: "account_invoices" */
  insertAccountInvoices?: Maybe<AccountInvoicesMutationResponse>;
  /** insert a single row into the table: "account_invoices" */
  insertAccountInvoicesOne?: Maybe<AccountInvoices>;
  /** insert data into the table: "account_user_roles" */
  insertAccountUserRoles?: Maybe<AccountUserRolesMutationResponse>;
  /** insert a single row into the table: "account_user_roles" */
  insertAccountUserRolesOne?: Maybe<AccountUserRoles>;
  /** insert data into the table: "account_users" */
  insertAccountUsers?: Maybe<AccountUsersMutationResponse>;
  /** insert a single row into the table: "account_users" */
  insertAccountUsersOne?: Maybe<AccountUsers>;
  /** insert data into the table: "accounts" */
  insertAccounts?: Maybe<AccountsMutationResponse>;
  /** insert a single row into the table: "accounts" */
  insertAccountsOne?: Maybe<Accounts>;
  /** insert data into the table: "canvas_items" */
  insertCanvasItems?: Maybe<CanvasItemsMutationResponse>;
  /** insert a single row into the table: "canvas_items" */
  insertCanvasItemsOne?: Maybe<CanvasItems>;
  /** insert data into the table: "db_event_log_types" */
  insertDbEventLogTypes?: Maybe<DbEventLogTypesMutationResponse>;
  /** insert a single row into the table: "db_event_log_types" */
  insertDbEventLogTypesOne?: Maybe<DbEventLogTypes>;
  /** insert data into the table: "db_event_logs" */
  insertDbEventLogs?: Maybe<DbEventLogsMutationResponse>;
  /** insert a single row into the table: "db_event_logs" */
  insertDbEventLogsOne?: Maybe<DbEventLogs>;
  /** insert data into the table: "document_labels" */
  insertDocumentLabels?: Maybe<DocumentLabelsMutationResponse>;
  /** insert a single row into the table: "document_labels" */
  insertDocumentLabelsOne?: Maybe<DocumentLabels>;
  /** insert data into the table: "document_users" */
  insertDocumentUsers?: Maybe<DocumentUsersMutationResponse>;
  /** insert a single row into the table: "document_users" */
  insertDocumentUsersOne?: Maybe<DocumentUsers>;
  /** insert data into the table: "documents" */
  insertDocuments?: Maybe<DocumentsMutationResponse>;
  /** insert a single row into the table: "documents" */
  insertDocumentsOne?: Maybe<Documents>;
  /** insert data into the table: "emails" */
  insertEmails?: Maybe<EmailsMutationResponse>;
  /** insert a single row into the table: "emails" */
  insertEmailsOne?: Maybe<Emails>;
  /** insert data into the table: "file_items" */
  insertFileItems?: Maybe<FileItemsMutationResponse>;
  /** insert a single row into the table: "file_items" */
  insertFileItemsOne?: Maybe<FileItems>;
  /** insert data into the table: "guided_tours" */
  insertGuidedTours?: Maybe<GuidedToursMutationResponse>;
  /** insert a single row into the table: "guided_tours" */
  insertGuidedToursOne?: Maybe<GuidedTours>;
  /** insert data into the table: "items" */
  insertItems?: Maybe<ItemsMutationResponse>;
  /** insert a single row into the table: "items" */
  insertItemsOne?: Maybe<Items>;
  /** insert data into the table: "labels" */
  insertLabels?: Maybe<LabelsMutationResponse>;
  /** insert a single row into the table: "labels" */
  insertLabelsOne?: Maybe<Labels>;
  /** insert data into the table: "lanes" */
  insertLanes?: Maybe<LanesMutationResponse>;
  /** insert a single row into the table: "lanes" */
  insertLanesOne?: Maybe<Lanes>;
  /** insert data into the table: "mentions" */
  insertMentions?: Maybe<MentionsMutationResponse>;
  /** insert a single row into the table: "mentions" */
  insertMentionsOne?: Maybe<Mentions>;
  /** insert data into the table: "message_files" */
  insertMessageFiles?: Maybe<MessageFilesMutationResponse>;
  /** insert a single row into the table: "message_files" */
  insertMessageFilesOne?: Maybe<MessageFiles>;
  /** insert data into the table: "message_users" */
  insertMessageUsers?: Maybe<MessageUsersMutationResponse>;
  /** insert a single row into the table: "message_users" */
  insertMessageUsersOne?: Maybe<MessageUsers>;
  /** insert data into the table: "messages" */
  insertMessages?: Maybe<MessagesMutationResponse>;
  /** insert a single row into the table: "messages" */
  insertMessagesOne?: Maybe<Messages>;
  /** insert data into the table: "my_document_users" */
  insertMyDocumentUsers?: Maybe<MyDocumentUsersMutationResponse>;
  /** insert a single row into the table: "my_document_users" */
  insertMyDocumentUsersOne?: Maybe<MyDocumentUsers>;
  /** insert data into the table: "my_user_info" */
  insertMyUserInfo?: Maybe<MyUserInfoMutationResponse>;
  /** insert a single row into the table: "my_user_info" */
  insertMyUserInfoOne?: Maybe<MyUserInfo>;
  /** insert data into the table: "notifications" */
  insertNotifications?: Maybe<NotificationsMutationResponse>;
  /** insert a single row into the table: "notifications" */
  insertNotificationsOne?: Maybe<Notifications>;
  /** insert data into the table: "pdf_items" */
  insertPdfItems?: Maybe<PdfItemsMutationResponse>;
  /** insert a single row into the table: "pdf_items" */
  insertPdfItemsOne?: Maybe<PdfItems>;
  /** insert data into the table: "project_and_folder_organizers" */
  insertProjectAndFolderOrganizers?: Maybe<ProjectAndFolderOrganizersMutationResponse>;
  /** insert a single row into the table: "project_and_folder_organizers" */
  insertProjectAndFolderOrganizersOne?: Maybe<ProjectAndFolderOrganizers>;
  /** insert data into the table: "project_folders" */
  insertProjectFolders?: Maybe<ProjectFoldersMutationResponse>;
  /** insert a single row into the table: "project_folders" */
  insertProjectFoldersOne?: Maybe<ProjectFolders>;
  /** insert data into the table: "project_users" */
  insertProjectUsers?: Maybe<ProjectUsersMutationResponse>;
  /** insert a single row into the table: "project_users" */
  insertProjectUsersOne?: Maybe<ProjectUsers>;
  /** insert data into the table: "projects" */
  insertProjects?: Maybe<ProjectsMutationResponse>;
  /** insert a single row into the table: "projects" */
  insertProjectsOne?: Maybe<Projects>;
  /** insert data into the table: "reactions" */
  insertReactions?: Maybe<ReactionsMutationResponse>;
  /** insert a single row into the table: "reactions" */
  insertReactionsOne?: Maybe<Reactions>;
  /** insert data into the table: "recordings" */
  insertRecordings?: Maybe<RecordingsMutationResponse>;
  /** insert a single row into the table: "recordings" */
  insertRecordingsOne?: Maybe<Recordings>;
  /** insert data into the table: "site_items" */
  insertSiteItems?: Maybe<SiteItemsMutationResponse>;
  /** insert a single row into the table: "site_items" */
  insertSiteItemsOne?: Maybe<SiteItems>;
  /** insert data into the table: "storage_multi_objects_metadata" */
  insertStorageMultiObjectsMetadata?: Maybe<StorageMultiObjectsMetadataMutationResponse>;
  /** insert a single row into the table: "storage_multi_objects_metadata" */
  insertStorageMultiObjectsMetadataOne?: Maybe<StorageMultiObjectsMetadata>;
  /** insert data into the table: "storage_objects_metadata" */
  insertStorageObjectsMetadata?: Maybe<StorageObjectsMetadataMutationResponse>;
  /** insert a single row into the table: "storage_objects_metadata" */
  insertStorageObjectsMetadataOne?: Maybe<StorageObjectsMetadata>;
  /** insert data into the table: "subscription_statuses" */
  insertSubscriptionStatuses?: Maybe<SubscriptionStatusesMutationResponse>;
  /** insert a single row into the table: "subscription_statuses" */
  insertSubscriptionStatusesOne?: Maybe<SubscriptionStatuses>;
  /** insert data into the table: "subscription_types" */
  insertSubscriptionTypes?: Maybe<SubscriptionTypesMutationResponse>;
  /** insert a single row into the table: "subscription_types" */
  insertSubscriptionTypesOne?: Maybe<SubscriptionTypes>;
  /** insert data into the table: "suggestions" */
  insertSuggestions?: Maybe<SuggestionsMutationResponse>;
  /** insert a single row into the table: "suggestions" */
  insertSuggestionsOne?: Maybe<Suggestions>;
  /** insert data into the table: "text_items" */
  insertTextItems?: Maybe<TextItemsMutationResponse>;
  /** insert a single row into the table: "text_items" */
  insertTextItemsOne?: Maybe<TextItems>;
  /** insert data into the table: "transcriptions" */
  insertTranscriptions?: Maybe<TranscriptionsMutationResponse>;
  /** insert a single row into the table: "transcriptions" */
  insertTranscriptionsOne?: Maybe<Transcriptions>;
  /** insert data into the table: "users" */
  insertUsers?: Maybe<UsersMutationResponse>;
  /** insert a single row into the table: "users" */
  insertUsersOne?: Maybe<Users>;
  /** insert data into the table: "versions" */
  insertVersions?: Maybe<VersionsMutationResponse>;
  /** insert a single row into the table: "versions" */
  insertVersionsOne?: Maybe<Versions>;
  /** insert data into the table: "video_items" */
  insertVideoItems?: Maybe<VideoItemsMutationResponse>;
  /** insert a single row into the table: "video_items" */
  insertVideoItemsOne?: Maybe<VideoItems>;
  takeLivesiteScreenshot?: Maybe<Scalars['Boolean']['output']>;
  /** update data of the table: "account_invoice_stripe_statuses" */
  updateAccountInvoiceStripeStatuses?: Maybe<AccountInvoiceStripeStatusesMutationResponse>;
  /** update single row of the table: "account_invoice_stripe_statuses" */
  updateAccountInvoiceStripeStatusesByPk?: Maybe<AccountInvoiceStripeStatuses>;
  /** update multiples rows of table: "account_invoice_stripe_statuses" */
  updateAccountInvoiceStripeStatusesMany?: Maybe<Array<Maybe<AccountInvoiceStripeStatusesMutationResponse>>>;
  /** update data of the table: "account_invoice_types" */
  updateAccountInvoiceTypes?: Maybe<AccountInvoiceTypesMutationResponse>;
  /** update single row of the table: "account_invoice_types" */
  updateAccountInvoiceTypesByPk?: Maybe<AccountInvoiceTypes>;
  /** update multiples rows of table: "account_invoice_types" */
  updateAccountInvoiceTypesMany?: Maybe<Array<Maybe<AccountInvoiceTypesMutationResponse>>>;
  /** update data of the table: "account_invoices" */
  updateAccountInvoices?: Maybe<AccountInvoicesMutationResponse>;
  /** update single row of the table: "account_invoices" */
  updateAccountInvoicesByPk?: Maybe<AccountInvoices>;
  /** update multiples rows of table: "account_invoices" */
  updateAccountInvoicesMany?: Maybe<Array<Maybe<AccountInvoicesMutationResponse>>>;
  /** update data of the table: "account_user_roles" */
  updateAccountUserRoles?: Maybe<AccountUserRolesMutationResponse>;
  /** update single row of the table: "account_user_roles" */
  updateAccountUserRolesByPk?: Maybe<AccountUserRoles>;
  /** update multiples rows of table: "account_user_roles" */
  updateAccountUserRolesMany?: Maybe<Array<Maybe<AccountUserRolesMutationResponse>>>;
  /** update data of the table: "account_users" */
  updateAccountUsers?: Maybe<AccountUsersMutationResponse>;
  /** update single row of the table: "account_users" */
  updateAccountUsersByPk?: Maybe<AccountUsers>;
  /** update multiples rows of table: "account_users" */
  updateAccountUsersMany?: Maybe<Array<Maybe<AccountUsersMutationResponse>>>;
  /** update data of the table: "accounts" */
  updateAccounts?: Maybe<AccountsMutationResponse>;
  /** update single row of the table: "accounts" */
  updateAccountsByPk?: Maybe<Accounts>;
  /** update multiples rows of table: "accounts" */
  updateAccountsMany?: Maybe<Array<Maybe<AccountsMutationResponse>>>;
  /** update data of the table: "canvas_items" */
  updateCanvasItems?: Maybe<CanvasItemsMutationResponse>;
  /** update single row of the table: "canvas_items" */
  updateCanvasItemsByPk?: Maybe<CanvasItems>;
  /** update multiples rows of table: "canvas_items" */
  updateCanvasItemsMany?: Maybe<Array<Maybe<CanvasItemsMutationResponse>>>;
  /** update data of the table: "db_event_log_types" */
  updateDbEventLogTypes?: Maybe<DbEventLogTypesMutationResponse>;
  /** update single row of the table: "db_event_log_types" */
  updateDbEventLogTypesByPk?: Maybe<DbEventLogTypes>;
  /** update multiples rows of table: "db_event_log_types" */
  updateDbEventLogTypesMany?: Maybe<Array<Maybe<DbEventLogTypesMutationResponse>>>;
  /** update data of the table: "db_event_logs" */
  updateDbEventLogs?: Maybe<DbEventLogsMutationResponse>;
  /** update single row of the table: "db_event_logs" */
  updateDbEventLogsByPk?: Maybe<DbEventLogs>;
  /** update multiples rows of table: "db_event_logs" */
  updateDbEventLogsMany?: Maybe<Array<Maybe<DbEventLogsMutationResponse>>>;
  /** update data of the table: "document_labels" */
  updateDocumentLabels?: Maybe<DocumentLabelsMutationResponse>;
  /** update single row of the table: "document_labels" */
  updateDocumentLabelsByPk?: Maybe<DocumentLabels>;
  /** update multiples rows of table: "document_labels" */
  updateDocumentLabelsMany?: Maybe<Array<Maybe<DocumentLabelsMutationResponse>>>;
  /** update data of the table: "document_users" */
  updateDocumentUsers?: Maybe<DocumentUsersMutationResponse>;
  /** update single row of the table: "document_users" */
  updateDocumentUsersByPk?: Maybe<DocumentUsers>;
  /** update multiples rows of table: "document_users" */
  updateDocumentUsersMany?: Maybe<Array<Maybe<DocumentUsersMutationResponse>>>;
  /** update data of the table: "documents" */
  updateDocuments?: Maybe<DocumentsMutationResponse>;
  /** update single row of the table: "documents" */
  updateDocumentsByPk?: Maybe<Documents>;
  /** update multiples rows of table: "documents" */
  updateDocumentsMany?: Maybe<Array<Maybe<DocumentsMutationResponse>>>;
  /** update data of the table: "emails" */
  updateEmails?: Maybe<EmailsMutationResponse>;
  /** update single row of the table: "emails" */
  updateEmailsByPk?: Maybe<Emails>;
  /** update multiples rows of table: "emails" */
  updateEmailsMany?: Maybe<Array<Maybe<EmailsMutationResponse>>>;
  /** update data of the table: "file_items" */
  updateFileItems?: Maybe<FileItemsMutationResponse>;
  /** update single row of the table: "file_items" */
  updateFileItemsByPk?: Maybe<FileItems>;
  /** update multiples rows of table: "file_items" */
  updateFileItemsMany?: Maybe<Array<Maybe<FileItemsMutationResponse>>>;
  /** update data of the table: "guided_tours" */
  updateGuidedTours?: Maybe<GuidedToursMutationResponse>;
  /** update single row of the table: "guided_tours" */
  updateGuidedToursByPk?: Maybe<GuidedTours>;
  /** update multiples rows of table: "guided_tours" */
  updateGuidedToursMany?: Maybe<Array<Maybe<GuidedToursMutationResponse>>>;
  /** update data of the table: "items" */
  updateItems?: Maybe<ItemsMutationResponse>;
  /** update single row of the table: "items" */
  updateItemsByPk?: Maybe<Items>;
  /** update multiples rows of table: "items" */
  updateItemsMany?: Maybe<Array<Maybe<ItemsMutationResponse>>>;
  /** update data of the table: "labels" */
  updateLabels?: Maybe<LabelsMutationResponse>;
  /** update single row of the table: "labels" */
  updateLabelsByPk?: Maybe<Labels>;
  /** update multiples rows of table: "labels" */
  updateLabelsMany?: Maybe<Array<Maybe<LabelsMutationResponse>>>;
  /** update data of the table: "lanes" */
  updateLanes?: Maybe<LanesMutationResponse>;
  /** update single row of the table: "lanes" */
  updateLanesByPk?: Maybe<Lanes>;
  /** update multiples rows of table: "lanes" */
  updateLanesMany?: Maybe<Array<Maybe<LanesMutationResponse>>>;
  /** update data of the table: "mentions" */
  updateMentions?: Maybe<MentionsMutationResponse>;
  /** update single row of the table: "mentions" */
  updateMentionsByPk?: Maybe<Mentions>;
  /** update multiples rows of table: "mentions" */
  updateMentionsMany?: Maybe<Array<Maybe<MentionsMutationResponse>>>;
  /** update data of the table: "message_files" */
  updateMessageFiles?: Maybe<MessageFilesMutationResponse>;
  /** update single row of the table: "message_files" */
  updateMessageFilesByPk?: Maybe<MessageFiles>;
  /** update multiples rows of table: "message_files" */
  updateMessageFilesMany?: Maybe<Array<Maybe<MessageFilesMutationResponse>>>;
  /** update data of the table: "message_users" */
  updateMessageUsers?: Maybe<MessageUsersMutationResponse>;
  /** update single row of the table: "message_users" */
  updateMessageUsersByPk?: Maybe<MessageUsers>;
  /** update multiples rows of table: "message_users" */
  updateMessageUsersMany?: Maybe<Array<Maybe<MessageUsersMutationResponse>>>;
  /** update data of the table: "messages" */
  updateMessages?: Maybe<MessagesMutationResponse>;
  /** update single row of the table: "messages" */
  updateMessagesByPk?: Maybe<Messages>;
  /** update multiples rows of table: "messages" */
  updateMessagesMany?: Maybe<Array<Maybe<MessagesMutationResponse>>>;
  /** update data of the table: "my_document_users" */
  updateMyDocumentUsers?: Maybe<MyDocumentUsersMutationResponse>;
  /** update multiples rows of table: "my_document_users" */
  updateMyDocumentUsersMany?: Maybe<Array<Maybe<MyDocumentUsersMutationResponse>>>;
  /** update data of the table: "my_user_info" */
  updateMyUserInfo?: Maybe<MyUserInfoMutationResponse>;
  /** update multiples rows of table: "my_user_info" */
  updateMyUserInfoMany?: Maybe<Array<Maybe<MyUserInfoMutationResponse>>>;
  /** update data of the table: "notifications" */
  updateNotifications?: Maybe<NotificationsMutationResponse>;
  /** update single row of the table: "notifications" */
  updateNotificationsByPk?: Maybe<Notifications>;
  /** update multiples rows of table: "notifications" */
  updateNotificationsMany?: Maybe<Array<Maybe<NotificationsMutationResponse>>>;
  /** update data of the table: "pdf_items" */
  updatePdfItems?: Maybe<PdfItemsMutationResponse>;
  /** update single row of the table: "pdf_items" */
  updatePdfItemsByPk?: Maybe<PdfItems>;
  /** update multiples rows of table: "pdf_items" */
  updatePdfItemsMany?: Maybe<Array<Maybe<PdfItemsMutationResponse>>>;
  /** update data of the table: "project_and_folder_organizers" */
  updateProjectAndFolderOrganizers?: Maybe<ProjectAndFolderOrganizersMutationResponse>;
  /** update single row of the table: "project_and_folder_organizers" */
  updateProjectAndFolderOrganizersByPk?: Maybe<ProjectAndFolderOrganizers>;
  /** update multiples rows of table: "project_and_folder_organizers" */
  updateProjectAndFolderOrganizersMany?: Maybe<Array<Maybe<ProjectAndFolderOrganizersMutationResponse>>>;
  /** update data of the table: "project_folders" */
  updateProjectFolders?: Maybe<ProjectFoldersMutationResponse>;
  /** update single row of the table: "project_folders" */
  updateProjectFoldersByPk?: Maybe<ProjectFolders>;
  /** update multiples rows of table: "project_folders" */
  updateProjectFoldersMany?: Maybe<Array<Maybe<ProjectFoldersMutationResponse>>>;
  /** update data of the table: "project_users" */
  updateProjectUsers?: Maybe<ProjectUsersMutationResponse>;
  /** update single row of the table: "project_users" */
  updateProjectUsersByPk?: Maybe<ProjectUsers>;
  /** update multiples rows of table: "project_users" */
  updateProjectUsersMany?: Maybe<Array<Maybe<ProjectUsersMutationResponse>>>;
  /** update data of the table: "projects" */
  updateProjects?: Maybe<ProjectsMutationResponse>;
  /** update single row of the table: "projects" */
  updateProjectsByPk?: Maybe<Projects>;
  /** update multiples rows of table: "projects" */
  updateProjectsMany?: Maybe<Array<Maybe<ProjectsMutationResponse>>>;
  /** update data of the table: "reactions" */
  updateReactions?: Maybe<ReactionsMutationResponse>;
  /** update single row of the table: "reactions" */
  updateReactionsByPk?: Maybe<Reactions>;
  /** update multiples rows of table: "reactions" */
  updateReactionsMany?: Maybe<Array<Maybe<ReactionsMutationResponse>>>;
  /** update data of the table: "recordings" */
  updateRecordings?: Maybe<RecordingsMutationResponse>;
  /** update single row of the table: "recordings" */
  updateRecordingsByPk?: Maybe<Recordings>;
  /** update multiples rows of table: "recordings" */
  updateRecordingsMany?: Maybe<Array<Maybe<RecordingsMutationResponse>>>;
  /** update data of the table: "site_items" */
  updateSiteItems?: Maybe<SiteItemsMutationResponse>;
  /** update single row of the table: "site_items" */
  updateSiteItemsByPk?: Maybe<SiteItems>;
  /** update multiples rows of table: "site_items" */
  updateSiteItemsMany?: Maybe<Array<Maybe<SiteItemsMutationResponse>>>;
  /** update data of the table: "storage_multi_objects_metadata" */
  updateStorageMultiObjectsMetadata?: Maybe<StorageMultiObjectsMetadataMutationResponse>;
  /** update single row of the table: "storage_multi_objects_metadata" */
  updateStorageMultiObjectsMetadataByPk?: Maybe<StorageMultiObjectsMetadata>;
  /** update multiples rows of table: "storage_multi_objects_metadata" */
  updateStorageMultiObjectsMetadataMany?: Maybe<Array<Maybe<StorageMultiObjectsMetadataMutationResponse>>>;
  /** update data of the table: "storage_objects_metadata" */
  updateStorageObjectsMetadata?: Maybe<StorageObjectsMetadataMutationResponse>;
  /** update single row of the table: "storage_objects_metadata" */
  updateStorageObjectsMetadataByPk?: Maybe<StorageObjectsMetadata>;
  /** update multiples rows of table: "storage_objects_metadata" */
  updateStorageObjectsMetadataMany?: Maybe<Array<Maybe<StorageObjectsMetadataMutationResponse>>>;
  /** update data of the table: "subscription_statuses" */
  updateSubscriptionStatuses?: Maybe<SubscriptionStatusesMutationResponse>;
  /** update single row of the table: "subscription_statuses" */
  updateSubscriptionStatusesByPk?: Maybe<SubscriptionStatuses>;
  /** update multiples rows of table: "subscription_statuses" */
  updateSubscriptionStatusesMany?: Maybe<Array<Maybe<SubscriptionStatusesMutationResponse>>>;
  /** update data of the table: "subscription_types" */
  updateSubscriptionTypes?: Maybe<SubscriptionTypesMutationResponse>;
  /** update single row of the table: "subscription_types" */
  updateSubscriptionTypesByPk?: Maybe<SubscriptionTypes>;
  /** update multiples rows of table: "subscription_types" */
  updateSubscriptionTypesMany?: Maybe<Array<Maybe<SubscriptionTypesMutationResponse>>>;
  /** update data of the table: "suggestions" */
  updateSuggestions?: Maybe<SuggestionsMutationResponse>;
  /** update single row of the table: "suggestions" */
  updateSuggestionsByPk?: Maybe<Suggestions>;
  /** update multiples rows of table: "suggestions" */
  updateSuggestionsMany?: Maybe<Array<Maybe<SuggestionsMutationResponse>>>;
  /** update data of the table: "text_items" */
  updateTextItems?: Maybe<TextItemsMutationResponse>;
  /** update single row of the table: "text_items" */
  updateTextItemsByPk?: Maybe<TextItems>;
  /** update multiples rows of table: "text_items" */
  updateTextItemsMany?: Maybe<Array<Maybe<TextItemsMutationResponse>>>;
  /** update data of the table: "transcriptions" */
  updateTranscriptions?: Maybe<TranscriptionsMutationResponse>;
  /** update single row of the table: "transcriptions" */
  updateTranscriptionsByPk?: Maybe<Transcriptions>;
  /** update multiples rows of table: "transcriptions" */
  updateTranscriptionsMany?: Maybe<Array<Maybe<TranscriptionsMutationResponse>>>;
  /** update data of the table: "users" */
  updateUsers?: Maybe<UsersMutationResponse>;
  /** update single row of the table: "users" */
  updateUsersByPk?: Maybe<Users>;
  /** update multiples rows of table: "users" */
  updateUsersMany?: Maybe<Array<Maybe<UsersMutationResponse>>>;
  /** update data of the table: "versions" */
  updateVersions?: Maybe<VersionsMutationResponse>;
  /** update single row of the table: "versions" */
  updateVersionsByPk?: Maybe<Versions>;
  /** update multiples rows of table: "versions" */
  updateVersionsMany?: Maybe<Array<Maybe<VersionsMutationResponse>>>;
  /** update data of the table: "video_items" */
  updateVideoItems?: Maybe<VideoItemsMutationResponse>;
  /** update single row of the table: "video_items" */
  updateVideoItemsByPk?: Maybe<VideoItems>;
  /** update multiples rows of table: "video_items" */
  updateVideoItemsMany?: Maybe<Array<Maybe<VideoItemsMutationResponse>>>;
};


/** mutation root */
export type Mutation_RootCompleteMultipartUploadArgs = {
  args: CompleteMultipartUploadInput;
};


/** mutation root */
export type Mutation_RootCreateDocumentWithVersionBlobsArgs = {
  args: CreateDocumentWithVersionBlobsInput;
};


/** mutation root */
export type Mutation_RootCreateDocumentWithVersionSiteArgs = {
  args: CreateDocumentWithVersionSiteInput;
};


/** mutation root */
export type Mutation_RootCreateDocumentWithVersionSiteAdminArgs = {
  args: CreateDocumentWithVersionSiteAdminInput;
};


/** mutation root */
export type Mutation_RootCreateDocumentWithoutVersionArgs = {
  args: CreateDocumentWithoutVersionInput;
};


/** mutation root */
export type Mutation_RootCreateMessageFileArgs = {
  args: CreateMessageFileInput;
};


/** mutation root */
export type Mutation_RootCreateVersionWithBlobsArgs = {
  args: CreateVersionWithBlobsInput;
};


/** mutation root */
export type Mutation_RootCreateVersionWithSiteArgs = {
  args: CreateVersionWithSiteInput;
};


/** mutation root */
export type Mutation_RootCreateVersionWithTextDocArgs = {
  args: CreateVersionWithTextDoc;
};


/** mutation root */
export type Mutation_RootDeleteAccountInvoiceStripeStatusesArgs = {
  where: AccountInvoiceStripeStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAccountInvoiceStripeStatusesByPkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDeleteAccountInvoiceTypesArgs = {
  where: AccountInvoiceTypesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAccountInvoiceTypesByPkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDeleteAccountInvoicesArgs = {
  where: AccountInvoicesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAccountInvoicesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteAccountUserRolesArgs = {
  where: AccountUserRolesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAccountUserRolesByPkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDeleteAccountUsersArgs = {
  where: AccountUsersBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAccountUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteAccountsArgs = {
  where: AccountsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAccountsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteCanvasItemsArgs = {
  where: CanvasItemsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteCanvasItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteDbEventLogTypesArgs = {
  where: DbEventLogTypesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteDbEventLogTypesByPkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDeleteDbEventLogsArgs = {
  where: DbEventLogsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteDbEventLogsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteDocumentLabelsArgs = {
  where: DocumentLabelsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteDocumentLabelsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteDocumentUsersArgs = {
  where: DocumentUsersBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteDocumentUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteDocumentsArgs = {
  where: DocumentsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteDocumentsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteEmailsArgs = {
  where: EmailsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEmailsByPkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDeleteFileItemsArgs = {
  where: FileItemsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteFileItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteGuidedToursArgs = {
  where: GuidedToursBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteGuidedToursByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteItemsArgs = {
  where: ItemsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteLabelsArgs = {
  where: LabelsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLabelsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteLanesArgs = {
  where: LanesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLanesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteMentionsArgs = {
  where: MentionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteMentionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteMessageFilesArgs = {
  where: MessageFilesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteMessageFilesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteMessageUsersArgs = {
  where: MessageUsersBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteMessageUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteMessagesArgs = {
  where: MessagesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteMessagesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteMyDocumentUsersArgs = {
  where: MyDocumentUsersBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteMyUserInfoArgs = {
  where: MyUserInfoBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteNotificationsArgs = {
  where: NotificationsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteNotificationsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePdfItemsArgs = {
  where: PdfItemsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePdfItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteProjectAndFolderOrganizersArgs = {
  where: ProjectAndFolderOrganizersBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteProjectAndFolderOrganizersByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteProjectFoldersArgs = {
  where: ProjectFoldersBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteProjectFoldersByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteProjectUsersArgs = {
  where: ProjectUsersBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteProjectUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteProjectsArgs = {
  where: ProjectsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteProjectsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteReactionsArgs = {
  where: ReactionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteReactionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteRecordingsArgs = {
  where: RecordingsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteRecordingsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSiteItemsArgs = {
  where: SiteItemsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteSiteItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteStorageMultiObjectsMetadataArgs = {
  where: StorageMultiObjectsMetadataBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteStorageMultiObjectsMetadataByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteStorageObjectsMetadataArgs = {
  where: StorageObjectsMetadataBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteStorageObjectsMetadataByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSubscriptionStatusesArgs = {
  where: SubscriptionStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteSubscriptionStatusesByPkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSubscriptionTypesArgs = {
  where: SubscriptionTypesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteSubscriptionTypesByPkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSuggestionsArgs = {
  where: SuggestionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteSuggestionsByPkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDeleteTextItemsArgs = {
  where: TextItemsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteTextItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteTranscriptionsArgs = {
  where: TranscriptionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteTranscriptionsByPkArgs = {
  id: Scalars['bigint']['input'];
};


/** mutation root */
export type Mutation_RootDeleteUsersArgs = {
  where: UsersBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteVersionsArgs = {
  where: VersionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteVersionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteVideoItemsArgs = {
  where: VideoItemsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteVideoItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDuplicateDocumentArgs = {
  args: DuplicateDocumentInput;
};


/** mutation root */
export type Mutation_RootGetPresignedUrlForMultipartUploadArgs = {
  args: GetPresignedUrlForMultipartUploadInput;
};


/** mutation root */
export type Mutation_RootInsertAccountInvoiceStripeStatusesArgs = {
  objects: Array<AccountInvoiceStripeStatusesInsertInput>;
  onConflict?: InputMaybe<AccountInvoiceStripeStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAccountInvoiceStripeStatusesOneArgs = {
  object: AccountInvoiceStripeStatusesInsertInput;
  onConflict?: InputMaybe<AccountInvoiceStripeStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAccountInvoiceTypesArgs = {
  objects: Array<AccountInvoiceTypesInsertInput>;
  onConflict?: InputMaybe<AccountInvoiceTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAccountInvoiceTypesOneArgs = {
  object: AccountInvoiceTypesInsertInput;
  onConflict?: InputMaybe<AccountInvoiceTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAccountInvoicesArgs = {
  objects: Array<AccountInvoicesInsertInput>;
  onConflict?: InputMaybe<AccountInvoicesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAccountInvoicesOneArgs = {
  object: AccountInvoicesInsertInput;
  onConflict?: InputMaybe<AccountInvoicesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAccountUserRolesArgs = {
  objects: Array<AccountUserRolesInsertInput>;
  onConflict?: InputMaybe<AccountUserRolesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAccountUserRolesOneArgs = {
  object: AccountUserRolesInsertInput;
  onConflict?: InputMaybe<AccountUserRolesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAccountUsersArgs = {
  objects: Array<AccountUsersInsertInput>;
  onConflict?: InputMaybe<AccountUsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAccountUsersOneArgs = {
  object: AccountUsersInsertInput;
  onConflict?: InputMaybe<AccountUsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAccountsArgs = {
  objects: Array<AccountsInsertInput>;
  onConflict?: InputMaybe<AccountsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAccountsOneArgs = {
  object: AccountsInsertInput;
  onConflict?: InputMaybe<AccountsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCanvasItemsArgs = {
  objects: Array<CanvasItemsInsertInput>;
  onConflict?: InputMaybe<CanvasItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertCanvasItemsOneArgs = {
  object: CanvasItemsInsertInput;
  onConflict?: InputMaybe<CanvasItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertDbEventLogTypesArgs = {
  objects: Array<DbEventLogTypesInsertInput>;
  onConflict?: InputMaybe<DbEventLogTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertDbEventLogTypesOneArgs = {
  object: DbEventLogTypesInsertInput;
  onConflict?: InputMaybe<DbEventLogTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertDbEventLogsArgs = {
  objects: Array<DbEventLogsInsertInput>;
  onConflict?: InputMaybe<DbEventLogsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertDbEventLogsOneArgs = {
  object: DbEventLogsInsertInput;
  onConflict?: InputMaybe<DbEventLogsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertDocumentLabelsArgs = {
  objects: Array<DocumentLabelsInsertInput>;
  onConflict?: InputMaybe<DocumentLabelsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertDocumentLabelsOneArgs = {
  object: DocumentLabelsInsertInput;
  onConflict?: InputMaybe<DocumentLabelsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertDocumentUsersArgs = {
  objects: Array<DocumentUsersInsertInput>;
  onConflict?: InputMaybe<DocumentUsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertDocumentUsersOneArgs = {
  object: DocumentUsersInsertInput;
  onConflict?: InputMaybe<DocumentUsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertDocumentsArgs = {
  objects: Array<DocumentsInsertInput>;
  onConflict?: InputMaybe<DocumentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertDocumentsOneArgs = {
  object: DocumentsInsertInput;
  onConflict?: InputMaybe<DocumentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEmailsArgs = {
  objects: Array<EmailsInsertInput>;
  onConflict?: InputMaybe<EmailsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEmailsOneArgs = {
  object: EmailsInsertInput;
  onConflict?: InputMaybe<EmailsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertFileItemsArgs = {
  objects: Array<FileItemsInsertInput>;
  onConflict?: InputMaybe<FileItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertFileItemsOneArgs = {
  object: FileItemsInsertInput;
  onConflict?: InputMaybe<FileItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGuidedToursArgs = {
  objects: Array<GuidedToursInsertInput>;
  onConflict?: InputMaybe<GuidedToursOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertGuidedToursOneArgs = {
  object: GuidedToursInsertInput;
  onConflict?: InputMaybe<GuidedToursOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertItemsArgs = {
  objects: Array<ItemsInsertInput>;
  onConflict?: InputMaybe<ItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertItemsOneArgs = {
  object: ItemsInsertInput;
  onConflict?: InputMaybe<ItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLabelsArgs = {
  objects: Array<LabelsInsertInput>;
  onConflict?: InputMaybe<LabelsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLabelsOneArgs = {
  object: LabelsInsertInput;
  onConflict?: InputMaybe<LabelsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLanesArgs = {
  objects: Array<LanesInsertInput>;
  onConflict?: InputMaybe<LanesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLanesOneArgs = {
  object: LanesInsertInput;
  onConflict?: InputMaybe<LanesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertMentionsArgs = {
  objects: Array<MentionsInsertInput>;
  onConflict?: InputMaybe<MentionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertMentionsOneArgs = {
  object: MentionsInsertInput;
  onConflict?: InputMaybe<MentionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertMessageFilesArgs = {
  objects: Array<MessageFilesInsertInput>;
  onConflict?: InputMaybe<MessageFilesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertMessageFilesOneArgs = {
  object: MessageFilesInsertInput;
  onConflict?: InputMaybe<MessageFilesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertMessageUsersArgs = {
  objects: Array<MessageUsersInsertInput>;
  onConflict?: InputMaybe<MessageUsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertMessageUsersOneArgs = {
  object: MessageUsersInsertInput;
  onConflict?: InputMaybe<MessageUsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertMessagesArgs = {
  objects: Array<MessagesInsertInput>;
  onConflict?: InputMaybe<MessagesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertMessagesOneArgs = {
  object: MessagesInsertInput;
  onConflict?: InputMaybe<MessagesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertMyDocumentUsersArgs = {
  objects: Array<MyDocumentUsersInsertInput>;
};


/** mutation root */
export type Mutation_RootInsertMyDocumentUsersOneArgs = {
  object: MyDocumentUsersInsertInput;
};


/** mutation root */
export type Mutation_RootInsertMyUserInfoArgs = {
  objects: Array<MyUserInfoInsertInput>;
};


/** mutation root */
export type Mutation_RootInsertMyUserInfoOneArgs = {
  object: MyUserInfoInsertInput;
};


/** mutation root */
export type Mutation_RootInsertNotificationsArgs = {
  objects: Array<NotificationsInsertInput>;
  onConflict?: InputMaybe<NotificationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertNotificationsOneArgs = {
  object: NotificationsInsertInput;
  onConflict?: InputMaybe<NotificationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPdfItemsArgs = {
  objects: Array<PdfItemsInsertInput>;
  onConflict?: InputMaybe<PdfItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPdfItemsOneArgs = {
  object: PdfItemsInsertInput;
  onConflict?: InputMaybe<PdfItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertProjectAndFolderOrganizersArgs = {
  objects: Array<ProjectAndFolderOrganizersInsertInput>;
  onConflict?: InputMaybe<ProjectAndFolderOrganizersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertProjectAndFolderOrganizersOneArgs = {
  object: ProjectAndFolderOrganizersInsertInput;
  onConflict?: InputMaybe<ProjectAndFolderOrganizersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertProjectFoldersArgs = {
  objects: Array<ProjectFoldersInsertInput>;
  onConflict?: InputMaybe<ProjectFoldersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertProjectFoldersOneArgs = {
  object: ProjectFoldersInsertInput;
  onConflict?: InputMaybe<ProjectFoldersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertProjectUsersArgs = {
  objects: Array<ProjectUsersInsertInput>;
  onConflict?: InputMaybe<ProjectUsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertProjectUsersOneArgs = {
  object: ProjectUsersInsertInput;
  onConflict?: InputMaybe<ProjectUsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertProjectsArgs = {
  objects: Array<ProjectsInsertInput>;
  onConflict?: InputMaybe<ProjectsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertProjectsOneArgs = {
  object: ProjectsInsertInput;
  onConflict?: InputMaybe<ProjectsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertReactionsArgs = {
  objects: Array<ReactionsInsertInput>;
  onConflict?: InputMaybe<ReactionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertReactionsOneArgs = {
  object: ReactionsInsertInput;
  onConflict?: InputMaybe<ReactionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertRecordingsArgs = {
  objects: Array<RecordingsInsertInput>;
  onConflict?: InputMaybe<RecordingsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertRecordingsOneArgs = {
  object: RecordingsInsertInput;
  onConflict?: InputMaybe<RecordingsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSiteItemsArgs = {
  objects: Array<SiteItemsInsertInput>;
  onConflict?: InputMaybe<SiteItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSiteItemsOneArgs = {
  object: SiteItemsInsertInput;
  onConflict?: InputMaybe<SiteItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertStorageMultiObjectsMetadataArgs = {
  objects: Array<StorageMultiObjectsMetadataInsertInput>;
  onConflict?: InputMaybe<StorageMultiObjectsMetadataOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertStorageMultiObjectsMetadataOneArgs = {
  object: StorageMultiObjectsMetadataInsertInput;
  onConflict?: InputMaybe<StorageMultiObjectsMetadataOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertStorageObjectsMetadataArgs = {
  objects: Array<StorageObjectsMetadataInsertInput>;
  onConflict?: InputMaybe<StorageObjectsMetadataOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertStorageObjectsMetadataOneArgs = {
  object: StorageObjectsMetadataInsertInput;
  onConflict?: InputMaybe<StorageObjectsMetadataOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSubscriptionStatusesArgs = {
  objects: Array<SubscriptionStatusesInsertInput>;
  onConflict?: InputMaybe<SubscriptionStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSubscriptionStatusesOneArgs = {
  object: SubscriptionStatusesInsertInput;
  onConflict?: InputMaybe<SubscriptionStatusesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSubscriptionTypesArgs = {
  objects: Array<SubscriptionTypesInsertInput>;
  onConflict?: InputMaybe<SubscriptionTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSubscriptionTypesOneArgs = {
  object: SubscriptionTypesInsertInput;
  onConflict?: InputMaybe<SubscriptionTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSuggestionsArgs = {
  objects: Array<SuggestionsInsertInput>;
  onConflict?: InputMaybe<SuggestionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSuggestionsOneArgs = {
  object: SuggestionsInsertInput;
  onConflict?: InputMaybe<SuggestionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertTextItemsArgs = {
  objects: Array<TextItemsInsertInput>;
  onConflict?: InputMaybe<TextItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertTextItemsOneArgs = {
  object: TextItemsInsertInput;
  onConflict?: InputMaybe<TextItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertTranscriptionsArgs = {
  objects: Array<TranscriptionsInsertInput>;
  onConflict?: InputMaybe<TranscriptionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertTranscriptionsOneArgs = {
  object: TranscriptionsInsertInput;
  onConflict?: InputMaybe<TranscriptionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsersArgs = {
  objects: Array<UsersInsertInput>;
  onConflict?: InputMaybe<UsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsersOneArgs = {
  object: UsersInsertInput;
  onConflict?: InputMaybe<UsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVersionsArgs = {
  objects: Array<VersionsInsertInput>;
  onConflict?: InputMaybe<VersionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVersionsOneArgs = {
  object: VersionsInsertInput;
  onConflict?: InputMaybe<VersionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVideoItemsArgs = {
  objects: Array<VideoItemsInsertInput>;
  onConflict?: InputMaybe<VideoItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertVideoItemsOneArgs = {
  object: VideoItemsInsertInput;
  onConflict?: InputMaybe<VideoItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootTakeLivesiteScreenshotArgs = {
  input: LiveSitescreenshotInput;
};


/** mutation root */
export type Mutation_RootUpdateAccountInvoiceStripeStatusesArgs = {
  _set?: InputMaybe<AccountInvoiceStripeStatusesSetInput>;
  where: AccountInvoiceStripeStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAccountInvoiceStripeStatusesByPkArgs = {
  _set?: InputMaybe<AccountInvoiceStripeStatusesSetInput>;
  pkColumns: AccountInvoiceStripeStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAccountInvoiceStripeStatusesManyArgs = {
  updates: Array<AccountInvoiceStripeStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAccountInvoiceTypesArgs = {
  _set?: InputMaybe<AccountInvoiceTypesSetInput>;
  where: AccountInvoiceTypesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAccountInvoiceTypesByPkArgs = {
  _set?: InputMaybe<AccountInvoiceTypesSetInput>;
  pkColumns: AccountInvoiceTypesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAccountInvoiceTypesManyArgs = {
  updates: Array<AccountInvoiceTypesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAccountInvoicesArgs = {
  _inc?: InputMaybe<AccountInvoicesIncInput>;
  _set?: InputMaybe<AccountInvoicesSetInput>;
  where: AccountInvoicesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAccountInvoicesByPkArgs = {
  _inc?: InputMaybe<AccountInvoicesIncInput>;
  _set?: InputMaybe<AccountInvoicesSetInput>;
  pkColumns: AccountInvoicesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAccountInvoicesManyArgs = {
  updates: Array<AccountInvoicesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAccountUserRolesArgs = {
  _set?: InputMaybe<AccountUserRolesSetInput>;
  where: AccountUserRolesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAccountUserRolesByPkArgs = {
  _set?: InputMaybe<AccountUserRolesSetInput>;
  pkColumns: AccountUserRolesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAccountUserRolesManyArgs = {
  updates: Array<AccountUserRolesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAccountUsersArgs = {
  _append?: InputMaybe<AccountUsersAppendInput>;
  _deleteAtPath?: InputMaybe<AccountUsersDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AccountUsersDeleteElemInput>;
  _deleteKey?: InputMaybe<AccountUsersDeleteKeyInput>;
  _inc?: InputMaybe<AccountUsersIncInput>;
  _prepend?: InputMaybe<AccountUsersPrependInput>;
  _set?: InputMaybe<AccountUsersSetInput>;
  where: AccountUsersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAccountUsersByPkArgs = {
  _append?: InputMaybe<AccountUsersAppendInput>;
  _deleteAtPath?: InputMaybe<AccountUsersDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AccountUsersDeleteElemInput>;
  _deleteKey?: InputMaybe<AccountUsersDeleteKeyInput>;
  _inc?: InputMaybe<AccountUsersIncInput>;
  _prepend?: InputMaybe<AccountUsersPrependInput>;
  _set?: InputMaybe<AccountUsersSetInput>;
  pkColumns: AccountUsersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAccountUsersManyArgs = {
  updates: Array<AccountUsersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAccountsArgs = {
  _append?: InputMaybe<AccountsAppendInput>;
  _deleteAtPath?: InputMaybe<AccountsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AccountsDeleteElemInput>;
  _deleteKey?: InputMaybe<AccountsDeleteKeyInput>;
  _inc?: InputMaybe<AccountsIncInput>;
  _prepend?: InputMaybe<AccountsPrependInput>;
  _set?: InputMaybe<AccountsSetInput>;
  where: AccountsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAccountsByPkArgs = {
  _append?: InputMaybe<AccountsAppendInput>;
  _deleteAtPath?: InputMaybe<AccountsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AccountsDeleteElemInput>;
  _deleteKey?: InputMaybe<AccountsDeleteKeyInput>;
  _inc?: InputMaybe<AccountsIncInput>;
  _prepend?: InputMaybe<AccountsPrependInput>;
  _set?: InputMaybe<AccountsSetInput>;
  pkColumns: AccountsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAccountsManyArgs = {
  updates: Array<AccountsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateCanvasItemsArgs = {
  _inc?: InputMaybe<CanvasItemsIncInput>;
  _set?: InputMaybe<CanvasItemsSetInput>;
  where: CanvasItemsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateCanvasItemsByPkArgs = {
  _inc?: InputMaybe<CanvasItemsIncInput>;
  _set?: InputMaybe<CanvasItemsSetInput>;
  pkColumns: CanvasItemsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateCanvasItemsManyArgs = {
  updates: Array<CanvasItemsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateDbEventLogTypesArgs = {
  _set?: InputMaybe<DbEventLogTypesSetInput>;
  where: DbEventLogTypesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateDbEventLogTypesByPkArgs = {
  _set?: InputMaybe<DbEventLogTypesSetInput>;
  pkColumns: DbEventLogTypesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateDbEventLogTypesManyArgs = {
  updates: Array<DbEventLogTypesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateDbEventLogsArgs = {
  _append?: InputMaybe<DbEventLogsAppendInput>;
  _deleteAtPath?: InputMaybe<DbEventLogsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<DbEventLogsDeleteElemInput>;
  _deleteKey?: InputMaybe<DbEventLogsDeleteKeyInput>;
  _prepend?: InputMaybe<DbEventLogsPrependInput>;
  _set?: InputMaybe<DbEventLogsSetInput>;
  where: DbEventLogsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateDbEventLogsByPkArgs = {
  _append?: InputMaybe<DbEventLogsAppendInput>;
  _deleteAtPath?: InputMaybe<DbEventLogsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<DbEventLogsDeleteElemInput>;
  _deleteKey?: InputMaybe<DbEventLogsDeleteKeyInput>;
  _prepend?: InputMaybe<DbEventLogsPrependInput>;
  _set?: InputMaybe<DbEventLogsSetInput>;
  pkColumns: DbEventLogsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateDbEventLogsManyArgs = {
  updates: Array<DbEventLogsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateDocumentLabelsArgs = {
  _inc?: InputMaybe<DocumentLabelsIncInput>;
  _set?: InputMaybe<DocumentLabelsSetInput>;
  where: DocumentLabelsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateDocumentLabelsByPkArgs = {
  _inc?: InputMaybe<DocumentLabelsIncInput>;
  _set?: InputMaybe<DocumentLabelsSetInput>;
  pkColumns: DocumentLabelsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateDocumentLabelsManyArgs = {
  updates: Array<DocumentLabelsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateDocumentUsersArgs = {
  _inc?: InputMaybe<DocumentUsersIncInput>;
  _set?: InputMaybe<DocumentUsersSetInput>;
  where: DocumentUsersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateDocumentUsersByPkArgs = {
  _inc?: InputMaybe<DocumentUsersIncInput>;
  _set?: InputMaybe<DocumentUsersSetInput>;
  pkColumns: DocumentUsersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateDocumentUsersManyArgs = {
  updates: Array<DocumentUsersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateDocumentsArgs = {
  _append?: InputMaybe<DocumentsAppendInput>;
  _deleteAtPath?: InputMaybe<DocumentsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<DocumentsDeleteElemInput>;
  _deleteKey?: InputMaybe<DocumentsDeleteKeyInput>;
  _inc?: InputMaybe<DocumentsIncInput>;
  _prepend?: InputMaybe<DocumentsPrependInput>;
  _set?: InputMaybe<DocumentsSetInput>;
  where: DocumentsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateDocumentsByPkArgs = {
  _append?: InputMaybe<DocumentsAppendInput>;
  _deleteAtPath?: InputMaybe<DocumentsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<DocumentsDeleteElemInput>;
  _deleteKey?: InputMaybe<DocumentsDeleteKeyInput>;
  _inc?: InputMaybe<DocumentsIncInput>;
  _prepend?: InputMaybe<DocumentsPrependInput>;
  _set?: InputMaybe<DocumentsSetInput>;
  pkColumns: DocumentsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateDocumentsManyArgs = {
  updates: Array<DocumentsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEmailsArgs = {
  _inc?: InputMaybe<EmailsIncInput>;
  _set?: InputMaybe<EmailsSetInput>;
  where: EmailsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEmailsByPkArgs = {
  _inc?: InputMaybe<EmailsIncInput>;
  _set?: InputMaybe<EmailsSetInput>;
  pkColumns: EmailsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEmailsManyArgs = {
  updates: Array<EmailsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateFileItemsArgs = {
  _inc?: InputMaybe<FileItemsIncInput>;
  _set?: InputMaybe<FileItemsSetInput>;
  where: FileItemsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateFileItemsByPkArgs = {
  _inc?: InputMaybe<FileItemsIncInput>;
  _set?: InputMaybe<FileItemsSetInput>;
  pkColumns: FileItemsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateFileItemsManyArgs = {
  updates: Array<FileItemsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateGuidedToursArgs = {
  _set?: InputMaybe<GuidedToursSetInput>;
  where: GuidedToursBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateGuidedToursByPkArgs = {
  _set?: InputMaybe<GuidedToursSetInput>;
  pkColumns: GuidedToursPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateGuidedToursManyArgs = {
  updates: Array<GuidedToursUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateItemsArgs = {
  _inc?: InputMaybe<ItemsIncInput>;
  _set?: InputMaybe<ItemsSetInput>;
  where: ItemsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateItemsByPkArgs = {
  _inc?: InputMaybe<ItemsIncInput>;
  _set?: InputMaybe<ItemsSetInput>;
  pkColumns: ItemsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateItemsManyArgs = {
  updates: Array<ItemsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLabelsArgs = {
  _inc?: InputMaybe<LabelsIncInput>;
  _set?: InputMaybe<LabelsSetInput>;
  where: LabelsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLabelsByPkArgs = {
  _inc?: InputMaybe<LabelsIncInput>;
  _set?: InputMaybe<LabelsSetInput>;
  pkColumns: LabelsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLabelsManyArgs = {
  updates: Array<LabelsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLanesArgs = {
  _inc?: InputMaybe<LanesIncInput>;
  _set?: InputMaybe<LanesSetInput>;
  where: LanesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLanesByPkArgs = {
  _inc?: InputMaybe<LanesIncInput>;
  _set?: InputMaybe<LanesSetInput>;
  pkColumns: LanesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLanesManyArgs = {
  updates: Array<LanesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateMentionsArgs = {
  _set?: InputMaybe<MentionsSetInput>;
  where: MentionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateMentionsByPkArgs = {
  _set?: InputMaybe<MentionsSetInput>;
  pkColumns: MentionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateMentionsManyArgs = {
  updates: Array<MentionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateMessageFilesArgs = {
  _inc?: InputMaybe<MessageFilesIncInput>;
  _set?: InputMaybe<MessageFilesSetInput>;
  where: MessageFilesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateMessageFilesByPkArgs = {
  _inc?: InputMaybe<MessageFilesIncInput>;
  _set?: InputMaybe<MessageFilesSetInput>;
  pkColumns: MessageFilesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateMessageFilesManyArgs = {
  updates: Array<MessageFilesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateMessageUsersArgs = {
  _inc?: InputMaybe<MessageUsersIncInput>;
  _set?: InputMaybe<MessageUsersSetInput>;
  where: MessageUsersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateMessageUsersByPkArgs = {
  _inc?: InputMaybe<MessageUsersIncInput>;
  _set?: InputMaybe<MessageUsersSetInput>;
  pkColumns: MessageUsersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateMessageUsersManyArgs = {
  updates: Array<MessageUsersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateMessagesArgs = {
  _append?: InputMaybe<MessagesAppendInput>;
  _deleteAtPath?: InputMaybe<MessagesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<MessagesDeleteElemInput>;
  _deleteKey?: InputMaybe<MessagesDeleteKeyInput>;
  _inc?: InputMaybe<MessagesIncInput>;
  _prepend?: InputMaybe<MessagesPrependInput>;
  _set?: InputMaybe<MessagesSetInput>;
  where: MessagesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateMessagesByPkArgs = {
  _append?: InputMaybe<MessagesAppendInput>;
  _deleteAtPath?: InputMaybe<MessagesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<MessagesDeleteElemInput>;
  _deleteKey?: InputMaybe<MessagesDeleteKeyInput>;
  _inc?: InputMaybe<MessagesIncInput>;
  _prepend?: InputMaybe<MessagesPrependInput>;
  _set?: InputMaybe<MessagesSetInput>;
  pkColumns: MessagesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateMessagesManyArgs = {
  updates: Array<MessagesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateMyDocumentUsersArgs = {
  _set?: InputMaybe<MyDocumentUsersSetInput>;
  where: MyDocumentUsersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateMyDocumentUsersManyArgs = {
  updates: Array<MyDocumentUsersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateMyUserInfoArgs = {
  _set?: InputMaybe<MyUserInfoSetInput>;
  where: MyUserInfoBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateMyUserInfoManyArgs = {
  updates: Array<MyUserInfoUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateNotificationsArgs = {
  _append?: InputMaybe<NotificationsAppendInput>;
  _deleteAtPath?: InputMaybe<NotificationsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<NotificationsDeleteElemInput>;
  _deleteKey?: InputMaybe<NotificationsDeleteKeyInput>;
  _inc?: InputMaybe<NotificationsIncInput>;
  _prepend?: InputMaybe<NotificationsPrependInput>;
  _set?: InputMaybe<NotificationsSetInput>;
  where: NotificationsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateNotificationsByPkArgs = {
  _append?: InputMaybe<NotificationsAppendInput>;
  _deleteAtPath?: InputMaybe<NotificationsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<NotificationsDeleteElemInput>;
  _deleteKey?: InputMaybe<NotificationsDeleteKeyInput>;
  _inc?: InputMaybe<NotificationsIncInput>;
  _prepend?: InputMaybe<NotificationsPrependInput>;
  _set?: InputMaybe<NotificationsSetInput>;
  pkColumns: NotificationsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateNotificationsManyArgs = {
  updates: Array<NotificationsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePdfItemsArgs = {
  _append?: InputMaybe<PdfItemsAppendInput>;
  _deleteAtPath?: InputMaybe<PdfItemsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<PdfItemsDeleteElemInput>;
  _deleteKey?: InputMaybe<PdfItemsDeleteKeyInput>;
  _prepend?: InputMaybe<PdfItemsPrependInput>;
  _set?: InputMaybe<PdfItemsSetInput>;
  where: PdfItemsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePdfItemsByPkArgs = {
  _append?: InputMaybe<PdfItemsAppendInput>;
  _deleteAtPath?: InputMaybe<PdfItemsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<PdfItemsDeleteElemInput>;
  _deleteKey?: InputMaybe<PdfItemsDeleteKeyInput>;
  _prepend?: InputMaybe<PdfItemsPrependInput>;
  _set?: InputMaybe<PdfItemsSetInput>;
  pkColumns: PdfItemsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePdfItemsManyArgs = {
  updates: Array<PdfItemsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateProjectAndFolderOrganizersArgs = {
  _inc?: InputMaybe<ProjectAndFolderOrganizersIncInput>;
  _set?: InputMaybe<ProjectAndFolderOrganizersSetInput>;
  where: ProjectAndFolderOrganizersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateProjectAndFolderOrganizersByPkArgs = {
  _inc?: InputMaybe<ProjectAndFolderOrganizersIncInput>;
  _set?: InputMaybe<ProjectAndFolderOrganizersSetInput>;
  pkColumns: ProjectAndFolderOrganizersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateProjectAndFolderOrganizersManyArgs = {
  updates: Array<ProjectAndFolderOrganizersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateProjectFoldersArgs = {
  _inc?: InputMaybe<ProjectFoldersIncInput>;
  _set?: InputMaybe<ProjectFoldersSetInput>;
  where: ProjectFoldersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateProjectFoldersByPkArgs = {
  _inc?: InputMaybe<ProjectFoldersIncInput>;
  _set?: InputMaybe<ProjectFoldersSetInput>;
  pkColumns: ProjectFoldersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateProjectFoldersManyArgs = {
  updates: Array<ProjectFoldersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateProjectUsersArgs = {
  _inc?: InputMaybe<ProjectUsersIncInput>;
  _set?: InputMaybe<ProjectUsersSetInput>;
  where: ProjectUsersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateProjectUsersByPkArgs = {
  _inc?: InputMaybe<ProjectUsersIncInput>;
  _set?: InputMaybe<ProjectUsersSetInput>;
  pkColumns: ProjectUsersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateProjectUsersManyArgs = {
  updates: Array<ProjectUsersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateProjectsArgs = {
  _append?: InputMaybe<ProjectsAppendInput>;
  _deleteAtPath?: InputMaybe<ProjectsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<ProjectsDeleteElemInput>;
  _deleteKey?: InputMaybe<ProjectsDeleteKeyInput>;
  _inc?: InputMaybe<ProjectsIncInput>;
  _prepend?: InputMaybe<ProjectsPrependInput>;
  _set?: InputMaybe<ProjectsSetInput>;
  where: ProjectsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateProjectsByPkArgs = {
  _append?: InputMaybe<ProjectsAppendInput>;
  _deleteAtPath?: InputMaybe<ProjectsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<ProjectsDeleteElemInput>;
  _deleteKey?: InputMaybe<ProjectsDeleteKeyInput>;
  _inc?: InputMaybe<ProjectsIncInput>;
  _prepend?: InputMaybe<ProjectsPrependInput>;
  _set?: InputMaybe<ProjectsSetInput>;
  pkColumns: ProjectsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateProjectsManyArgs = {
  updates: Array<ProjectsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateReactionsArgs = {
  _inc?: InputMaybe<ReactionsIncInput>;
  _set?: InputMaybe<ReactionsSetInput>;
  where: ReactionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateReactionsByPkArgs = {
  _inc?: InputMaybe<ReactionsIncInput>;
  _set?: InputMaybe<ReactionsSetInput>;
  pkColumns: ReactionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateReactionsManyArgs = {
  updates: Array<ReactionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateRecordingsArgs = {
  _append?: InputMaybe<RecordingsAppendInput>;
  _deleteAtPath?: InputMaybe<RecordingsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<RecordingsDeleteElemInput>;
  _deleteKey?: InputMaybe<RecordingsDeleteKeyInput>;
  _inc?: InputMaybe<RecordingsIncInput>;
  _prepend?: InputMaybe<RecordingsPrependInput>;
  _set?: InputMaybe<RecordingsSetInput>;
  where: RecordingsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateRecordingsByPkArgs = {
  _append?: InputMaybe<RecordingsAppendInput>;
  _deleteAtPath?: InputMaybe<RecordingsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<RecordingsDeleteElemInput>;
  _deleteKey?: InputMaybe<RecordingsDeleteKeyInput>;
  _inc?: InputMaybe<RecordingsIncInput>;
  _prepend?: InputMaybe<RecordingsPrependInput>;
  _set?: InputMaybe<RecordingsSetInput>;
  pkColumns: RecordingsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateRecordingsManyArgs = {
  updates: Array<RecordingsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateSiteItemsArgs = {
  _inc?: InputMaybe<SiteItemsIncInput>;
  _set?: InputMaybe<SiteItemsSetInput>;
  where: SiteItemsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateSiteItemsByPkArgs = {
  _inc?: InputMaybe<SiteItemsIncInput>;
  _set?: InputMaybe<SiteItemsSetInput>;
  pkColumns: SiteItemsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateSiteItemsManyArgs = {
  updates: Array<SiteItemsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateStorageMultiObjectsMetadataArgs = {
  _set?: InputMaybe<StorageMultiObjectsMetadataSetInput>;
  where: StorageMultiObjectsMetadataBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateStorageMultiObjectsMetadataByPkArgs = {
  _set?: InputMaybe<StorageMultiObjectsMetadataSetInput>;
  pkColumns: StorageMultiObjectsMetadataPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateStorageMultiObjectsMetadataManyArgs = {
  updates: Array<StorageMultiObjectsMetadataUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateStorageObjectsMetadataArgs = {
  _inc?: InputMaybe<StorageObjectsMetadataIncInput>;
  _set?: InputMaybe<StorageObjectsMetadataSetInput>;
  where: StorageObjectsMetadataBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateStorageObjectsMetadataByPkArgs = {
  _inc?: InputMaybe<StorageObjectsMetadataIncInput>;
  _set?: InputMaybe<StorageObjectsMetadataSetInput>;
  pkColumns: StorageObjectsMetadataPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateStorageObjectsMetadataManyArgs = {
  updates: Array<StorageObjectsMetadataUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateSubscriptionStatusesArgs = {
  _set?: InputMaybe<SubscriptionStatusesSetInput>;
  where: SubscriptionStatusesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateSubscriptionStatusesByPkArgs = {
  _set?: InputMaybe<SubscriptionStatusesSetInput>;
  pkColumns: SubscriptionStatusesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateSubscriptionStatusesManyArgs = {
  updates: Array<SubscriptionStatusesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateSubscriptionTypesArgs = {
  _set?: InputMaybe<SubscriptionTypesSetInput>;
  where: SubscriptionTypesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateSubscriptionTypesByPkArgs = {
  _set?: InputMaybe<SubscriptionTypesSetInput>;
  pkColumns: SubscriptionTypesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateSubscriptionTypesManyArgs = {
  updates: Array<SubscriptionTypesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateSuggestionsArgs = {
  _inc?: InputMaybe<SuggestionsIncInput>;
  _set?: InputMaybe<SuggestionsSetInput>;
  where: SuggestionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateSuggestionsByPkArgs = {
  _inc?: InputMaybe<SuggestionsIncInput>;
  _set?: InputMaybe<SuggestionsSetInput>;
  pkColumns: SuggestionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateSuggestionsManyArgs = {
  updates: Array<SuggestionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateTextItemsArgs = {
  _append?: InputMaybe<TextItemsAppendInput>;
  _deleteAtPath?: InputMaybe<TextItemsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<TextItemsDeleteElemInput>;
  _deleteKey?: InputMaybe<TextItemsDeleteKeyInput>;
  _prepend?: InputMaybe<TextItemsPrependInput>;
  _set?: InputMaybe<TextItemsSetInput>;
  where: TextItemsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateTextItemsByPkArgs = {
  _append?: InputMaybe<TextItemsAppendInput>;
  _deleteAtPath?: InputMaybe<TextItemsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<TextItemsDeleteElemInput>;
  _deleteKey?: InputMaybe<TextItemsDeleteKeyInput>;
  _prepend?: InputMaybe<TextItemsPrependInput>;
  _set?: InputMaybe<TextItemsSetInput>;
  pkColumns: TextItemsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateTextItemsManyArgs = {
  updates: Array<TextItemsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateTranscriptionsArgs = {
  _inc?: InputMaybe<TranscriptionsIncInput>;
  _set?: InputMaybe<TranscriptionsSetInput>;
  where: TranscriptionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateTranscriptionsByPkArgs = {
  _inc?: InputMaybe<TranscriptionsIncInput>;
  _set?: InputMaybe<TranscriptionsSetInput>;
  pkColumns: TranscriptionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateTranscriptionsManyArgs = {
  updates: Array<TranscriptionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUsersArgs = {
  _append?: InputMaybe<UsersAppendInput>;
  _deleteAtPath?: InputMaybe<UsersDeleteAtPathInput>;
  _deleteElem?: InputMaybe<UsersDeleteElemInput>;
  _deleteKey?: InputMaybe<UsersDeleteKeyInput>;
  _inc?: InputMaybe<UsersIncInput>;
  _prepend?: InputMaybe<UsersPrependInput>;
  _set?: InputMaybe<UsersSetInput>;
  where: UsersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUsersByPkArgs = {
  _append?: InputMaybe<UsersAppendInput>;
  _deleteAtPath?: InputMaybe<UsersDeleteAtPathInput>;
  _deleteElem?: InputMaybe<UsersDeleteElemInput>;
  _deleteKey?: InputMaybe<UsersDeleteKeyInput>;
  _inc?: InputMaybe<UsersIncInput>;
  _prepend?: InputMaybe<UsersPrependInput>;
  _set?: InputMaybe<UsersSetInput>;
  pkColumns: UsersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUsersManyArgs = {
  updates: Array<UsersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateVersionsArgs = {
  _append?: InputMaybe<VersionsAppendInput>;
  _deleteAtPath?: InputMaybe<VersionsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<VersionsDeleteElemInput>;
  _deleteKey?: InputMaybe<VersionsDeleteKeyInput>;
  _inc?: InputMaybe<VersionsIncInput>;
  _prepend?: InputMaybe<VersionsPrependInput>;
  _set?: InputMaybe<VersionsSetInput>;
  where: VersionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateVersionsByPkArgs = {
  _append?: InputMaybe<VersionsAppendInput>;
  _deleteAtPath?: InputMaybe<VersionsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<VersionsDeleteElemInput>;
  _deleteKey?: InputMaybe<VersionsDeleteKeyInput>;
  _inc?: InputMaybe<VersionsIncInput>;
  _prepend?: InputMaybe<VersionsPrependInput>;
  _set?: InputMaybe<VersionsSetInput>;
  pkColumns: VersionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateVersionsManyArgs = {
  updates: Array<VersionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateVideoItemsArgs = {
  _inc?: InputMaybe<VideoItemsIncInput>;
  _set?: InputMaybe<VideoItemsSetInput>;
  where: VideoItemsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateVideoItemsByPkArgs = {
  _inc?: InputMaybe<VideoItemsIncInput>;
  _set?: InputMaybe<VideoItemsSetInput>;
  pkColumns: VideoItemsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateVideoItemsManyArgs = {
  updates: Array<VideoItemsUpdates>;
};

export type NotificationsAggregateBoolExpBool_And = {
  arguments: NotificationsSelectColumnNotificationsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<NotificationsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type NotificationsAggregateBoolExpBool_Or = {
  arguments: NotificationsSelectColumnNotificationsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<NotificationsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type NotificationsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<NotificationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<NotificationsBoolExp>;
  predicate: IntComparisonExp;
};

export type ProjectAndFolderOrganizersAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ProjectAndFolderOrganizersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ProjectAndFolderOrganizersBoolExp>;
  predicate: IntComparisonExp;
};

export type ProjectUsersAggregateBoolExpBool_And = {
  arguments: ProjectUsersSelectColumnProjectUsersAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ProjectUsersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ProjectUsersAggregateBoolExpBool_Or = {
  arguments: ProjectUsersSelectColumnProjectUsersAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ProjectUsersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ProjectUsersAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ProjectUsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ProjectUsersBoolExp>;
  predicate: IntComparisonExp;
};

export type ProjectsAggregateBoolExpBool_And = {
  arguments: ProjectsSelectColumnProjectsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ProjectsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ProjectsAggregateBoolExpBool_Or = {
  arguments: ProjectsSelectColumnProjectsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ProjectsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ProjectsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ProjectsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ProjectsBoolExp>;
  predicate: IntComparisonExp;
};

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "account_invoice_stripe_statuses" */
  accountInvoiceStripeStatuses: Array<AccountInvoiceStripeStatuses>;
  /** fetch aggregated fields from the table: "account_invoice_stripe_statuses" */
  accountInvoiceStripeStatusesAggregate: AccountInvoiceStripeStatusesAggregate;
  /** fetch data from the table: "account_invoice_stripe_statuses" using primary key columns */
  accountInvoiceStripeStatusesByPk?: Maybe<AccountInvoiceStripeStatuses>;
  /** fetch data from the table: "account_invoice_types" */
  accountInvoiceTypes: Array<AccountInvoiceTypes>;
  /** fetch aggregated fields from the table: "account_invoice_types" */
  accountInvoiceTypesAggregate: AccountInvoiceTypesAggregate;
  /** fetch data from the table: "account_invoice_types" using primary key columns */
  accountInvoiceTypesByPk?: Maybe<AccountInvoiceTypes>;
  /** An array relationship */
  accountInvoices: Array<AccountInvoices>;
  /** An aggregate relationship */
  accountInvoicesAggregate: AccountInvoicesAggregate;
  /** fetch data from the table: "account_invoices" using primary key columns */
  accountInvoicesByPk?: Maybe<AccountInvoices>;
  /** fetch data from the table: "account_user_roles" */
  accountUserRoles: Array<AccountUserRoles>;
  /** fetch aggregated fields from the table: "account_user_roles" */
  accountUserRolesAggregate: AccountUserRolesAggregate;
  /** fetch data from the table: "account_user_roles" using primary key columns */
  accountUserRolesByPk?: Maybe<AccountUserRoles>;
  /** An array relationship */
  accountUsers: Array<AccountUsers>;
  /** An aggregate relationship */
  accountUsersAggregate: AccountUsersAggregate;
  /** fetch data from the table: "account_users" using primary key columns */
  accountUsersByPk?: Maybe<AccountUsers>;
  /** fetch data from the table: "accounts" */
  accounts: Array<Accounts>;
  /** fetch aggregated fields from the table: "accounts" */
  accountsAggregate: AccountsAggregate;
  /** fetch data from the table: "accounts" using primary key columns */
  accountsByPk?: Maybe<Accounts>;
  /** An array relationship */
  canvasItems: Array<CanvasItems>;
  /** An aggregate relationship */
  canvasItemsAggregate: CanvasItemsAggregate;
  /** fetch data from the table: "canvas_items" using primary key columns */
  canvasItemsByPk?: Maybe<CanvasItems>;
  /** fetch data from the table: "db_event_log_types" */
  dbEventLogTypes: Array<DbEventLogTypes>;
  /** fetch aggregated fields from the table: "db_event_log_types" */
  dbEventLogTypesAggregate: DbEventLogTypesAggregate;
  /** fetch data from the table: "db_event_log_types" using primary key columns */
  dbEventLogTypesByPk?: Maybe<DbEventLogTypes>;
  /** fetch data from the table: "db_event_logs" */
  dbEventLogs: Array<DbEventLogs>;
  /** fetch aggregated fields from the table: "db_event_logs" */
  dbEventLogsAggregate: DbEventLogsAggregate;
  /** fetch data from the table: "db_event_logs" using primary key columns */
  dbEventLogsByPk?: Maybe<DbEventLogs>;
  /** An array relationship */
  documentLabels: Array<DocumentLabels>;
  /** An aggregate relationship */
  documentLabelsAggregate: DocumentLabelsAggregate;
  /** fetch data from the table: "document_labels" using primary key columns */
  documentLabelsByPk?: Maybe<DocumentLabels>;
  /** An array relationship */
  documentUsers: Array<DocumentUsers>;
  /** An aggregate relationship */
  documentUsersAggregate: DocumentUsersAggregate;
  /** fetch data from the table: "document_users" using primary key columns */
  documentUsersByPk?: Maybe<DocumentUsers>;
  /** An array relationship */
  documents: Array<Documents>;
  /** An aggregate relationship */
  documentsAggregate: DocumentsAggregate;
  /** fetch data from the table: "documents" using primary key columns */
  documentsByPk?: Maybe<Documents>;
  /** fetch data from the table: "emails" */
  emails: Array<Emails>;
  /** fetch aggregated fields from the table: "emails" */
  emailsAggregate: EmailsAggregate;
  /** fetch data from the table: "emails" using primary key columns */
  emailsByPk?: Maybe<Emails>;
  /** fetch data from the table: "file_items" */
  fileItems: Array<FileItems>;
  /** fetch aggregated fields from the table: "file_items" */
  fileItemsAggregate: FileItemsAggregate;
  /** fetch data from the table: "file_items" using primary key columns */
  fileItemsByPk?: Maybe<FileItems>;
  getCheckoutSession: CheckoutSession;
  /** getDocumentPermissions */
  getDocumentPermissions?: Maybe<GetDocumentPermissionsOutput>;
  /** getInvoiceUrl */
  getInvoiceUrl: InvoiceUrl;
  getPortalSession: PortalSession;
  /** getReferralStatsByAccount */
  getReferralStatsByAccount?: Maybe<ReferralStats>;
  getSubscription?: Maybe<Subscription>;
  /** fetch data from the table: "guided_tours" */
  guidedTours: Array<GuidedTours>;
  /** fetch aggregated fields from the table: "guided_tours" */
  guidedToursAggregate: GuidedToursAggregate;
  /** fetch data from the table: "guided_tours" using primary key columns */
  guidedToursByPk?: Maybe<GuidedTours>;
  /** An array relationship */
  items: Array<Items>;
  /** An aggregate relationship */
  itemsAggregate: ItemsAggregate;
  /** fetch data from the table: "items" using primary key columns */
  itemsByPk?: Maybe<Items>;
  /** An array relationship */
  labels: Array<Labels>;
  /** An aggregate relationship */
  labelsAggregate: LabelsAggregate;
  /** fetch data from the table: "labels" using primary key columns */
  labelsByPk?: Maybe<Labels>;
  /** An array relationship */
  lanes: Array<Lanes>;
  /** An aggregate relationship */
  lanesAggregate: LanesAggregate;
  /** fetch data from the table: "lanes" using primary key columns */
  lanesByPk?: Maybe<Lanes>;
  /** fetch data from the table: "mentions" */
  mentions: Array<Mentions>;
  /** fetch aggregated fields from the table: "mentions" */
  mentionsAggregate: MentionsAggregate;
  /** fetch data from the table: "mentions" using primary key columns */
  mentionsByPk?: Maybe<Mentions>;
  /** An array relationship */
  messageFiles: Array<MessageFiles>;
  /** An aggregate relationship */
  messageFilesAggregate: MessageFilesAggregate;
  /** fetch data from the table: "message_files" using primary key columns */
  messageFilesByPk?: Maybe<MessageFiles>;
  /** An array relationship */
  messageUsers: Array<MessageUsers>;
  /** An aggregate relationship */
  messageUsersAggregate: MessageUsersAggregate;
  /** fetch data from the table: "message_users" using primary key columns */
  messageUsersByPk?: Maybe<MessageUsers>;
  /** An array relationship */
  messages: Array<Messages>;
  /** An aggregate relationship */
  messagesAggregate: MessagesAggregate;
  /** fetch data from the table: "messages" using primary key columns */
  messagesByPk?: Maybe<Messages>;
  /** fetch data from the table: "my_document_users" */
  myDocumentUsers: Array<MyDocumentUsers>;
  /** fetch aggregated fields from the table: "my_document_users" */
  myDocumentUsersAggregate: MyDocumentUsersAggregate;
  /** fetch data from the table: "my_user_info" */
  myUserInfo: Array<MyUserInfo>;
  /** fetch aggregated fields from the table: "my_user_info" */
  myUserInfoAggregate: MyUserInfoAggregate;
  /** An array relationship */
  notifications: Array<Notifications>;
  /** An aggregate relationship */
  notificationsAggregate: NotificationsAggregate;
  /** fetch data from the table: "notifications" using primary key columns */
  notificationsByPk?: Maybe<Notifications>;
  /** fetch data from the table: "pdf_items" */
  pdfItems: Array<PdfItems>;
  /** fetch aggregated fields from the table: "pdf_items" */
  pdfItemsAggregate: PdfItemsAggregate;
  /** fetch data from the table: "pdf_items" using primary key columns */
  pdfItemsByPk?: Maybe<PdfItems>;
  /** An array relationship */
  projectAndFolderOrganizers: Array<ProjectAndFolderOrganizers>;
  /** An aggregate relationship */
  projectAndFolderOrganizersAggregate: ProjectAndFolderOrganizersAggregate;
  /** fetch data from the table: "project_and_folder_organizers" using primary key columns */
  projectAndFolderOrganizersByPk?: Maybe<ProjectAndFolderOrganizers>;
  /** fetch data from the table: "project_folders" */
  projectFolders: Array<ProjectFolders>;
  /** fetch aggregated fields from the table: "project_folders" */
  projectFoldersAggregate: ProjectFoldersAggregate;
  /** fetch data from the table: "project_folders" using primary key columns */
  projectFoldersByPk?: Maybe<ProjectFolders>;
  /** An array relationship */
  projectUsers: Array<ProjectUsers>;
  /** An aggregate relationship */
  projectUsersAggregate: ProjectUsersAggregate;
  /** fetch data from the table: "project_users" using primary key columns */
  projectUsersByPk?: Maybe<ProjectUsers>;
  /** An array relationship */
  projects: Array<Projects>;
  /** An aggregate relationship */
  projectsAggregate: ProjectsAggregate;
  /** fetch data from the table: "projects" using primary key columns */
  projectsByPk?: Maybe<Projects>;
  /** An array relationship */
  reactions: Array<Reactions>;
  /** An aggregate relationship */
  reactionsAggregate: ReactionsAggregate;
  /** fetch data from the table: "reactions" using primary key columns */
  reactionsByPk?: Maybe<Reactions>;
  /** An array relationship */
  recordings: Array<Recordings>;
  /** An aggregate relationship */
  recordingsAggregate: RecordingsAggregate;
  /** fetch data from the table: "recordings" using primary key columns */
  recordingsByPk?: Maybe<Recordings>;
  /** fetch data from the table: "site_items" */
  siteItems: Array<SiteItems>;
  /** fetch aggregated fields from the table: "site_items" */
  siteItemsAggregate: SiteItemsAggregate;
  /** fetch data from the table: "site_items" using primary key columns */
  siteItemsByPk?: Maybe<SiteItems>;
  /** fetch data from the table: "storage_multi_objects_metadata" */
  storageMultiObjectsMetadata: Array<StorageMultiObjectsMetadata>;
  /** fetch aggregated fields from the table: "storage_multi_objects_metadata" */
  storageMultiObjectsMetadataAggregate: StorageMultiObjectsMetadataAggregate;
  /** fetch data from the table: "storage_multi_objects_metadata" using primary key columns */
  storageMultiObjectsMetadataByPk?: Maybe<StorageMultiObjectsMetadata>;
  /** fetch data from the table: "storage_objects_metadata" */
  storageObjectsMetadata: Array<StorageObjectsMetadata>;
  /** fetch aggregated fields from the table: "storage_objects_metadata" */
  storageObjectsMetadataAggregate: StorageObjectsMetadataAggregate;
  /** fetch data from the table: "storage_objects_metadata" using primary key columns */
  storageObjectsMetadataByPk?: Maybe<StorageObjectsMetadata>;
  /** fetch data from the table: "subscription_statuses" */
  subscriptionStatuses: Array<SubscriptionStatuses>;
  /** fetch aggregated fields from the table: "subscription_statuses" */
  subscriptionStatusesAggregate: SubscriptionStatusesAggregate;
  /** fetch data from the table: "subscription_statuses" using primary key columns */
  subscriptionStatusesByPk?: Maybe<SubscriptionStatuses>;
  /** fetch data from the table: "subscription_types" */
  subscriptionTypes: Array<SubscriptionTypes>;
  /** fetch aggregated fields from the table: "subscription_types" */
  subscriptionTypesAggregate: SubscriptionTypesAggregate;
  /** fetch data from the table: "subscription_types" using primary key columns */
  subscriptionTypesByPk?: Maybe<SubscriptionTypes>;
  /** An array relationship */
  suggestions: Array<Suggestions>;
  /** An aggregate relationship */
  suggestionsAggregate: SuggestionsAggregate;
  /** fetch data from the table: "suggestions" using primary key columns */
  suggestionsByPk?: Maybe<Suggestions>;
  /** fetch data from the table: "text_items" */
  textItems: Array<TextItems>;
  /** fetch aggregated fields from the table: "text_items" */
  textItemsAggregate: TextItemsAggregate;
  /** fetch data from the table: "text_items" using primary key columns */
  textItemsByPk?: Maybe<TextItems>;
  /** An array relationship */
  transcriptions: Array<Transcriptions>;
  /** An aggregate relationship */
  transcriptionsAggregate: TranscriptionsAggregate;
  /** fetch data from the table: "transcriptions" using primary key columns */
  transcriptionsByPk?: Maybe<Transcriptions>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  usersAggregate: UsersAggregate;
  /** fetch data from the table: "users" using primary key columns */
  usersByPk?: Maybe<Users>;
  validateUrl?: Maybe<Scalars['Boolean']['output']>;
  /** An array relationship */
  versions: Array<Versions>;
  /** An aggregate relationship */
  versionsAggregate: VersionsAggregate;
  /** fetch data from the table: "versions" using primary key columns */
  versionsByPk?: Maybe<Versions>;
  /** fetch data from the table: "video_items" */
  videoItems: Array<VideoItems>;
  /** fetch aggregated fields from the table: "video_items" */
  videoItemsAggregate: VideoItemsAggregate;
  /** fetch data from the table: "video_items" using primary key columns */
  videoItemsByPk?: Maybe<VideoItems>;
};


export type Query_RootAccountInvoiceStripeStatusesArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoiceStripeStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoiceStripeStatusesOrderBy>>;
  where?: InputMaybe<AccountInvoiceStripeStatusesBoolExp>;
};


export type Query_RootAccountInvoiceStripeStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoiceStripeStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoiceStripeStatusesOrderBy>>;
  where?: InputMaybe<AccountInvoiceStripeStatusesBoolExp>;
};


export type Query_RootAccountInvoiceStripeStatusesByPkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootAccountInvoiceTypesArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoiceTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoiceTypesOrderBy>>;
  where?: InputMaybe<AccountInvoiceTypesBoolExp>;
};


export type Query_RootAccountInvoiceTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoiceTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoiceTypesOrderBy>>;
  where?: InputMaybe<AccountInvoiceTypesBoolExp>;
};


export type Query_RootAccountInvoiceTypesByPkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootAccountInvoicesArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoicesOrderBy>>;
  where?: InputMaybe<AccountInvoicesBoolExp>;
};


export type Query_RootAccountInvoicesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoicesOrderBy>>;
  where?: InputMaybe<AccountInvoicesBoolExp>;
};


export type Query_RootAccountInvoicesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootAccountUserRolesArgs = {
  distinctOn?: InputMaybe<Array<AccountUserRolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountUserRolesOrderBy>>;
  where?: InputMaybe<AccountUserRolesBoolExp>;
};


export type Query_RootAccountUserRolesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountUserRolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountUserRolesOrderBy>>;
  where?: InputMaybe<AccountUserRolesBoolExp>;
};


export type Query_RootAccountUserRolesByPkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootAccountUsersArgs = {
  distinctOn?: InputMaybe<Array<AccountUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountUsersOrderBy>>;
  where?: InputMaybe<AccountUsersBoolExp>;
};


export type Query_RootAccountUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountUsersOrderBy>>;
  where?: InputMaybe<AccountUsersBoolExp>;
};


export type Query_RootAccountUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootAccountsArgs = {
  distinctOn?: InputMaybe<Array<AccountsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  where?: InputMaybe<AccountsBoolExp>;
};


export type Query_RootAccountsAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  where?: InputMaybe<AccountsBoolExp>;
};


export type Query_RootAccountsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootCanvasItemsArgs = {
  distinctOn?: InputMaybe<Array<CanvasItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CanvasItemsOrderBy>>;
  where?: InputMaybe<CanvasItemsBoolExp>;
};


export type Query_RootCanvasItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CanvasItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CanvasItemsOrderBy>>;
  where?: InputMaybe<CanvasItemsBoolExp>;
};


export type Query_RootCanvasItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootDbEventLogTypesArgs = {
  distinctOn?: InputMaybe<Array<DbEventLogTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DbEventLogTypesOrderBy>>;
  where?: InputMaybe<DbEventLogTypesBoolExp>;
};


export type Query_RootDbEventLogTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<DbEventLogTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DbEventLogTypesOrderBy>>;
  where?: InputMaybe<DbEventLogTypesBoolExp>;
};


export type Query_RootDbEventLogTypesByPkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootDbEventLogsArgs = {
  distinctOn?: InputMaybe<Array<DbEventLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DbEventLogsOrderBy>>;
  where?: InputMaybe<DbEventLogsBoolExp>;
};


export type Query_RootDbEventLogsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DbEventLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DbEventLogsOrderBy>>;
  where?: InputMaybe<DbEventLogsBoolExp>;
};


export type Query_RootDbEventLogsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootDocumentLabelsArgs = {
  distinctOn?: InputMaybe<Array<DocumentLabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentLabelsOrderBy>>;
  where?: InputMaybe<DocumentLabelsBoolExp>;
};


export type Query_RootDocumentLabelsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentLabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentLabelsOrderBy>>;
  where?: InputMaybe<DocumentLabelsBoolExp>;
};


export type Query_RootDocumentLabelsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootDocumentUsersArgs = {
  distinctOn?: InputMaybe<Array<DocumentUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentUsersOrderBy>>;
  where?: InputMaybe<DocumentUsersBoolExp>;
};


export type Query_RootDocumentUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentUsersOrderBy>>;
  where?: InputMaybe<DocumentUsersBoolExp>;
};


export type Query_RootDocumentUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootDocumentsArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


export type Query_RootDocumentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


export type Query_RootDocumentsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootEmailsArgs = {
  distinctOn?: InputMaybe<Array<EmailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
  where?: InputMaybe<EmailsBoolExp>;
};


export type Query_RootEmailsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
  where?: InputMaybe<EmailsBoolExp>;
};


export type Query_RootEmailsByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootFileItemsArgs = {
  distinctOn?: InputMaybe<Array<FileItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FileItemsOrderBy>>;
  where?: InputMaybe<FileItemsBoolExp>;
};


export type Query_RootFileItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<FileItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FileItemsOrderBy>>;
  where?: InputMaybe<FileItemsBoolExp>;
};


export type Query_RootFileItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootGetCheckoutSessionArgs = {
  subscriptionType?: InputMaybe<Actions_SubscriptionTypesEnum>;
};


export type Query_RootGetDocumentPermissionsArgs = {
  args: GetDocumentPermissionsInput;
};


export type Query_RootGetInvoiceUrlArgs = {
  invoiceId: Scalars['String']['input'];
};


export type Query_RootGuidedToursArgs = {
  distinctOn?: InputMaybe<Array<GuidedToursSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GuidedToursOrderBy>>;
  where?: InputMaybe<GuidedToursBoolExp>;
};


export type Query_RootGuidedToursAggregateArgs = {
  distinctOn?: InputMaybe<Array<GuidedToursSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GuidedToursOrderBy>>;
  where?: InputMaybe<GuidedToursBoolExp>;
};


export type Query_RootGuidedToursByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootItemsArgs = {
  distinctOn?: InputMaybe<Array<ItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ItemsOrderBy>>;
  where?: InputMaybe<ItemsBoolExp>;
};


export type Query_RootItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ItemsOrderBy>>;
  where?: InputMaybe<ItemsBoolExp>;
};


export type Query_RootItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootLabelsArgs = {
  distinctOn?: InputMaybe<Array<LabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LabelsOrderBy>>;
  where?: InputMaybe<LabelsBoolExp>;
};


export type Query_RootLabelsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LabelsOrderBy>>;
  where?: InputMaybe<LabelsBoolExp>;
};


export type Query_RootLabelsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootLanesArgs = {
  distinctOn?: InputMaybe<Array<LanesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LanesOrderBy>>;
  where?: InputMaybe<LanesBoolExp>;
};


export type Query_RootLanesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LanesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LanesOrderBy>>;
  where?: InputMaybe<LanesBoolExp>;
};


export type Query_RootLanesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootMentionsArgs = {
  distinctOn?: InputMaybe<Array<MentionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MentionsOrderBy>>;
  where?: InputMaybe<MentionsBoolExp>;
};


export type Query_RootMentionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<MentionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MentionsOrderBy>>;
  where?: InputMaybe<MentionsBoolExp>;
};


export type Query_RootMentionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootMessageFilesArgs = {
  distinctOn?: InputMaybe<Array<MessageFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageFilesOrderBy>>;
  where?: InputMaybe<MessageFilesBoolExp>;
};


export type Query_RootMessageFilesAggregateArgs = {
  distinctOn?: InputMaybe<Array<MessageFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageFilesOrderBy>>;
  where?: InputMaybe<MessageFilesBoolExp>;
};


export type Query_RootMessageFilesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootMessageUsersArgs = {
  distinctOn?: InputMaybe<Array<MessageUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageUsersOrderBy>>;
  where?: InputMaybe<MessageUsersBoolExp>;
};


export type Query_RootMessageUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<MessageUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageUsersOrderBy>>;
  where?: InputMaybe<MessageUsersBoolExp>;
};


export type Query_RootMessageUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootMessagesArgs = {
  distinctOn?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


export type Query_RootMessagesAggregateArgs = {
  distinctOn?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


export type Query_RootMessagesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootMyDocumentUsersArgs = {
  distinctOn?: InputMaybe<Array<MyDocumentUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MyDocumentUsersOrderBy>>;
  where?: InputMaybe<MyDocumentUsersBoolExp>;
};


export type Query_RootMyDocumentUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<MyDocumentUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MyDocumentUsersOrderBy>>;
  where?: InputMaybe<MyDocumentUsersBoolExp>;
};


export type Query_RootMyUserInfoArgs = {
  distinctOn?: InputMaybe<Array<MyUserInfoSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MyUserInfoOrderBy>>;
  where?: InputMaybe<MyUserInfoBoolExp>;
};


export type Query_RootMyUserInfoAggregateArgs = {
  distinctOn?: InputMaybe<Array<MyUserInfoSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MyUserInfoOrderBy>>;
  where?: InputMaybe<MyUserInfoBoolExp>;
};


export type Query_RootNotificationsArgs = {
  distinctOn?: InputMaybe<Array<NotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
  where?: InputMaybe<NotificationsBoolExp>;
};


export type Query_RootNotificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<NotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
  where?: InputMaybe<NotificationsBoolExp>;
};


export type Query_RootNotificationsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPdfItemsArgs = {
  distinctOn?: InputMaybe<Array<PdfItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PdfItemsOrderBy>>;
  where?: InputMaybe<PdfItemsBoolExp>;
};


export type Query_RootPdfItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PdfItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PdfItemsOrderBy>>;
  where?: InputMaybe<PdfItemsBoolExp>;
};


export type Query_RootPdfItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootProjectAndFolderOrganizersArgs = {
  distinctOn?: InputMaybe<Array<ProjectAndFolderOrganizersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectAndFolderOrganizersOrderBy>>;
  where?: InputMaybe<ProjectAndFolderOrganizersBoolExp>;
};


export type Query_RootProjectAndFolderOrganizersAggregateArgs = {
  distinctOn?: InputMaybe<Array<ProjectAndFolderOrganizersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectAndFolderOrganizersOrderBy>>;
  where?: InputMaybe<ProjectAndFolderOrganizersBoolExp>;
};


export type Query_RootProjectAndFolderOrganizersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootProjectFoldersArgs = {
  distinctOn?: InputMaybe<Array<ProjectFoldersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectFoldersOrderBy>>;
  where?: InputMaybe<ProjectFoldersBoolExp>;
};


export type Query_RootProjectFoldersAggregateArgs = {
  distinctOn?: InputMaybe<Array<ProjectFoldersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectFoldersOrderBy>>;
  where?: InputMaybe<ProjectFoldersBoolExp>;
};


export type Query_RootProjectFoldersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootProjectUsersArgs = {
  distinctOn?: InputMaybe<Array<ProjectUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
  where?: InputMaybe<ProjectUsersBoolExp>;
};


export type Query_RootProjectUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<ProjectUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
  where?: InputMaybe<ProjectUsersBoolExp>;
};


export type Query_RootProjectUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootProjectsArgs = {
  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  where?: InputMaybe<ProjectsBoolExp>;
};


export type Query_RootProjectsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  where?: InputMaybe<ProjectsBoolExp>;
};


export type Query_RootProjectsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootReactionsArgs = {
  distinctOn?: InputMaybe<Array<ReactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReactionsOrderBy>>;
  where?: InputMaybe<ReactionsBoolExp>;
};


export type Query_RootReactionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ReactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReactionsOrderBy>>;
  where?: InputMaybe<ReactionsBoolExp>;
};


export type Query_RootReactionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootRecordingsArgs = {
  distinctOn?: InputMaybe<Array<RecordingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RecordingsOrderBy>>;
  where?: InputMaybe<RecordingsBoolExp>;
};


export type Query_RootRecordingsAggregateArgs = {
  distinctOn?: InputMaybe<Array<RecordingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RecordingsOrderBy>>;
  where?: InputMaybe<RecordingsBoolExp>;
};


export type Query_RootRecordingsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootSiteItemsArgs = {
  distinctOn?: InputMaybe<Array<SiteItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SiteItemsOrderBy>>;
  where?: InputMaybe<SiteItemsBoolExp>;
};


export type Query_RootSiteItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SiteItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SiteItemsOrderBy>>;
  where?: InputMaybe<SiteItemsBoolExp>;
};


export type Query_RootSiteItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootStorageMultiObjectsMetadataArgs = {
  distinctOn?: InputMaybe<Array<StorageMultiObjectsMetadataSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StorageMultiObjectsMetadataOrderBy>>;
  where?: InputMaybe<StorageMultiObjectsMetadataBoolExp>;
};


export type Query_RootStorageMultiObjectsMetadataAggregateArgs = {
  distinctOn?: InputMaybe<Array<StorageMultiObjectsMetadataSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StorageMultiObjectsMetadataOrderBy>>;
  where?: InputMaybe<StorageMultiObjectsMetadataBoolExp>;
};


export type Query_RootStorageMultiObjectsMetadataByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootStorageObjectsMetadataArgs = {
  distinctOn?: InputMaybe<Array<StorageObjectsMetadataSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StorageObjectsMetadataOrderBy>>;
  where?: InputMaybe<StorageObjectsMetadataBoolExp>;
};


export type Query_RootStorageObjectsMetadataAggregateArgs = {
  distinctOn?: InputMaybe<Array<StorageObjectsMetadataSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StorageObjectsMetadataOrderBy>>;
  where?: InputMaybe<StorageObjectsMetadataBoolExp>;
};


export type Query_RootStorageObjectsMetadataByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootSubscriptionStatusesArgs = {
  distinctOn?: InputMaybe<Array<SubscriptionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SubscriptionStatusesOrderBy>>;
  where?: InputMaybe<SubscriptionStatusesBoolExp>;
};


export type Query_RootSubscriptionStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<SubscriptionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SubscriptionStatusesOrderBy>>;
  where?: InputMaybe<SubscriptionStatusesBoolExp>;
};


export type Query_RootSubscriptionStatusesByPkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootSubscriptionTypesArgs = {
  distinctOn?: InputMaybe<Array<SubscriptionTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SubscriptionTypesOrderBy>>;
  where?: InputMaybe<SubscriptionTypesBoolExp>;
};


export type Query_RootSubscriptionTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<SubscriptionTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SubscriptionTypesOrderBy>>;
  where?: InputMaybe<SubscriptionTypesBoolExp>;
};


export type Query_RootSubscriptionTypesByPkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootSuggestionsArgs = {
  distinctOn?: InputMaybe<Array<SuggestionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SuggestionsOrderBy>>;
  where?: InputMaybe<SuggestionsBoolExp>;
};


export type Query_RootSuggestionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SuggestionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SuggestionsOrderBy>>;
  where?: InputMaybe<SuggestionsBoolExp>;
};


export type Query_RootSuggestionsByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootTextItemsArgs = {
  distinctOn?: InputMaybe<Array<TextItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TextItemsOrderBy>>;
  where?: InputMaybe<TextItemsBoolExp>;
};


export type Query_RootTextItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<TextItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TextItemsOrderBy>>;
  where?: InputMaybe<TextItemsBoolExp>;
};


export type Query_RootTextItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootTranscriptionsArgs = {
  distinctOn?: InputMaybe<Array<TranscriptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TranscriptionsOrderBy>>;
  where?: InputMaybe<TranscriptionsBoolExp>;
};


export type Query_RootTranscriptionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<TranscriptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TranscriptionsOrderBy>>;
  where?: InputMaybe<TranscriptionsBoolExp>;
};


export type Query_RootTranscriptionsByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type Query_RootUsersArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Query_RootUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Query_RootUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootValidateUrlArgs = {
  url: Scalars['String']['input'];
};


export type Query_RootVersionsArgs = {
  distinctOn?: InputMaybe<Array<VersionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VersionsOrderBy>>;
  where?: InputMaybe<VersionsBoolExp>;
};


export type Query_RootVersionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<VersionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VersionsOrderBy>>;
  where?: InputMaybe<VersionsBoolExp>;
};


export type Query_RootVersionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootVideoItemsArgs = {
  distinctOn?: InputMaybe<Array<VideoItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VideoItemsOrderBy>>;
  where?: InputMaybe<VideoItemsBoolExp>;
};


export type Query_RootVideoItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<VideoItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VideoItemsOrderBy>>;
  where?: InputMaybe<VideoItemsBoolExp>;
};


export type Query_RootVideoItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};

export type ReactionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ReactionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ReactionsBoolExp>;
  predicate: IntComparisonExp;
};

export type RecordingsAggregateBoolExpBool_And = {
  arguments: RecordingsSelectColumnRecordingsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<RecordingsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type RecordingsAggregateBoolExpBool_Or = {
  arguments: RecordingsSelectColumnRecordingsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<RecordingsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type RecordingsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<RecordingsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<RecordingsBoolExp>;
  predicate: IntComparisonExp;
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "account_invoice_stripe_statuses" */
  accountInvoiceStripeStatuses: Array<AccountInvoiceStripeStatuses>;
  /** fetch aggregated fields from the table: "account_invoice_stripe_statuses" */
  accountInvoiceStripeStatusesAggregate: AccountInvoiceStripeStatusesAggregate;
  /** fetch data from the table: "account_invoice_stripe_statuses" using primary key columns */
  accountInvoiceStripeStatusesByPk?: Maybe<AccountInvoiceStripeStatuses>;
  /** fetch data from the table in a streaming manner: "account_invoice_stripe_statuses" */
  accountInvoiceStripeStatusesStream: Array<AccountInvoiceStripeStatuses>;
  /** fetch data from the table: "account_invoice_types" */
  accountInvoiceTypes: Array<AccountInvoiceTypes>;
  /** fetch aggregated fields from the table: "account_invoice_types" */
  accountInvoiceTypesAggregate: AccountInvoiceTypesAggregate;
  /** fetch data from the table: "account_invoice_types" using primary key columns */
  accountInvoiceTypesByPk?: Maybe<AccountInvoiceTypes>;
  /** fetch data from the table in a streaming manner: "account_invoice_types" */
  accountInvoiceTypesStream: Array<AccountInvoiceTypes>;
  /** An array relationship */
  accountInvoices: Array<AccountInvoices>;
  /** An aggregate relationship */
  accountInvoicesAggregate: AccountInvoicesAggregate;
  /** fetch data from the table: "account_invoices" using primary key columns */
  accountInvoicesByPk?: Maybe<AccountInvoices>;
  /** fetch data from the table in a streaming manner: "account_invoices" */
  accountInvoicesStream: Array<AccountInvoices>;
  /** fetch data from the table: "account_user_roles" */
  accountUserRoles: Array<AccountUserRoles>;
  /** fetch aggregated fields from the table: "account_user_roles" */
  accountUserRolesAggregate: AccountUserRolesAggregate;
  /** fetch data from the table: "account_user_roles" using primary key columns */
  accountUserRolesByPk?: Maybe<AccountUserRoles>;
  /** fetch data from the table in a streaming manner: "account_user_roles" */
  accountUserRolesStream: Array<AccountUserRoles>;
  /** An array relationship */
  accountUsers: Array<AccountUsers>;
  /** An aggregate relationship */
  accountUsersAggregate: AccountUsersAggregate;
  /** fetch data from the table: "account_users" using primary key columns */
  accountUsersByPk?: Maybe<AccountUsers>;
  /** fetch data from the table in a streaming manner: "account_users" */
  accountUsersStream: Array<AccountUsers>;
  /** fetch data from the table: "accounts" */
  accounts: Array<Accounts>;
  /** fetch aggregated fields from the table: "accounts" */
  accountsAggregate: AccountsAggregate;
  /** fetch data from the table: "accounts" using primary key columns */
  accountsByPk?: Maybe<Accounts>;
  /** fetch data from the table in a streaming manner: "accounts" */
  accountsStream: Array<Accounts>;
  /** An array relationship */
  canvasItems: Array<CanvasItems>;
  /** An aggregate relationship */
  canvasItemsAggregate: CanvasItemsAggregate;
  /** fetch data from the table: "canvas_items" using primary key columns */
  canvasItemsByPk?: Maybe<CanvasItems>;
  /** fetch data from the table in a streaming manner: "canvas_items" */
  canvasItemsStream: Array<CanvasItems>;
  /** fetch data from the table: "db_event_log_types" */
  dbEventLogTypes: Array<DbEventLogTypes>;
  /** fetch aggregated fields from the table: "db_event_log_types" */
  dbEventLogTypesAggregate: DbEventLogTypesAggregate;
  /** fetch data from the table: "db_event_log_types" using primary key columns */
  dbEventLogTypesByPk?: Maybe<DbEventLogTypes>;
  /** fetch data from the table in a streaming manner: "db_event_log_types" */
  dbEventLogTypesStream: Array<DbEventLogTypes>;
  /** fetch data from the table: "db_event_logs" */
  dbEventLogs: Array<DbEventLogs>;
  /** fetch aggregated fields from the table: "db_event_logs" */
  dbEventLogsAggregate: DbEventLogsAggregate;
  /** fetch data from the table: "db_event_logs" using primary key columns */
  dbEventLogsByPk?: Maybe<DbEventLogs>;
  /** fetch data from the table in a streaming manner: "db_event_logs" */
  dbEventLogsStream: Array<DbEventLogs>;
  /** An array relationship */
  documentLabels: Array<DocumentLabels>;
  /** An aggregate relationship */
  documentLabelsAggregate: DocumentLabelsAggregate;
  /** fetch data from the table: "document_labels" using primary key columns */
  documentLabelsByPk?: Maybe<DocumentLabels>;
  /** fetch data from the table in a streaming manner: "document_labels" */
  documentLabelsStream: Array<DocumentLabels>;
  /** An array relationship */
  documentUsers: Array<DocumentUsers>;
  /** An aggregate relationship */
  documentUsersAggregate: DocumentUsersAggregate;
  /** fetch data from the table: "document_users" using primary key columns */
  documentUsersByPk?: Maybe<DocumentUsers>;
  /** fetch data from the table in a streaming manner: "document_users" */
  documentUsersStream: Array<DocumentUsers>;
  /** An array relationship */
  documents: Array<Documents>;
  /** An aggregate relationship */
  documentsAggregate: DocumentsAggregate;
  /** fetch data from the table: "documents" using primary key columns */
  documentsByPk?: Maybe<Documents>;
  /** fetch data from the table in a streaming manner: "documents" */
  documentsStream: Array<Documents>;
  /** fetch data from the table: "emails" */
  emails: Array<Emails>;
  /** fetch aggregated fields from the table: "emails" */
  emailsAggregate: EmailsAggregate;
  /** fetch data from the table: "emails" using primary key columns */
  emailsByPk?: Maybe<Emails>;
  /** fetch data from the table in a streaming manner: "emails" */
  emailsStream: Array<Emails>;
  /** fetch data from the table: "file_items" */
  fileItems: Array<FileItems>;
  /** fetch aggregated fields from the table: "file_items" */
  fileItemsAggregate: FileItemsAggregate;
  /** fetch data from the table: "file_items" using primary key columns */
  fileItemsByPk?: Maybe<FileItems>;
  /** fetch data from the table in a streaming manner: "file_items" */
  fileItemsStream: Array<FileItems>;
  /** fetch data from the table: "guided_tours" */
  guidedTours: Array<GuidedTours>;
  /** fetch aggregated fields from the table: "guided_tours" */
  guidedToursAggregate: GuidedToursAggregate;
  /** fetch data from the table: "guided_tours" using primary key columns */
  guidedToursByPk?: Maybe<GuidedTours>;
  /** fetch data from the table in a streaming manner: "guided_tours" */
  guidedToursStream: Array<GuidedTours>;
  /** An array relationship */
  items: Array<Items>;
  /** An aggregate relationship */
  itemsAggregate: ItemsAggregate;
  /** fetch data from the table: "items" using primary key columns */
  itemsByPk?: Maybe<Items>;
  /** fetch data from the table in a streaming manner: "items" */
  itemsStream: Array<Items>;
  /** An array relationship */
  labels: Array<Labels>;
  /** An aggregate relationship */
  labelsAggregate: LabelsAggregate;
  /** fetch data from the table: "labels" using primary key columns */
  labelsByPk?: Maybe<Labels>;
  /** fetch data from the table in a streaming manner: "labels" */
  labelsStream: Array<Labels>;
  /** An array relationship */
  lanes: Array<Lanes>;
  /** An aggregate relationship */
  lanesAggregate: LanesAggregate;
  /** fetch data from the table: "lanes" using primary key columns */
  lanesByPk?: Maybe<Lanes>;
  /** fetch data from the table in a streaming manner: "lanes" */
  lanesStream: Array<Lanes>;
  /** fetch data from the table: "mentions" */
  mentions: Array<Mentions>;
  /** fetch aggregated fields from the table: "mentions" */
  mentionsAggregate: MentionsAggregate;
  /** fetch data from the table: "mentions" using primary key columns */
  mentionsByPk?: Maybe<Mentions>;
  /** fetch data from the table in a streaming manner: "mentions" */
  mentionsStream: Array<Mentions>;
  /** An array relationship */
  messageFiles: Array<MessageFiles>;
  /** An aggregate relationship */
  messageFilesAggregate: MessageFilesAggregate;
  /** fetch data from the table: "message_files" using primary key columns */
  messageFilesByPk?: Maybe<MessageFiles>;
  /** fetch data from the table in a streaming manner: "message_files" */
  messageFilesStream: Array<MessageFiles>;
  /** An array relationship */
  messageUsers: Array<MessageUsers>;
  /** An aggregate relationship */
  messageUsersAggregate: MessageUsersAggregate;
  /** fetch data from the table: "message_users" using primary key columns */
  messageUsersByPk?: Maybe<MessageUsers>;
  /** fetch data from the table in a streaming manner: "message_users" */
  messageUsersStream: Array<MessageUsers>;
  /** An array relationship */
  messages: Array<Messages>;
  /** An aggregate relationship */
  messagesAggregate: MessagesAggregate;
  /** fetch data from the table: "messages" using primary key columns */
  messagesByPk?: Maybe<Messages>;
  /** fetch data from the table in a streaming manner: "messages" */
  messagesStream: Array<Messages>;
  /** fetch data from the table: "my_document_users" */
  myDocumentUsers: Array<MyDocumentUsers>;
  /** fetch aggregated fields from the table: "my_document_users" */
  myDocumentUsersAggregate: MyDocumentUsersAggregate;
  /** fetch data from the table in a streaming manner: "my_document_users" */
  myDocumentUsersStream: Array<MyDocumentUsers>;
  /** fetch data from the table: "my_user_info" */
  myUserInfo: Array<MyUserInfo>;
  /** fetch aggregated fields from the table: "my_user_info" */
  myUserInfoAggregate: MyUserInfoAggregate;
  /** fetch data from the table in a streaming manner: "my_user_info" */
  myUserInfoStream: Array<MyUserInfo>;
  /** An array relationship */
  notifications: Array<Notifications>;
  /** An aggregate relationship */
  notificationsAggregate: NotificationsAggregate;
  /** fetch data from the table: "notifications" using primary key columns */
  notificationsByPk?: Maybe<Notifications>;
  /** fetch data from the table in a streaming manner: "notifications" */
  notificationsStream: Array<Notifications>;
  /** fetch data from the table: "pdf_items" */
  pdfItems: Array<PdfItems>;
  /** fetch aggregated fields from the table: "pdf_items" */
  pdfItemsAggregate: PdfItemsAggregate;
  /** fetch data from the table: "pdf_items" using primary key columns */
  pdfItemsByPk?: Maybe<PdfItems>;
  /** fetch data from the table in a streaming manner: "pdf_items" */
  pdfItemsStream: Array<PdfItems>;
  /** An array relationship */
  projectAndFolderOrganizers: Array<ProjectAndFolderOrganizers>;
  /** An aggregate relationship */
  projectAndFolderOrganizersAggregate: ProjectAndFolderOrganizersAggregate;
  /** fetch data from the table: "project_and_folder_organizers" using primary key columns */
  projectAndFolderOrganizersByPk?: Maybe<ProjectAndFolderOrganizers>;
  /** fetch data from the table in a streaming manner: "project_and_folder_organizers" */
  projectAndFolderOrganizersStream: Array<ProjectAndFolderOrganizers>;
  /** fetch data from the table: "project_folders" */
  projectFolders: Array<ProjectFolders>;
  /** fetch aggregated fields from the table: "project_folders" */
  projectFoldersAggregate: ProjectFoldersAggregate;
  /** fetch data from the table: "project_folders" using primary key columns */
  projectFoldersByPk?: Maybe<ProjectFolders>;
  /** fetch data from the table in a streaming manner: "project_folders" */
  projectFoldersStream: Array<ProjectFolders>;
  /** An array relationship */
  projectUsers: Array<ProjectUsers>;
  /** An aggregate relationship */
  projectUsersAggregate: ProjectUsersAggregate;
  /** fetch data from the table: "project_users" using primary key columns */
  projectUsersByPk?: Maybe<ProjectUsers>;
  /** fetch data from the table in a streaming manner: "project_users" */
  projectUsersStream: Array<ProjectUsers>;
  /** An array relationship */
  projects: Array<Projects>;
  /** An aggregate relationship */
  projectsAggregate: ProjectsAggregate;
  /** fetch data from the table: "projects" using primary key columns */
  projectsByPk?: Maybe<Projects>;
  /** fetch data from the table in a streaming manner: "projects" */
  projectsStream: Array<Projects>;
  /** An array relationship */
  reactions: Array<Reactions>;
  /** An aggregate relationship */
  reactionsAggregate: ReactionsAggregate;
  /** fetch data from the table: "reactions" using primary key columns */
  reactionsByPk?: Maybe<Reactions>;
  /** fetch data from the table in a streaming manner: "reactions" */
  reactionsStream: Array<Reactions>;
  /** An array relationship */
  recordings: Array<Recordings>;
  /** An aggregate relationship */
  recordingsAggregate: RecordingsAggregate;
  /** fetch data from the table: "recordings" using primary key columns */
  recordingsByPk?: Maybe<Recordings>;
  /** fetch data from the table in a streaming manner: "recordings" */
  recordingsStream: Array<Recordings>;
  /** fetch data from the table: "site_items" */
  siteItems: Array<SiteItems>;
  /** fetch aggregated fields from the table: "site_items" */
  siteItemsAggregate: SiteItemsAggregate;
  /** fetch data from the table: "site_items" using primary key columns */
  siteItemsByPk?: Maybe<SiteItems>;
  /** fetch data from the table in a streaming manner: "site_items" */
  siteItemsStream: Array<SiteItems>;
  /** fetch data from the table: "storage_multi_objects_metadata" */
  storageMultiObjectsMetadata: Array<StorageMultiObjectsMetadata>;
  /** fetch aggregated fields from the table: "storage_multi_objects_metadata" */
  storageMultiObjectsMetadataAggregate: StorageMultiObjectsMetadataAggregate;
  /** fetch data from the table: "storage_multi_objects_metadata" using primary key columns */
  storageMultiObjectsMetadataByPk?: Maybe<StorageMultiObjectsMetadata>;
  /** fetch data from the table in a streaming manner: "storage_multi_objects_metadata" */
  storageMultiObjectsMetadataStream: Array<StorageMultiObjectsMetadata>;
  /** fetch data from the table: "storage_objects_metadata" */
  storageObjectsMetadata: Array<StorageObjectsMetadata>;
  /** fetch aggregated fields from the table: "storage_objects_metadata" */
  storageObjectsMetadataAggregate: StorageObjectsMetadataAggregate;
  /** fetch data from the table: "storage_objects_metadata" using primary key columns */
  storageObjectsMetadataByPk?: Maybe<StorageObjectsMetadata>;
  /** fetch data from the table in a streaming manner: "storage_objects_metadata" */
  storageObjectsMetadataStream: Array<StorageObjectsMetadata>;
  /** fetch data from the table: "subscription_statuses" */
  subscriptionStatuses: Array<SubscriptionStatuses>;
  /** fetch aggregated fields from the table: "subscription_statuses" */
  subscriptionStatusesAggregate: SubscriptionStatusesAggregate;
  /** fetch data from the table: "subscription_statuses" using primary key columns */
  subscriptionStatusesByPk?: Maybe<SubscriptionStatuses>;
  /** fetch data from the table in a streaming manner: "subscription_statuses" */
  subscriptionStatusesStream: Array<SubscriptionStatuses>;
  /** fetch data from the table: "subscription_types" */
  subscriptionTypes: Array<SubscriptionTypes>;
  /** fetch aggregated fields from the table: "subscription_types" */
  subscriptionTypesAggregate: SubscriptionTypesAggregate;
  /** fetch data from the table: "subscription_types" using primary key columns */
  subscriptionTypesByPk?: Maybe<SubscriptionTypes>;
  /** fetch data from the table in a streaming manner: "subscription_types" */
  subscriptionTypesStream: Array<SubscriptionTypes>;
  /** An array relationship */
  suggestions: Array<Suggestions>;
  /** An aggregate relationship */
  suggestionsAggregate: SuggestionsAggregate;
  /** fetch data from the table: "suggestions" using primary key columns */
  suggestionsByPk?: Maybe<Suggestions>;
  /** fetch data from the table in a streaming manner: "suggestions" */
  suggestionsStream: Array<Suggestions>;
  /** fetch data from the table: "text_items" */
  textItems: Array<TextItems>;
  /** fetch aggregated fields from the table: "text_items" */
  textItemsAggregate: TextItemsAggregate;
  /** fetch data from the table: "text_items" using primary key columns */
  textItemsByPk?: Maybe<TextItems>;
  /** fetch data from the table in a streaming manner: "text_items" */
  textItemsStream: Array<TextItems>;
  /** An array relationship */
  transcriptions: Array<Transcriptions>;
  /** An aggregate relationship */
  transcriptionsAggregate: TranscriptionsAggregate;
  /** fetch data from the table: "transcriptions" using primary key columns */
  transcriptionsByPk?: Maybe<Transcriptions>;
  /** fetch data from the table in a streaming manner: "transcriptions" */
  transcriptionsStream: Array<Transcriptions>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  usersAggregate: UsersAggregate;
  /** fetch data from the table: "users" using primary key columns */
  usersByPk?: Maybe<Users>;
  /** fetch data from the table in a streaming manner: "users" */
  usersStream: Array<Users>;
  /** An array relationship */
  versions: Array<Versions>;
  /** An aggregate relationship */
  versionsAggregate: VersionsAggregate;
  /** fetch data from the table: "versions" using primary key columns */
  versionsByPk?: Maybe<Versions>;
  /** fetch data from the table in a streaming manner: "versions" */
  versionsStream: Array<Versions>;
  /** fetch data from the table: "video_items" */
  videoItems: Array<VideoItems>;
  /** fetch aggregated fields from the table: "video_items" */
  videoItemsAggregate: VideoItemsAggregate;
  /** fetch data from the table: "video_items" using primary key columns */
  videoItemsByPk?: Maybe<VideoItems>;
  /** fetch data from the table in a streaming manner: "video_items" */
  videoItemsStream: Array<VideoItems>;
};


export type Subscription_RootAccountInvoiceStripeStatusesArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoiceStripeStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoiceStripeStatusesOrderBy>>;
  where?: InputMaybe<AccountInvoiceStripeStatusesBoolExp>;
};


export type Subscription_RootAccountInvoiceStripeStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoiceStripeStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoiceStripeStatusesOrderBy>>;
  where?: InputMaybe<AccountInvoiceStripeStatusesBoolExp>;
};


export type Subscription_RootAccountInvoiceStripeStatusesByPkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootAccountInvoiceStripeStatusesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AccountInvoiceStripeStatusesStreamCursorInput>>;
  where?: InputMaybe<AccountInvoiceStripeStatusesBoolExp>;
};


export type Subscription_RootAccountInvoiceTypesArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoiceTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoiceTypesOrderBy>>;
  where?: InputMaybe<AccountInvoiceTypesBoolExp>;
};


export type Subscription_RootAccountInvoiceTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoiceTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoiceTypesOrderBy>>;
  where?: InputMaybe<AccountInvoiceTypesBoolExp>;
};


export type Subscription_RootAccountInvoiceTypesByPkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootAccountInvoiceTypesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AccountInvoiceTypesStreamCursorInput>>;
  where?: InputMaybe<AccountInvoiceTypesBoolExp>;
};


export type Subscription_RootAccountInvoicesArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoicesOrderBy>>;
  where?: InputMaybe<AccountInvoicesBoolExp>;
};


export type Subscription_RootAccountInvoicesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountInvoicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountInvoicesOrderBy>>;
  where?: InputMaybe<AccountInvoicesBoolExp>;
};


export type Subscription_RootAccountInvoicesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootAccountInvoicesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AccountInvoicesStreamCursorInput>>;
  where?: InputMaybe<AccountInvoicesBoolExp>;
};


export type Subscription_RootAccountUserRolesArgs = {
  distinctOn?: InputMaybe<Array<AccountUserRolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountUserRolesOrderBy>>;
  where?: InputMaybe<AccountUserRolesBoolExp>;
};


export type Subscription_RootAccountUserRolesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountUserRolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountUserRolesOrderBy>>;
  where?: InputMaybe<AccountUserRolesBoolExp>;
};


export type Subscription_RootAccountUserRolesByPkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootAccountUserRolesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AccountUserRolesStreamCursorInput>>;
  where?: InputMaybe<AccountUserRolesBoolExp>;
};


export type Subscription_RootAccountUsersArgs = {
  distinctOn?: InputMaybe<Array<AccountUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountUsersOrderBy>>;
  where?: InputMaybe<AccountUsersBoolExp>;
};


export type Subscription_RootAccountUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountUsersOrderBy>>;
  where?: InputMaybe<AccountUsersBoolExp>;
};


export type Subscription_RootAccountUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootAccountUsersStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AccountUsersStreamCursorInput>>;
  where?: InputMaybe<AccountUsersBoolExp>;
};


export type Subscription_RootAccountsArgs = {
  distinctOn?: InputMaybe<Array<AccountsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  where?: InputMaybe<AccountsBoolExp>;
};


export type Subscription_RootAccountsAggregateArgs = {
  distinctOn?: InputMaybe<Array<AccountsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  where?: InputMaybe<AccountsBoolExp>;
};


export type Subscription_RootAccountsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootAccountsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AccountsStreamCursorInput>>;
  where?: InputMaybe<AccountsBoolExp>;
};


export type Subscription_RootCanvasItemsArgs = {
  distinctOn?: InputMaybe<Array<CanvasItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CanvasItemsOrderBy>>;
  where?: InputMaybe<CanvasItemsBoolExp>;
};


export type Subscription_RootCanvasItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CanvasItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CanvasItemsOrderBy>>;
  where?: InputMaybe<CanvasItemsBoolExp>;
};


export type Subscription_RootCanvasItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootCanvasItemsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<CanvasItemsStreamCursorInput>>;
  where?: InputMaybe<CanvasItemsBoolExp>;
};


export type Subscription_RootDbEventLogTypesArgs = {
  distinctOn?: InputMaybe<Array<DbEventLogTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DbEventLogTypesOrderBy>>;
  where?: InputMaybe<DbEventLogTypesBoolExp>;
};


export type Subscription_RootDbEventLogTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<DbEventLogTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DbEventLogTypesOrderBy>>;
  where?: InputMaybe<DbEventLogTypesBoolExp>;
};


export type Subscription_RootDbEventLogTypesByPkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootDbEventLogTypesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<DbEventLogTypesStreamCursorInput>>;
  where?: InputMaybe<DbEventLogTypesBoolExp>;
};


export type Subscription_RootDbEventLogsArgs = {
  distinctOn?: InputMaybe<Array<DbEventLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DbEventLogsOrderBy>>;
  where?: InputMaybe<DbEventLogsBoolExp>;
};


export type Subscription_RootDbEventLogsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DbEventLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DbEventLogsOrderBy>>;
  where?: InputMaybe<DbEventLogsBoolExp>;
};


export type Subscription_RootDbEventLogsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootDbEventLogsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<DbEventLogsStreamCursorInput>>;
  where?: InputMaybe<DbEventLogsBoolExp>;
};


export type Subscription_RootDocumentLabelsArgs = {
  distinctOn?: InputMaybe<Array<DocumentLabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentLabelsOrderBy>>;
  where?: InputMaybe<DocumentLabelsBoolExp>;
};


export type Subscription_RootDocumentLabelsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentLabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentLabelsOrderBy>>;
  where?: InputMaybe<DocumentLabelsBoolExp>;
};


export type Subscription_RootDocumentLabelsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootDocumentLabelsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<DocumentLabelsStreamCursorInput>>;
  where?: InputMaybe<DocumentLabelsBoolExp>;
};


export type Subscription_RootDocumentUsersArgs = {
  distinctOn?: InputMaybe<Array<DocumentUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentUsersOrderBy>>;
  where?: InputMaybe<DocumentUsersBoolExp>;
};


export type Subscription_RootDocumentUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentUsersOrderBy>>;
  where?: InputMaybe<DocumentUsersBoolExp>;
};


export type Subscription_RootDocumentUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootDocumentUsersStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<DocumentUsersStreamCursorInput>>;
  where?: InputMaybe<DocumentUsersBoolExp>;
};


export type Subscription_RootDocumentsArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


export type Subscription_RootDocumentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DocumentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DocumentsOrderBy>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


export type Subscription_RootDocumentsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootDocumentsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<DocumentsStreamCursorInput>>;
  where?: InputMaybe<DocumentsBoolExp>;
};


export type Subscription_RootEmailsArgs = {
  distinctOn?: InputMaybe<Array<EmailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
  where?: InputMaybe<EmailsBoolExp>;
};


export type Subscription_RootEmailsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
  where?: InputMaybe<EmailsBoolExp>;
};


export type Subscription_RootEmailsByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootEmailsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<EmailsStreamCursorInput>>;
  where?: InputMaybe<EmailsBoolExp>;
};


export type Subscription_RootFileItemsArgs = {
  distinctOn?: InputMaybe<Array<FileItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FileItemsOrderBy>>;
  where?: InputMaybe<FileItemsBoolExp>;
};


export type Subscription_RootFileItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<FileItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FileItemsOrderBy>>;
  where?: InputMaybe<FileItemsBoolExp>;
};


export type Subscription_RootFileItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootFileItemsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<FileItemsStreamCursorInput>>;
  where?: InputMaybe<FileItemsBoolExp>;
};


export type Subscription_RootGuidedToursArgs = {
  distinctOn?: InputMaybe<Array<GuidedToursSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GuidedToursOrderBy>>;
  where?: InputMaybe<GuidedToursBoolExp>;
};


export type Subscription_RootGuidedToursAggregateArgs = {
  distinctOn?: InputMaybe<Array<GuidedToursSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GuidedToursOrderBy>>;
  where?: InputMaybe<GuidedToursBoolExp>;
};


export type Subscription_RootGuidedToursByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootGuidedToursStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<GuidedToursStreamCursorInput>>;
  where?: InputMaybe<GuidedToursBoolExp>;
};


export type Subscription_RootItemsArgs = {
  distinctOn?: InputMaybe<Array<ItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ItemsOrderBy>>;
  where?: InputMaybe<ItemsBoolExp>;
};


export type Subscription_RootItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ItemsOrderBy>>;
  where?: InputMaybe<ItemsBoolExp>;
};


export type Subscription_RootItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootItemsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ItemsStreamCursorInput>>;
  where?: InputMaybe<ItemsBoolExp>;
};


export type Subscription_RootLabelsArgs = {
  distinctOn?: InputMaybe<Array<LabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LabelsOrderBy>>;
  where?: InputMaybe<LabelsBoolExp>;
};


export type Subscription_RootLabelsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LabelsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LabelsOrderBy>>;
  where?: InputMaybe<LabelsBoolExp>;
};


export type Subscription_RootLabelsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootLabelsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<LabelsStreamCursorInput>>;
  where?: InputMaybe<LabelsBoolExp>;
};


export type Subscription_RootLanesArgs = {
  distinctOn?: InputMaybe<Array<LanesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LanesOrderBy>>;
  where?: InputMaybe<LanesBoolExp>;
};


export type Subscription_RootLanesAggregateArgs = {
  distinctOn?: InputMaybe<Array<LanesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LanesOrderBy>>;
  where?: InputMaybe<LanesBoolExp>;
};


export type Subscription_RootLanesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootLanesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<LanesStreamCursorInput>>;
  where?: InputMaybe<LanesBoolExp>;
};


export type Subscription_RootMentionsArgs = {
  distinctOn?: InputMaybe<Array<MentionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MentionsOrderBy>>;
  where?: InputMaybe<MentionsBoolExp>;
};


export type Subscription_RootMentionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<MentionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MentionsOrderBy>>;
  where?: InputMaybe<MentionsBoolExp>;
};


export type Subscription_RootMentionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootMentionsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MentionsStreamCursorInput>>;
  where?: InputMaybe<MentionsBoolExp>;
};


export type Subscription_RootMessageFilesArgs = {
  distinctOn?: InputMaybe<Array<MessageFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageFilesOrderBy>>;
  where?: InputMaybe<MessageFilesBoolExp>;
};


export type Subscription_RootMessageFilesAggregateArgs = {
  distinctOn?: InputMaybe<Array<MessageFilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageFilesOrderBy>>;
  where?: InputMaybe<MessageFilesBoolExp>;
};


export type Subscription_RootMessageFilesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootMessageFilesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MessageFilesStreamCursorInput>>;
  where?: InputMaybe<MessageFilesBoolExp>;
};


export type Subscription_RootMessageUsersArgs = {
  distinctOn?: InputMaybe<Array<MessageUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageUsersOrderBy>>;
  where?: InputMaybe<MessageUsersBoolExp>;
};


export type Subscription_RootMessageUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<MessageUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessageUsersOrderBy>>;
  where?: InputMaybe<MessageUsersBoolExp>;
};


export type Subscription_RootMessageUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootMessageUsersStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MessageUsersStreamCursorInput>>;
  where?: InputMaybe<MessageUsersBoolExp>;
};


export type Subscription_RootMessagesArgs = {
  distinctOn?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


export type Subscription_RootMessagesAggregateArgs = {
  distinctOn?: InputMaybe<Array<MessagesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  where?: InputMaybe<MessagesBoolExp>;
};


export type Subscription_RootMessagesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootMessagesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MessagesStreamCursorInput>>;
  where?: InputMaybe<MessagesBoolExp>;
};


export type Subscription_RootMyDocumentUsersArgs = {
  distinctOn?: InputMaybe<Array<MyDocumentUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MyDocumentUsersOrderBy>>;
  where?: InputMaybe<MyDocumentUsersBoolExp>;
};


export type Subscription_RootMyDocumentUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<MyDocumentUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MyDocumentUsersOrderBy>>;
  where?: InputMaybe<MyDocumentUsersBoolExp>;
};


export type Subscription_RootMyDocumentUsersStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MyDocumentUsersStreamCursorInput>>;
  where?: InputMaybe<MyDocumentUsersBoolExp>;
};


export type Subscription_RootMyUserInfoArgs = {
  distinctOn?: InputMaybe<Array<MyUserInfoSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MyUserInfoOrderBy>>;
  where?: InputMaybe<MyUserInfoBoolExp>;
};


export type Subscription_RootMyUserInfoAggregateArgs = {
  distinctOn?: InputMaybe<Array<MyUserInfoSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MyUserInfoOrderBy>>;
  where?: InputMaybe<MyUserInfoBoolExp>;
};


export type Subscription_RootMyUserInfoStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MyUserInfoStreamCursorInput>>;
  where?: InputMaybe<MyUserInfoBoolExp>;
};


export type Subscription_RootNotificationsArgs = {
  distinctOn?: InputMaybe<Array<NotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
  where?: InputMaybe<NotificationsBoolExp>;
};


export type Subscription_RootNotificationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<NotificationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
  where?: InputMaybe<NotificationsBoolExp>;
};


export type Subscription_RootNotificationsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootNotificationsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<NotificationsStreamCursorInput>>;
  where?: InputMaybe<NotificationsBoolExp>;
};


export type Subscription_RootPdfItemsArgs = {
  distinctOn?: InputMaybe<Array<PdfItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PdfItemsOrderBy>>;
  where?: InputMaybe<PdfItemsBoolExp>;
};


export type Subscription_RootPdfItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PdfItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PdfItemsOrderBy>>;
  where?: InputMaybe<PdfItemsBoolExp>;
};


export type Subscription_RootPdfItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPdfItemsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PdfItemsStreamCursorInput>>;
  where?: InputMaybe<PdfItemsBoolExp>;
};


export type Subscription_RootProjectAndFolderOrganizersArgs = {
  distinctOn?: InputMaybe<Array<ProjectAndFolderOrganizersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectAndFolderOrganizersOrderBy>>;
  where?: InputMaybe<ProjectAndFolderOrganizersBoolExp>;
};


export type Subscription_RootProjectAndFolderOrganizersAggregateArgs = {
  distinctOn?: InputMaybe<Array<ProjectAndFolderOrganizersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectAndFolderOrganizersOrderBy>>;
  where?: InputMaybe<ProjectAndFolderOrganizersBoolExp>;
};


export type Subscription_RootProjectAndFolderOrganizersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootProjectAndFolderOrganizersStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ProjectAndFolderOrganizersStreamCursorInput>>;
  where?: InputMaybe<ProjectAndFolderOrganizersBoolExp>;
};


export type Subscription_RootProjectFoldersArgs = {
  distinctOn?: InputMaybe<Array<ProjectFoldersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectFoldersOrderBy>>;
  where?: InputMaybe<ProjectFoldersBoolExp>;
};


export type Subscription_RootProjectFoldersAggregateArgs = {
  distinctOn?: InputMaybe<Array<ProjectFoldersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectFoldersOrderBy>>;
  where?: InputMaybe<ProjectFoldersBoolExp>;
};


export type Subscription_RootProjectFoldersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootProjectFoldersStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ProjectFoldersStreamCursorInput>>;
  where?: InputMaybe<ProjectFoldersBoolExp>;
};


export type Subscription_RootProjectUsersArgs = {
  distinctOn?: InputMaybe<Array<ProjectUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
  where?: InputMaybe<ProjectUsersBoolExp>;
};


export type Subscription_RootProjectUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<ProjectUsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectUsersOrderBy>>;
  where?: InputMaybe<ProjectUsersBoolExp>;
};


export type Subscription_RootProjectUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootProjectUsersStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ProjectUsersStreamCursorInput>>;
  where?: InputMaybe<ProjectUsersBoolExp>;
};


export type Subscription_RootProjectsArgs = {
  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  where?: InputMaybe<ProjectsBoolExp>;
};


export type Subscription_RootProjectsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ProjectsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  where?: InputMaybe<ProjectsBoolExp>;
};


export type Subscription_RootProjectsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootProjectsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ProjectsStreamCursorInput>>;
  where?: InputMaybe<ProjectsBoolExp>;
};


export type Subscription_RootReactionsArgs = {
  distinctOn?: InputMaybe<Array<ReactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReactionsOrderBy>>;
  where?: InputMaybe<ReactionsBoolExp>;
};


export type Subscription_RootReactionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ReactionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReactionsOrderBy>>;
  where?: InputMaybe<ReactionsBoolExp>;
};


export type Subscription_RootReactionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootReactionsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ReactionsStreamCursorInput>>;
  where?: InputMaybe<ReactionsBoolExp>;
};


export type Subscription_RootRecordingsArgs = {
  distinctOn?: InputMaybe<Array<RecordingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RecordingsOrderBy>>;
  where?: InputMaybe<RecordingsBoolExp>;
};


export type Subscription_RootRecordingsAggregateArgs = {
  distinctOn?: InputMaybe<Array<RecordingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RecordingsOrderBy>>;
  where?: InputMaybe<RecordingsBoolExp>;
};


export type Subscription_RootRecordingsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootRecordingsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<RecordingsStreamCursorInput>>;
  where?: InputMaybe<RecordingsBoolExp>;
};


export type Subscription_RootSiteItemsArgs = {
  distinctOn?: InputMaybe<Array<SiteItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SiteItemsOrderBy>>;
  where?: InputMaybe<SiteItemsBoolExp>;
};


export type Subscription_RootSiteItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SiteItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SiteItemsOrderBy>>;
  where?: InputMaybe<SiteItemsBoolExp>;
};


export type Subscription_RootSiteItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootSiteItemsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SiteItemsStreamCursorInput>>;
  where?: InputMaybe<SiteItemsBoolExp>;
};


export type Subscription_RootStorageMultiObjectsMetadataArgs = {
  distinctOn?: InputMaybe<Array<StorageMultiObjectsMetadataSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StorageMultiObjectsMetadataOrderBy>>;
  where?: InputMaybe<StorageMultiObjectsMetadataBoolExp>;
};


export type Subscription_RootStorageMultiObjectsMetadataAggregateArgs = {
  distinctOn?: InputMaybe<Array<StorageMultiObjectsMetadataSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StorageMultiObjectsMetadataOrderBy>>;
  where?: InputMaybe<StorageMultiObjectsMetadataBoolExp>;
};


export type Subscription_RootStorageMultiObjectsMetadataByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootStorageMultiObjectsMetadataStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<StorageMultiObjectsMetadataStreamCursorInput>>;
  where?: InputMaybe<StorageMultiObjectsMetadataBoolExp>;
};


export type Subscription_RootStorageObjectsMetadataArgs = {
  distinctOn?: InputMaybe<Array<StorageObjectsMetadataSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StorageObjectsMetadataOrderBy>>;
  where?: InputMaybe<StorageObjectsMetadataBoolExp>;
};


export type Subscription_RootStorageObjectsMetadataAggregateArgs = {
  distinctOn?: InputMaybe<Array<StorageObjectsMetadataSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StorageObjectsMetadataOrderBy>>;
  where?: InputMaybe<StorageObjectsMetadataBoolExp>;
};


export type Subscription_RootStorageObjectsMetadataByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootStorageObjectsMetadataStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<StorageObjectsMetadataStreamCursorInput>>;
  where?: InputMaybe<StorageObjectsMetadataBoolExp>;
};


export type Subscription_RootSubscriptionStatusesArgs = {
  distinctOn?: InputMaybe<Array<SubscriptionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SubscriptionStatusesOrderBy>>;
  where?: InputMaybe<SubscriptionStatusesBoolExp>;
};


export type Subscription_RootSubscriptionStatusesAggregateArgs = {
  distinctOn?: InputMaybe<Array<SubscriptionStatusesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SubscriptionStatusesOrderBy>>;
  where?: InputMaybe<SubscriptionStatusesBoolExp>;
};


export type Subscription_RootSubscriptionStatusesByPkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootSubscriptionStatusesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SubscriptionStatusesStreamCursorInput>>;
  where?: InputMaybe<SubscriptionStatusesBoolExp>;
};


export type Subscription_RootSubscriptionTypesArgs = {
  distinctOn?: InputMaybe<Array<SubscriptionTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SubscriptionTypesOrderBy>>;
  where?: InputMaybe<SubscriptionTypesBoolExp>;
};


export type Subscription_RootSubscriptionTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<SubscriptionTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SubscriptionTypesOrderBy>>;
  where?: InputMaybe<SubscriptionTypesBoolExp>;
};


export type Subscription_RootSubscriptionTypesByPkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootSubscriptionTypesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SubscriptionTypesStreamCursorInput>>;
  where?: InputMaybe<SubscriptionTypesBoolExp>;
};


export type Subscription_RootSuggestionsArgs = {
  distinctOn?: InputMaybe<Array<SuggestionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SuggestionsOrderBy>>;
  where?: InputMaybe<SuggestionsBoolExp>;
};


export type Subscription_RootSuggestionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SuggestionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SuggestionsOrderBy>>;
  where?: InputMaybe<SuggestionsBoolExp>;
};


export type Subscription_RootSuggestionsByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootSuggestionsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SuggestionsStreamCursorInput>>;
  where?: InputMaybe<SuggestionsBoolExp>;
};


export type Subscription_RootTextItemsArgs = {
  distinctOn?: InputMaybe<Array<TextItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TextItemsOrderBy>>;
  where?: InputMaybe<TextItemsBoolExp>;
};


export type Subscription_RootTextItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<TextItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TextItemsOrderBy>>;
  where?: InputMaybe<TextItemsBoolExp>;
};


export type Subscription_RootTextItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootTextItemsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TextItemsStreamCursorInput>>;
  where?: InputMaybe<TextItemsBoolExp>;
};


export type Subscription_RootTranscriptionsArgs = {
  distinctOn?: InputMaybe<Array<TranscriptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TranscriptionsOrderBy>>;
  where?: InputMaybe<TranscriptionsBoolExp>;
};


export type Subscription_RootTranscriptionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<TranscriptionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TranscriptionsOrderBy>>;
  where?: InputMaybe<TranscriptionsBoolExp>;
};


export type Subscription_RootTranscriptionsByPkArgs = {
  id: Scalars['bigint']['input'];
};


export type Subscription_RootTranscriptionsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TranscriptionsStreamCursorInput>>;
  where?: InputMaybe<TranscriptionsBoolExp>;
};


export type Subscription_RootUsersArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Subscription_RootUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Subscription_RootUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootUsersStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UsersStreamCursorInput>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Subscription_RootVersionsArgs = {
  distinctOn?: InputMaybe<Array<VersionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VersionsOrderBy>>;
  where?: InputMaybe<VersionsBoolExp>;
};


export type Subscription_RootVersionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<VersionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VersionsOrderBy>>;
  where?: InputMaybe<VersionsBoolExp>;
};


export type Subscription_RootVersionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootVersionsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<VersionsStreamCursorInput>>;
  where?: InputMaybe<VersionsBoolExp>;
};


export type Subscription_RootVideoItemsArgs = {
  distinctOn?: InputMaybe<Array<VideoItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VideoItemsOrderBy>>;
  where?: InputMaybe<VideoItemsBoolExp>;
};


export type Subscription_RootVideoItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<VideoItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VideoItemsOrderBy>>;
  where?: InputMaybe<VideoItemsBoolExp>;
};


export type Subscription_RootVideoItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootVideoItemsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<VideoItemsStreamCursorInput>>;
  where?: InputMaybe<VideoItemsBoolExp>;
};

export type SuggestionsAggregateBoolExpBool_And = {
  arguments: SuggestionsSelectColumnSuggestionsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SuggestionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type SuggestionsAggregateBoolExpBool_Or = {
  arguments: SuggestionsSelectColumnSuggestionsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SuggestionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type SuggestionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<SuggestionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SuggestionsBoolExp>;
  predicate: IntComparisonExp;
};

export type TranscriptionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<TranscriptionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TranscriptionsBoolExp>;
  predicate: IntComparisonExp;
};

export type VersionsAggregateBoolExpBool_And = {
  arguments: VersionsSelectColumnVersionsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<VersionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type VersionsAggregateBoolExpBool_Or = {
  arguments: VersionsSelectColumnVersionsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<VersionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type VersionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<VersionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<VersionsBoolExp>;
  predicate: IntComparisonExp;
};

export type CreateAccountUserMutationVariables = Exact<{
  userId: Scalars['uuid']['input'];
  accountId: Scalars['uuid']['input'];
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<AccountUserRolesEnum>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
}>;


export type CreateAccountUserMutation = { __typename?: 'mutation_root', insertAccountUsersOne?: { __typename?: 'AccountUsers', id: string } | null };

export type CreateDocumentUserMutationVariables = Exact<{
  userId: Scalars['uuid']['input'];
  documentId: Scalars['uuid']['input'];
  accountId: Scalars['uuid']['input'];
}>;


export type CreateDocumentUserMutation = { __typename?: 'mutation_root', insertDocumentUsersOne?: { __typename?: 'DocumentUsers', id: string } | null };

export type CreateProjectUserMutationVariables = Exact<{
  userId: Scalars['uuid']['input'];
  projectId: Scalars['uuid']['input'];
  accountId: Scalars['uuid']['input'];
  guest?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
}>;


export type CreateProjectUserMutation = { __typename?: 'mutation_root', insertProjectUsersOne?: { __typename?: 'ProjectUsers', id: string } | null };

export type DeleteAccountUserMutationVariables = Exact<{
  userId: Scalars['uuid']['input'];
  accountId: Scalars['uuid']['input'];
}>;


export type DeleteAccountUserMutation = { __typename?: 'mutation_root', deleteAccountUsers?: { __typename?: 'AccountUsersMutationResponse', affectedRows: number, returning: Array<{ __typename?: 'AccountUsers', id: string, email?: string | null }> } | null };

export type DeleteDocumentUserMutationVariables = Exact<{
  userId: Scalars['uuid']['input'];
  documentId: Scalars['uuid']['input'];
}>;


export type DeleteDocumentUserMutation = { __typename?: 'mutation_root', deleteDocumentUsers?: { __typename?: 'DocumentUsersMutationResponse', affectedRows: number } | null };

export type DeleteProjectUserMutationVariables = Exact<{
  userId: Scalars['uuid']['input'];
  projectId: Scalars['uuid']['input'];
}>;


export type DeleteProjectUserMutation = { __typename?: 'mutation_root', deleteProjectUsers?: { __typename?: 'ProjectUsersMutationResponse', affectedRows: number } | null };

export type UserDocumentsQueryVariables = Exact<{
  userId: Scalars['uuid']['input'];
}>;


export type UserDocumentsQuery = { __typename?: 'query_root', usersByPk?: { __typename?: 'Users', accountUsers: Array<{ __typename?: 'AccountUsers', account: { __typename?: 'Accounts', id: string } }>, projectUsers: Array<{ __typename?: 'ProjectUsers', project: { __typename?: 'Projects', id: string } }>, documentUsers: Array<{ __typename?: 'DocumentUsers', document: { __typename?: 'Documents', id: string, project?: { __typename?: 'Projects', id: string } | null } }> } | null };

export type GetUserIdQueryVariables = Exact<{
  email: Scalars['String']['input'];
}>;


export type GetUserIdQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'Users', id: string }> };

export type UserOverviewFragment = { __typename?: 'Users', id: string, email: string, firstName?: string | null, lastName?: string | null, profilePictureUrl?: string | null, createdAt: string, lastSignInAt?: string | null, accountUsers: Array<{ __typename?: 'AccountUsers', account: { __typename?: 'Accounts', id: string, name: string, projects: Array<{ __typename?: 'Projects', id: string, name?: string | null, documents: Array<{ __typename?: 'Documents', id: string, name: string, slug: string }> }> } }> };

export type UserDataByIdQueryVariables = Exact<{
  userId: Scalars['uuid']['input'];
}>;


export type UserDataByIdQuery = { __typename?: 'query_root', usersByPk?: { __typename?: 'Users', id: string, email: string, firstName?: string | null, lastName?: string | null, profilePictureUrl?: string | null, createdAt: string, lastSignInAt?: string | null, accountUsers: Array<{ __typename?: 'AccountUsers', account: { __typename?: 'Accounts', id: string, name: string, projects: Array<{ __typename?: 'Projects', id: string, name?: string | null, documents: Array<{ __typename?: 'Documents', id: string, name: string, slug: string }> }> } }> } | null };

export const UserOverviewFragmentDoc = gql`
    fragment UserOverview on Users {
  id
  email
  firstName
  lastName
  profilePictureUrl
  createdAt
  lastSignInAt
  accountUsers {
    account {
      id
      name
      projects {
        id
        name
        documents {
          id
          name
          slug
        }
      }
    }
  }
}
    `;
export const CreateAccountUserDocument = gql`
    mutation CreateAccountUser($userId: uuid!, $accountId: uuid!, $firstName: String = null, $lastName: String = null, $email: String = null, $role: AccountUserRolesEnum = TEAMMATE, $createdAt: timestamp = "NOW()", $updatedAt: timestamp = "NOW()") {
  insertAccountUsersOne(
    object: {userId: $userId, accountId: $accountId, firstName: $firstName, lastName: $lastName, email: $email, role: $role, createdAt: $createdAt, updatedAt: $updatedAt}
  ) {
    id
  }
}
    `;
export type CreateAccountUserMutationFn = Apollo.MutationFunction<CreateAccountUserMutation, CreateAccountUserMutationVariables>;

/**
 * __useCreateAccountUserMutation__
 *
 * To run a mutation, you first call `useCreateAccountUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAccountUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAccountUserMutation, { data, loading, error }] = useCreateAccountUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      accountId: // value for 'accountId'
 *      firstName: // value for 'firstName'
 *      lastName: // value for 'lastName'
 *      email: // value for 'email'
 *      role: // value for 'role'
 *      createdAt: // value for 'createdAt'
 *      updatedAt: // value for 'updatedAt'
 *   },
 * });
 */
export function useCreateAccountUserMutation(baseOptions?: Apollo.MutationHookOptions<CreateAccountUserMutation, CreateAccountUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAccountUserMutation, CreateAccountUserMutationVariables>(CreateAccountUserDocument, options);
      }
export type CreateAccountUserMutationHookResult = ReturnType<typeof useCreateAccountUserMutation>;
export type CreateAccountUserMutationResult = Apollo.MutationResult<CreateAccountUserMutation>;
export type CreateAccountUserMutationOptions = Apollo.BaseMutationOptions<CreateAccountUserMutation, CreateAccountUserMutationVariables>;
export const CreateDocumentUserDocument = gql`
    mutation CreateDocumentUser($userId: uuid!, $documentId: uuid!, $accountId: uuid!) {
  insertDocumentUsersOne(
    object: {userId: $userId, documentId: $documentId, accountId: $accountId, guest: true}
  ) {
    id
  }
}
    `;
export type CreateDocumentUserMutationFn = Apollo.MutationFunction<CreateDocumentUserMutation, CreateDocumentUserMutationVariables>;

/**
 * __useCreateDocumentUserMutation__
 *
 * To run a mutation, you first call `useCreateDocumentUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDocumentUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDocumentUserMutation, { data, loading, error }] = useCreateDocumentUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      documentId: // value for 'documentId'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useCreateDocumentUserMutation(baseOptions?: Apollo.MutationHookOptions<CreateDocumentUserMutation, CreateDocumentUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDocumentUserMutation, CreateDocumentUserMutationVariables>(CreateDocumentUserDocument, options);
      }
export type CreateDocumentUserMutationHookResult = ReturnType<typeof useCreateDocumentUserMutation>;
export type CreateDocumentUserMutationResult = Apollo.MutationResult<CreateDocumentUserMutation>;
export type CreateDocumentUserMutationOptions = Apollo.BaseMutationOptions<CreateDocumentUserMutation, CreateDocumentUserMutationVariables>;
export const CreateProjectUserDocument = gql`
    mutation CreateProjectUser($userId: uuid!, $projectId: uuid!, $accountId: uuid!, $guest: Boolean = true, $createdAt: timestamp = "NOW()", $updatedAt: timestamp = "NOW()") {
  insertProjectUsersOne(
    object: {userId: $userId, projectId: $projectId, accountId: $accountId, guest: $guest, createdAt: $createdAt, updatedAt: $updatedAt}
  ) {
    id
  }
}
    `;
export type CreateProjectUserMutationFn = Apollo.MutationFunction<CreateProjectUserMutation, CreateProjectUserMutationVariables>;

/**
 * __useCreateProjectUserMutation__
 *
 * To run a mutation, you first call `useCreateProjectUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateProjectUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createProjectUserMutation, { data, loading, error }] = useCreateProjectUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      projectId: // value for 'projectId'
 *      accountId: // value for 'accountId'
 *      guest: // value for 'guest'
 *      createdAt: // value for 'createdAt'
 *      updatedAt: // value for 'updatedAt'
 *   },
 * });
 */
export function useCreateProjectUserMutation(baseOptions?: Apollo.MutationHookOptions<CreateProjectUserMutation, CreateProjectUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateProjectUserMutation, CreateProjectUserMutationVariables>(CreateProjectUserDocument, options);
      }
export type CreateProjectUserMutationHookResult = ReturnType<typeof useCreateProjectUserMutation>;
export type CreateProjectUserMutationResult = Apollo.MutationResult<CreateProjectUserMutation>;
export type CreateProjectUserMutationOptions = Apollo.BaseMutationOptions<CreateProjectUserMutation, CreateProjectUserMutationVariables>;
export const DeleteAccountUserDocument = gql`
    mutation DeleteAccountUser($userId: uuid!, $accountId: uuid!) {
  deleteAccountUsers(
    where: {userId: {_eq: $userId}, accountId: {_eq: $accountId}}
  ) {
    affectedRows
    returning {
      id
      email
    }
  }
}
    `;
export type DeleteAccountUserMutationFn = Apollo.MutationFunction<DeleteAccountUserMutation, DeleteAccountUserMutationVariables>;

/**
 * __useDeleteAccountUserMutation__
 *
 * To run a mutation, you first call `useDeleteAccountUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAccountUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAccountUserMutation, { data, loading, error }] = useDeleteAccountUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      accountId: // value for 'accountId'
 *   },
 * });
 */
export function useDeleteAccountUserMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAccountUserMutation, DeleteAccountUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAccountUserMutation, DeleteAccountUserMutationVariables>(DeleteAccountUserDocument, options);
      }
export type DeleteAccountUserMutationHookResult = ReturnType<typeof useDeleteAccountUserMutation>;
export type DeleteAccountUserMutationResult = Apollo.MutationResult<DeleteAccountUserMutation>;
export type DeleteAccountUserMutationOptions = Apollo.BaseMutationOptions<DeleteAccountUserMutation, DeleteAccountUserMutationVariables>;
export const DeleteDocumentUserDocument = gql`
    mutation DeleteDocumentUser($userId: uuid!, $documentId: uuid!) {
  deleteDocumentUsers(
    where: {_and: [{userId: {_eq: $userId}}, {documentId: {_eq: $documentId}}]}
  ) {
    affectedRows
  }
}
    `;
export type DeleteDocumentUserMutationFn = Apollo.MutationFunction<DeleteDocumentUserMutation, DeleteDocumentUserMutationVariables>;

/**
 * __useDeleteDocumentUserMutation__
 *
 * To run a mutation, you first call `useDeleteDocumentUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteDocumentUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteDocumentUserMutation, { data, loading, error }] = useDeleteDocumentUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      documentId: // value for 'documentId'
 *   },
 * });
 */
export function useDeleteDocumentUserMutation(baseOptions?: Apollo.MutationHookOptions<DeleteDocumentUserMutation, DeleteDocumentUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteDocumentUserMutation, DeleteDocumentUserMutationVariables>(DeleteDocumentUserDocument, options);
      }
export type DeleteDocumentUserMutationHookResult = ReturnType<typeof useDeleteDocumentUserMutation>;
export type DeleteDocumentUserMutationResult = Apollo.MutationResult<DeleteDocumentUserMutation>;
export type DeleteDocumentUserMutationOptions = Apollo.BaseMutationOptions<DeleteDocumentUserMutation, DeleteDocumentUserMutationVariables>;
export const DeleteProjectUserDocument = gql`
    mutation DeleteProjectUser($userId: uuid!, $projectId: uuid!) {
  deleteProjectUsers(
    where: {userId: {_eq: $userId}, projectId: {_eq: $projectId}}
  ) {
    affectedRows
  }
}
    `;
export type DeleteProjectUserMutationFn = Apollo.MutationFunction<DeleteProjectUserMutation, DeleteProjectUserMutationVariables>;

/**
 * __useDeleteProjectUserMutation__
 *
 * To run a mutation, you first call `useDeleteProjectUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteProjectUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteProjectUserMutation, { data, loading, error }] = useDeleteProjectUserMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      projectId: // value for 'projectId'
 *   },
 * });
 */
export function useDeleteProjectUserMutation(baseOptions?: Apollo.MutationHookOptions<DeleteProjectUserMutation, DeleteProjectUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteProjectUserMutation, DeleteProjectUserMutationVariables>(DeleteProjectUserDocument, options);
      }
export type DeleteProjectUserMutationHookResult = ReturnType<typeof useDeleteProjectUserMutation>;
export type DeleteProjectUserMutationResult = Apollo.MutationResult<DeleteProjectUserMutation>;
export type DeleteProjectUserMutationOptions = Apollo.BaseMutationOptions<DeleteProjectUserMutation, DeleteProjectUserMutationVariables>;
export const UserDocumentsDocument = gql`
    query UserDocuments($userId: uuid!) {
  usersByPk(id: $userId) {
    accountUsers {
      account {
        id
      }
    }
    projectUsers {
      project {
        id
      }
    }
    documentUsers {
      document {
        id
        project {
          id
        }
      }
    }
  }
}
    `;

/**
 * __useUserDocumentsQuery__
 *
 * To run a query within a React component, call `useUserDocumentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserDocumentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserDocumentsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserDocumentsQuery(baseOptions: Apollo.QueryHookOptions<UserDocumentsQuery, UserDocumentsQueryVariables> & ({ variables: UserDocumentsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserDocumentsQuery, UserDocumentsQueryVariables>(UserDocumentsDocument, options);
      }
export function useUserDocumentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserDocumentsQuery, UserDocumentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserDocumentsQuery, UserDocumentsQueryVariables>(UserDocumentsDocument, options);
        }
export function useUserDocumentsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<UserDocumentsQuery, UserDocumentsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UserDocumentsQuery, UserDocumentsQueryVariables>(UserDocumentsDocument, options);
        }
export type UserDocumentsQueryHookResult = ReturnType<typeof useUserDocumentsQuery>;
export type UserDocumentsLazyQueryHookResult = ReturnType<typeof useUserDocumentsLazyQuery>;
export type UserDocumentsSuspenseQueryHookResult = ReturnType<typeof useUserDocumentsSuspenseQuery>;
export type UserDocumentsQueryResult = Apollo.QueryResult<UserDocumentsQuery, UserDocumentsQueryVariables>;
export const GetUserIdDocument = gql`
    query GetUserId($email: String!) {
  users(where: {email: {_eq: $email}}) {
    id
  }
}
    `;

/**
 * __useGetUserIdQuery__
 *
 * To run a query within a React component, call `useGetUserIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUserIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUserIdQuery({
 *   variables: {
 *      email: // value for 'email'
 *   },
 * });
 */
export function useGetUserIdQuery(baseOptions: Apollo.QueryHookOptions<GetUserIdQuery, GetUserIdQueryVariables> & ({ variables: GetUserIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUserIdQuery, GetUserIdQueryVariables>(GetUserIdDocument, options);
      }
export function useGetUserIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUserIdQuery, GetUserIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUserIdQuery, GetUserIdQueryVariables>(GetUserIdDocument, options);
        }
export function useGetUserIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetUserIdQuery, GetUserIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetUserIdQuery, GetUserIdQueryVariables>(GetUserIdDocument, options);
        }
export type GetUserIdQueryHookResult = ReturnType<typeof useGetUserIdQuery>;
export type GetUserIdLazyQueryHookResult = ReturnType<typeof useGetUserIdLazyQuery>;
export type GetUserIdSuspenseQueryHookResult = ReturnType<typeof useGetUserIdSuspenseQuery>;
export type GetUserIdQueryResult = Apollo.QueryResult<GetUserIdQuery, GetUserIdQueryVariables>;
export const UserDataByIdDocument = gql`
    query UserDataById($userId: uuid!) {
  usersByPk(id: $userId) {
    ...UserOverview
  }
}
    ${UserOverviewFragmentDoc}`;

/**
 * __useUserDataByIdQuery__
 *
 * To run a query within a React component, call `useUserDataByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserDataByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserDataByIdQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useUserDataByIdQuery(baseOptions: Apollo.QueryHookOptions<UserDataByIdQuery, UserDataByIdQueryVariables> & ({ variables: UserDataByIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserDataByIdQuery, UserDataByIdQueryVariables>(UserDataByIdDocument, options);
      }
export function useUserDataByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserDataByIdQuery, UserDataByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserDataByIdQuery, UserDataByIdQueryVariables>(UserDataByIdDocument, options);
        }
export function useUserDataByIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<UserDataByIdQuery, UserDataByIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UserDataByIdQuery, UserDataByIdQueryVariables>(UserDataByIdDocument, options);
        }
export type UserDataByIdQueryHookResult = ReturnType<typeof useUserDataByIdQuery>;
export type UserDataByIdLazyQueryHookResult = ReturnType<typeof useUserDataByIdLazyQuery>;
export type UserDataByIdSuspenseQueryHookResult = ReturnType<typeof useUserDataByIdSuspenseQuery>;
export type UserDataByIdQueryResult = Apollo.QueryResult<UserDataByIdQuery, UserDataByIdQueryVariables>;